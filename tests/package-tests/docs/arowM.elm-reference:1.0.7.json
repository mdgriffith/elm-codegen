[
    {
        "name": "Reference",
        "comment": " `Reference` is a concept to handle immutable data structure flexibly as using \"reference\" in mutable languages.\n\n\n# Primitives\n\n@docs Reference\n@docs this\n@docs root\n@docs rootWith\n\n\n# Constructors\n\n@docs fromRecord\n@docs top\n\n\n# Operators\n\n@docs modify\n@docs map\n\n",
        "unions": [
            {
                "name": "Reference",
                "comment": " A core data type to realize references of mutable programing languages in Elm.\nAfter modifying target value by `modify` function, `root` value is also updated as an example bellow.\n\n    ref : Reference Int (List Int)\n    ref = fromRecord\n        { this = 3\n        , rootWith = \\x -> [1,2] ++ x :: [4,5]\n        }\n\n    this ref\n    --> 3\n\n    root ref\n    --> [ 1, 2, 3, 4, 5 ]\n\n    ref2 : Reference Int (List Int)\n    ref2 = modify (\\n -> n + 1) ref\n\n    this ref2\n    --> 4\n\n    root ref2\n    --> [ 1, 2, 4, 4, 5 ]\n\n",
                "args": [
                    "a",
                    "root"
                ],
                "cases": []
            }
        ],
        "aliases": [],
        "values": [
            {
                "name": "fromRecord",
                "comment": " A constructor for `Reference`.\n",
                "type": "{ this : a, rootWith : a -> root } -> Reference.Reference a root"
            },
            {
                "name": "map",
                "comment": " Change root object type by providing convert function.\n\n    ref : Reference Int (List Int)\n    ref = fromRecord\n        { this = 4\n        , rootWith = \\x ->\n            x :: [5]\n        }\n\n    rootWith : List Int -> List (List Int)\n    rootWith ls =\n        [[2, 3]] ++ [ls] ++ [[6, 7]]\n\n    newRef : Reference Int (List (List Int))\n    newRef = map rootWith ref\n\n    this ref\n    --> 4\n\n    root ref\n    --> [4, 5]\n\n    this newRef\n    --> 4\n\n    root newRef\n    --> [[2,3], [4,5], [6,7]]\n\n    modifiedRef : Reference Int (List (List Int))\n    modifiedRef = modify (\\_ -> 8) newRef\n\n    this modifiedRef\n    --> 8\n\n    root modifiedRef\n    --> [[2,3], [8,5], [6,7]]\n\n",
                "type": "(b -> c) -> Reference.Reference a b -> Reference.Reference a c"
            },
            {
                "name": "modify",
                "comment": " Modify an object. It makes root object also changed.\n\n    ref : Reference Int (List Int)\n    ref = fromRecord\n        { this = 2\n        , rootWith = \\x -> [1] ++ [x] ++ [3]\n        }\n\n    modifiedRef : Reference Int (List Int)\n    modifiedRef = modify (\\n -> n * 10) ref\n\n    this modifiedRef\n    --> 20\n\n    root modifiedRef\n    --> [1, 20, 3]\n\n",
                "type": "(a -> a) -> Reference.Reference a root -> Reference.Reference a root"
            },
            {
                "name": "root",
                "comment": " Pick out root object from `Reference` value.\n\n    ref : Reference Int (List Int)\n    ref = fromRecord\n        { this = 2\n        , rootWith = \\x -> [1] ++ [x] ++ [3]\n        }\n\n    root ref\n    --> [1, 2, 3]\n\n",
                "type": "Reference.Reference a root -> root"
            },
            {
                "name": "rootWith",
                "comment": " Pick out root object from `Reference` value by specifying `this` value.\n\n    rootWith ref a == root <| modify (\\_ -> a) ref\n\n",
                "type": "Reference.Reference a root -> a -> root"
            },
            {
                "name": "this",
                "comment": " Get focused object from `Reference` value.\n\n    ref : Reference Int (List Int)\n    ref = fromRecord\n        { this = 2\n        , rootWith = \\x -> [1] ++ [x] ++ [3]\n        }\n\n    this ref\n    --> 2\n\n",
                "type": "Reference.Reference a root -> a"
            },
            {
                "name": "top",
                "comment": " A constructor for `Reference` to create top root object.\n\n    ref : Reference (Maybe Int) (Maybe Int)\n    ref = top (Just 3)\n\n    this ref\n    --> Just 3\n\n    root ref\n    --> Just 3\n\n",
                "type": "a -> Reference.Reference a a"
            }
        ],
        "binops": []
    },
    {
        "name": "Reference.List",
        "comment": " `List` specific functions for `Reference`.\n\n@docs unwrap\n\n",
        "unions": [],
        "aliases": [],
        "values": [
            {
                "name": "unwrap",
                "comment": " Map and unwrap to list.\nThis is especially useful for updating list of sub views in the Elm architecture.\n\nSee more about [README](http://package.elm-lang.org/packages/arowM/elm-reference/latest)\n\n",
                "type": "(Reference.Reference a x -> b) -> Reference.Reference (List.List a) x -> List.List b"
            }
        ],
        "binops": []
    }
]