[
    {
        "name": "VegaLite",
        "comment": " Create Vega-Lite visualization specifications in Elm. This package allows you\nto generate the JSON specs that may be passed to the Vega-Lite runtime library via\na port to activate the visualization. Alternatively, to avoid coding the link to\nthe Vega-Lite runtime, you can embed specifications directly in a\n[litvis document](https://github.com/gicentre/litvis).\n\n1.  [Creating a Specification](#1-creating-a-vega-lite-specification)\n2.  [Specifying the Data to Visualize](#2-specifying-the-data-to-visualize)\n3.  [Transforming Data](#3-transforming-data)\n4.  [Specifying Marks](#4-specifying-marks)\n5.  [Encoding Data as Channels](#5-encoding-data-as-channels)\n6.  [View Composition](#6-view-composition)\n7.  [Parameters](#7-parameters)\n8.  [Top-level Settings](#8-top-level-settings)\n9.  [General Data Functions](#9-general-data-functions)\n10. [Type Reference](#10-type-reference)\n\n---\n\n\n# 1. Creating A Vega-Lite Specification\n\n@docs toVegaLite\n@docs VLProperty\n@docs Spec\n@docs LabelledSpec\n@docs combineSpecs\n\n---\n\n\n# 2. Specifying the Data to Visualize\n\nTo create a visualization, you will need to specify what data you wish to visualize.\nFor context, see the\n[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/data.html#format).\n\n  - [2.1 Geographic Data](#2-1-geographic-data)\n  - [2.2 Data Generators](#2-2-data-generators)\n  - [2.3 Formatting Input Data](#2-3-formatting-input-data)\n\n@docs dataFromUrl\n@docs dataFromColumns\n@docs dataColumn\n@docs dataFromRows\n@docs dataRow\n@docs dataFromJson\n@docs jsonToSpec\n@docs dataFromSource\n@docs dataName\n@docs datasets\n@docs noData\n@docs Data\n@docs DataColumn\n@docs DataRow\n\n\n## 2.1 Geographic Data\n\n@docs geometry\n@docs geoFeatureCollection\n@docs geometryCollection\n@docs geoPoint\n@docs geoPoints\n@docs geoLine\n@docs geoLines\n@docs geoPolygon\n@docs geoPolygons\n\n\n## 2.2 Data Generators\n\nFunctions that create new data sources.\n\n@docs dataSequence\n@docs dataSequenceAs\n@docs sphere\n@docs graticule\n\n@docs grStep\n@docs grStepMajor\n@docs grStepMinor\n@docs grExtent\n@docs grExtentMajor\n@docs grExtentMinor\n@docs grPrecision\n\n\n## 2.3 Formatting Input Data\n\nSee the Vega-Lite\n[format](https://vega.github.io/vega-lite/docs/data.html#format) and\n[JSON](https://vega.github.io/vega-lite/docs/data.html#json) documentation.\n\n@docs csv\n@docs tsv\n@docs dsv\n@docs arrow\n@docs jsonProperty\n@docs topojsonFeature\n@docs topojsonMesh\n@docs parse\n\n@docs foNum\n@docs foBoo\n@docs foDate\n@docs foUtc\n\n---\n\n\n# 3. Transforming Data\n\nTransformation rules are applied to data fields or geospatial coordinates before\nthey are encoded visually.\n\n  - [3.1 Map Projections](#3-1-map-projections)\n  - [3.2 Aggregation](#3-2-aggregation)\n  - [3.3 Binning](#3-3-binning)\n  - [3.4 Stacking](#3-4-stacking)\n  - [3.5 Data Calculation](#3-5-data-calculation)\n  - [3.6 Filtering](#3-6-filtering)\n  - [3.7 Flattening](#3-7-flattening)\n  - [3.8 Folding and Pivoting](#3-8-folding-and-pivoting)\n  - [3.9 Relational Joining](#3-9-relational-joining)\n  - [3.10 Data Imputation](#3-10-data-imputation)\n  - [3.11 Data Sampling](#3-11-data-sampling)\n  - [3.12 Density Estimation](#3-12-density-estimation)\n  - [3.13 Loess Trend Calculation](#3-13-loess-trend-calculation)\n  - [3.14 Regression Calculation](#3-14-regression-calculation)\n  - [3.15] Quantile Calculation](#3-15-quantile-calculation)\n  - [3.16 Window Transformations](#3-16-window-transformations)\n\n@docs transform\n\n\n## 3.1 Map Projections\n\nSee the\n[Vega-Lite map projection documentation](https://vega.github.io/vega-lite/docs/projection.html).\n\n@docs projection\n\n@docs prNumExpr\n\n@docs prType\n@docs prExpr\n@docs prClipAngle\n@docs prClipExtent\n@docs prFit\n@docs prCenter\n@docs prCenterExpr\n@docs prScale\n@docs prTranslate\n@docs prTranslateExpr\n@docs prRotate\n@docs prRotateExpr\n@docs prPrecision\n@docs prCoefficient\n@docs prDistance\n@docs prFraction\n@docs prLobes\n@docs prParallel\n@docs prParallels\n@docs prParallelsExpr\n@docs prPointRadius\n@docs prRadius\n@docs prRatio\n@docs prReflectX\n@docs prReflectY\n@docs prSpacing\n@docs prTilt\n\n@docs albers\n@docs albersUsa\n@docs azimuthalEqualArea\n@docs azimuthalEquidistant\n@docs conicConformal\n@docs conicEqualArea\n@docs conicEquidistant\n@docs equalEarth\n@docs equirectangular\n@docs gnomonic\n@docs identityProjection\n@docs mercator\n@docs naturalEarth1\n@docs orthographic\n@docs stereographic\n@docs transverseMercator\n@docs customProjection\n@docs noClip\n@docs clipRect\n@docs clipRectExpr\n\n\n## 3.2 Aggregation\n\nSee the\n[Vega-Lite aggregate documentation](https://vega.github.io/vega-lite/docs/aggregate.html).\n\n@docs aggregate\n@docs joinAggregate\n@docs opAs\n@docs timeUnitAs\n@docs opArgMax\n@docs opArgMin\n@docs opCI0\n@docs opCI1\n@docs opCount\n@docs opDistinct\n@docs opMax\n@docs opMean\n@docs opMedian\n@docs opMin\n@docs opMissing\n@docs opProduct\n@docs opQ1\n@docs opQ3\n@docs opStderr\n@docs opStdev\n@docs opStdevP\n@docs opSum\n@docs opValid\n@docs opVariance\n@docs opVarianceP\n\n\n## 3.3 Binning\n\nSee the [Vega-Lite binning documentation](https://vega.github.io/vega-lite/docs/bin.html).\n\n@docs binAs\n@docs biAnchor\n@docs biBase\n@docs biDivide\n@docs biExtent\n@docs biSelectionExtent\n@docs biMaxBins\n@docs biMinStep\n@docs biNice\n@docs biStep\n@docs biSteps\n\n\n## 3.4 Stacking\n\nSee the [Vega-Lite stack documentation](https://vega.github.io/vega-lite/docs/stack.html)\n\n@docs stack\n@docs stOffset\n@docs stNormalize\n@docs stCenter\n@docs stZero\n@docs stNone\n@docs stSort\n@docs stAscending\n@docs stDescending\n\n\n## 3.5 Data Calculation\n\nSee\n[Vega-Lite calculate documentation](https://vega.github.io/vega-lite/docs/calculate.html).\n\n@docs calculateAs\n\n\n## 3.6 Filtering\n\nSee the\n[Vega-Lite filter documentation](https://vega.github.io/vega-lite/docs/filter.html).\n\n@docs filter\n\n@docs fiEqual\n@docs fiLessThan\n@docs fiLessThanEq\n@docs fiGreaterThan\n@docs fiGreaterThanEq\n@docs fiExpr\n@docs fiSelection\n@docs fiSelectionEmpty\n@docs fiOp\n@docs fiOpTrans\n@docs fiCompose\n@docs fiOneOf\n@docs fiRange\n@docs fiValid\n@docs numRange\n@docs dtRange\n\n\n## 3.7 Flattening\n\nSee the Vega-Lite [flatten](https://vega.github.io/vega-lite/docs/flatten.html)\nand [fold](https://vega.github.io/vega-lite/docs/fold.html) documentation.\n\n@docs flatten\n@docs flattenAs\n\n\n## 3.8 Folding and Pivoting\n\nData tidying operations that reshape the rows and columns of a dataset.\nSee the Vega-Lite [fold](https://vega.github.io/vega-lite/docs/fold.html) and\n[pivot](https://vega.github.io/vega-lite/docs/pivot.html) documentation.\n\n@docs fold\n@docs foldAs\n\n@docs pivot\n@docs piGroupBy\n@docs piLimit\n@docs piOp\n\n\n## 3.9 Relational Joining\n\nCreate lookups between data tables in order to join values from multiple sources.\nSee the [Vega-Lite lookup documentation](https://vega.github.io/vega-lite/docs/lookup.html).\n\n@docs lookup\n@docs lookupSelection\n@docs luFields\n@docs luFieldsWithDefault\n@docs luFieldsAs\n@docs luFieldsAsWithDefault\n@docs luAs\n@docs luAsWithDefault\n\n\n## 3.10 Data Imputation\n\nImpute missing data. See the\n[Vega-Lite impute documentation](https://vega.github.io/vega-lite/docs/impute.html#transform).\n\n@docs impute\n@docs imFrame\n@docs imKeyVals\n@docs imKeyValSequence\n@docs imMethod\n@docs imGroupBy\n@docs imNewValue\n@docs imValue\n@docs imMean\n@docs imMedian\n@docs imMax\n@docs imMin\n\n\n## 3.11 Data Sampling\n\nSee the [Vega-Lite sample documentation](https://vega.github.io/vega-lite/docs/sample.html)\n\n@docs sample\n\n\n## 3.12 Density Estimation\n\nSee the [Vega-Lite density documentation](https://vega.github.io/vega-lite/docs/density.html)\n\n@docs density\n@docs dnGroupBy\n@docs dnCumulative\n@docs dnCounts\n@docs dnBandwidth\n@docs dnExtent\n@docs dnMinSteps\n@docs dnMaxSteps\n@docs dnSteps\n@docs dnAs\n\n\n## 3.13 Loess Trend Calculation\n\nSee the [Vega-Lite loess documentation](https://vega.github.io/vega-lite/docs/loess.html)\n\n@docs loess\n@docs lsGroupBy\n@docs lsBandwidth\n@docs lsAs\n\n\n## 3.14 Regression Calculation\n\nSee the [Vega-Lite regression documentation](https://vega.github.io/vega-lite/docs/regression.html)\n\n@docs regression\n@docs rgGroupBy\n@docs rgMethod\n@docs rgOrder\n@docs rgExtent\n@docs rgParams\n@docs rgAs\n\n@docs rgLinear\n@docs rgLog\n@docs rgExp\n@docs rgPow\n@docs rgQuad\n@docs rgPoly\n\n\n## 3.15 Quantile Calculation\n\n@docs quantile\n@docs qtGroupBy\n@docs qtProbs\n@docs qtStep\n@docs qtAs\n\n\n## 3.16 Window Transformations\n\nSee the Vega-Lite\n[window transform field](https://vega.github.io/vega-lite/docs/window.html#field-def)\nand [window transform](https://vega.github.io/vega-lite/docs/window.html#window-transform-definition)\ndocumentation.\n\n@docs window\n@docs wiAggregateOp\n@docs wiOp\n@docs wiParam\n@docs wiField\n@docs woRowNumber\n@docs woRank\n@docs woDenseRank\n@docs woPercentRank\n@docs woCumeDist\n@docs woPercentile\n@docs woLag\n@docs woLead\n@docs woFirstValue\n@docs woLastValue\n@docs woNthValue\n@docs wiFrame\n@docs wiIgnorePeers\n@docs wiGroupBy\n@docs wiSort\n@docs wiAscending\n@docs wiDescending\n\n---\n\n\n# 4. Specifying Marks\n\nFunctions for declaring the type of visual marks used to represent encoded data.\n\n  - 4.1 [Types of Mark](#4-1-types-of-mark)\n  - 4.2 [Mark Properties](#4-2-mark-properties)\n\n\n## 4.1 Types of Mark\n\n@docs arc\n@docs area\n@docs bar\n@docs boxplot\n@docs errorband\n@docs errorbar\n@docs circle\n@docs geoshape\n@docs image\n@docs line\n@docs point\n@docs rect\n@docs rule\n@docs square\n@docs textMark\n@docs tick\n@docs trail\n\n\n## 4.2 Mark Properties\n\nSee the Vega-Lite\n[general mark](https://vega.github.io/vega-lite/docs/mark.html#general-mark-properties),\n[area mark](https://vega.github.io/vega-lite/docs/area.html#properties),\n[bar mark](https://vega.github.io/vega-lite/docs/bar.html#properties),\n[boxplot](https://vega.github.io/vega-lite/docs/boxplot.html#properties),\n[circle mark](https://vega.github.io/vega-lite/docs/circle.html#properties),\n[error band](https://vega.github.io/vega-lite/docs/errorband.html#properties),\n[error bar](https://vega.github.io/vega-lite/docs/errorbar.html#properties),\n[hyperlink mark](https://vega.github.io/vega-lite/docs/mark.html#hyperlink),\n[image mark](https://vega.github.io/vega-lite/docs/image.html#properties),\n[line mark](https://vega.github.io/vega-lite/docs/line.html#properties),\n[point mark](https://vega.github.io/vega-lite/docs/point.html#properties),\n[rect mark](https://vega.github.io/vega-lite/docs/rect.html#properties),\n[rule mark](https://vega.github.io/vega-lite/docs/rule.html#properties),\n[square mark](https://vega.github.io/vega-lite/docs/square.html#properties),\n[text mark](https://vega.github.io/vega-lite/docs/text.html#properties) and\n[tick mark](https://vega.github.io/vega-lite/docs/tick.html#properties)\nproperty documentation.\n\n@docs maBooExpr\n@docs maNumExpr\n@docs maNumsExpr\n@docs maStrExpr\n\n@docs maAlign\n@docs maAngle\n@docs maAria\n@docs maBandSize\n@docs maBaseline\n@docs maBinSpacing\n@docs maBlend\n@docs maBorders\n@docs maBox\n@docs maClip\n@docs maRemoveInvalid\n@docs maColor\n@docs maColorGradient\n@docs maCornerRadius\n@docs maCornerRadiusEnd\n@docs maCornerRadiusTopLeft\n@docs maCornerRadiusTopRight\n@docs maCornerRadiusBottomLeft\n@docs maCornerRadiusBottomRight\n@docs maCursor\n@docs maExtent\n@docs maHRef\n@docs maContinuousBandSize\n@docs maDiscreteBandSize\n@docs maLimit\n@docs maDir\n@docs maEllipsis\n@docs maDx\n@docs maDy\n@docs maInnerRadius\n@docs maOuterRadius\n@docs maPadAngle\n@docs maFill\n@docs maFillGradient\n@docs maFilled\n@docs maFillOpacity\n@docs maFont\n@docs maFontSize\n@docs maFontStyle\n@docs maFontWeight\n@docs maInterpolate\n@docs maOpacity\n@docs maOrder\n@docs maOrient\n@docs maPoint\n@docs maLine\n@docs maMedian\n@docs maOutliers\n@docs maRadius\n@docs maRule\n@docs maShape\n@docs maShortTimeLabels\n@docs maSize\n@docs maStroke\n@docs maStrokeGradient\n@docs maStrokeCap\n@docs caRound\n@docs caSquare\n@docs caButt\n@docs caExpr\n@docs maStrokeDash\n@docs maStrokeDashOffset\n@docs maStrokeJoin\n@docs joRound\n@docs joBevel\n@docs joMiter\n@docs joExpr\n@docs maStrokeMiterLimit\n@docs maStrokeOpacity\n@docs maStrokeWidth\n@docs maStyle\n@docs maTension\n@docs maText\n@docs maLineHeight\n@docs maTheta\n@docs maTheta2\n@docs maThickness\n@docs maTicks\n@docs maTooltip\n@docs maUrl\n@docs maWidth\n@docs maWidthBand\n@docs maHeight\n@docs maHeightBand\n@docs maX\n@docs maY\n@docs maXOffset\n@docs maYOffset\n@docs maThetaOffset\n@docs maTheta2Offset\n@docs maX2\n@docs maY2\n@docs maX2Offset\n@docs maY2Offset\n@docs maRadiusOffset\n@docs maRadius2Offset\n@docs maAspect\n\n\n### 4.2.1 Color Gradients\n\n@docs grLinear\n@docs grRadial\n@docs grX1\n@docs grX2\n@docs grY1\n@docs grY2\n@docs grR1\n@docs grR2\n@docs grStops\n\n\n### 4.2.2 Used by Mark Properties\n\n@docs arEnable\n@docs arDisable\n@docs arDescription\n@docs arExpr\n\n@docs moHorizontal\n@docs moVertical\n@docs miBasis\n@docs miBasisOpen\n@docs miBasisClosed\n@docs miBundle\n@docs miCardinal\n@docs miCardinalOpen\n@docs miCardinalClosed\n@docs miLinear\n@docs miLinearClosed\n@docs miMonotone\n@docs miStepwise\n@docs miStepAfter\n@docs miStepBefore\n@docs miExpr\n\n@docs tdLeftToRight\n@docs tdRightToLeft\n@docs tdExpr\n\n@docs symCircle\n@docs symCross\n@docs symDiamond\n@docs symSquare\n@docs symTriangleUp\n@docs symTriangleDown\n@docs symTriangleLeft\n@docs symTriangleRight\n@docs symPath\n@docs symStroke\n@docs symArrow\n@docs symWedge\n@docs symTriangle\n@docs symExpr\n@docs pmNone\n@docs pmTransparent\n@docs pmMarker\n@docs lmMarker\n@docs lmNone\n@docs exRange\n@docs exCi\n@docs exIqr\n@docs exIqrScale\n@docs exStderr\n@docs exStdev\n@docs ttData\n@docs ttEncoding\n@docs ttNone\n\n\n### 4.2.3 Blend Modes\n\n@docs bmNormal\n@docs bmMultiply\n@docs bmScreen\n@docs bmOverlay\n@docs bmDarken\n@docs bmLighten\n@docs bmColorDodge\n@docs bmColorBurn\n@docs bmHardLight\n@docs bmSoftLight\n@docs bmDifference\n@docs bmExclusion\n@docs bmHue\n@docs bmSaturation\n@docs bmColor\n@docs bmLuminosity\n@docs bmExpr\n\n\n### 4.2.4 Cursors\n\nSee the\n[CSS cursor documentation](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#Keyword%20values)\n\n@docs cuAuto\n@docs cuDefault\n@docs cuNone\n@docs cuContextMenu\n@docs cuHelp\n@docs cuPointer\n@docs cuProgress\n@docs cuWait\n@docs cuCell\n@docs cuCrosshair\n@docs cuText\n@docs cuVerticalText\n@docs cuAlias\n@docs cuCopy\n@docs cuMove\n@docs cuNoDrop\n@docs cuNotAllowed\n@docs cuAllScroll\n@docs cuColResize\n@docs cuRowResize\n@docs cuNResize\n@docs cuEResize\n@docs cuSResize\n@docs cuWResize\n@docs cuNEResize\n@docs cuNWResize\n@docs cuSEResize\n@docs cuSWResize\n@docs cuEWResize\n@docs cuNSResize\n@docs cuNESWResize\n@docs cuNWSEResize\n@docs cuZoomIn\n@docs cuZoomOut\n@docs cuGrab\n@docs cuGrabbing\n@docs cuExpr\n\n---\n\n\n# 5. Encoding Data as Channels\n\nDescribes the mapping between data fields and the channels (position, color etc.)\nused to determine the visual appearance of marks that represent them.\n\n  - 5.1 [Position Channel](#5-1-position-channel)\n  - 5.2 [Mark Channels](#5-2-mark-channels)\n  - 5.3 [Text Channel](#5-3-text-channel)\n  - 5.4 [Hyperlink Channel](#5-4-hyperlink-channel)\n  - 5.5 [URL Channel](#5-5-url-channel)\n  - 5.6 [Order Channel](#5-6-order-channel)\n  - 5.7 [Facet Channels](#5-7-facet-channels)\n  - 5.8 [Level of Detail Channel](#5-8-level-of-detail-channel)\n  - 5.9 [Key Channel](#5-9-key-channel)\n  - 5.10 [Scaling](#5-10-scaling)\n\n@docs encoding\n@docs Measurement\n\n\n## 5.1 Position channel\n\nRelates to where something appears in the visualization.\nSee the\n[Vega-Lite position documentation](https://vega.github.io/vega-lite/docs/encoding.html#position)\n\n@docs position\n@docs Position\n\n\n### 5.1.1 Position Channel Properties\n\n@docs pName\n@docs pDatum\n@docs pRepeat\n@docs pRepeatDatum\n@docs pNominal\n@docs pOrdinal\n@docs pQuant\n@docs pTemporal\n@docs pGeo\n@docs pBin\n@docs pBinned\n@docs pTimeUnit\n@docs pTitle\n@docs pAggregate\n@docs pScale\n@docs pAxis\n@docs pSort\n@docs pBandPosition\n@docs pStack\n@docs pWidth\n@docs pHeight\n@docs pNum\n@docs pImpute\n\n\n### 5.1.2 Sorting Properties\n\nSee the\n[Vega-Lite sort documentation](https://vega.github.io/vega-lite/docs/sort.html).\n\n@docs soAscending\n@docs soDescending\n@docs soByField\n@docs soByChannel\n@docs soByRepeat\n@docs soCustom\n\n\n### 5.1.3 Axis Properties\n\nSee the\n[Vega-Lite axis property documentation](https://vega.github.io/vega-lite/docs/axis.html#axis-properties)\n\n@docs axBooExpr\n@docs axcoBooExpr\n@docs axNumExpr\n@docs axcoNumExpr\n@docs axNumsExpr\n@docs axcoNumsExpr\n@docs axStrExpr\n@docs axcoStrExpr\n\n\n#### General\n\n@docs axAria\n@docs axBandPosition\n@docs axMaxExtent\n@docs axMinExtent\n@docs axOrient\n@docs axOffset\n@docs axPosition\n@docs axZIndex\n@docs axDataCondition\n@docs axStyle\n@docs axTranslate\n\n\n#### Axis Domain\n\n@docs axDomain\n@docs axDomainDash\n@docs axDomainDashOffset\n@docs axDomainCap\n@docs axDomainColor\n@docs axDomainOpacity\n@docs axDomainWidth\n\n\n#### Axis Labels\n\n@docs axFormat\n@docs axFormatAsNum\n@docs axFormatAsTemporal\n@docs axFormatAsCustom\n@docs axLabels\n@docs axLabelAlign\n@docs cAxLabelAlign\n@docs axLabelAngle\n@docs axLabelBaseline\n@docs cAxLabelBaseline\n@docs axLabelBound\n@docs axLabelBoundExpr\n@docs axLabelColor\n@docs cAxLabelColor\n@docs axLabelExpr\n@docs axLabelFlush\n@docs axLabelFlushOffset\n@docs axLabelFont\n@docs cAxLabelFont\n@docs axLabelFontSize\n@docs cAxLabelFontSize\n@docs axLabelFontStyle\n@docs cAxLabelFontStyle\n@docs axLabelFontWeight\n@docs cAxLabelFontWeight\n@docs axLabelLimit\n@docs axLabelLineHeight\n@docs axLabelOffset\n@docs cAxLabelOffset\n@docs axLabelOpacity\n@docs cAxLabelOpacity\n@docs axLabelOverlap\n@docs axLabelPadding\n@docs cAxLabelPadding\n@docs axLabelSeparation\n\n\n#### Axis Ticks\n\n@docs axTicks\n@docs axTickBand\n@docs tbCenter\n@docs tbExtent\n@docs tbExpr\n@docs axTickCap\n@docs axTickColor\n@docs cAxTickColor\n@docs axTickCount\n@docs axTickDash\n@docs cAxTickDash\n@docs axTickDashOffset\n@docs cAxTickDashOffset\n@docs axTickExtra\n@docs axTickMinStep\n@docs axTickOffset\n@docs axTickOpacity\n@docs cAxTickOpacity\n@docs axTickRound\n@docs axTickSize\n@docs cAxTickSize\n@docs axTickWidth\n@docs cAxTickWidth\n@docs axValues\n\n\n#### Axis Title\n\n@docs axTitle\n@docs axTitleAlign\n@docs axTitleAnchor\n@docs axTitleAngle\n@docs axTitleBaseline\n@docs axTitleColor\n@docs axTitleFont\n@docs axTitleFontSize\n@docs axTitleFontStyle\n@docs axTitleFontWeight\n@docs axTitleLimit\n@docs axTitleLineHeight\n@docs axTitleOpacity\n@docs axTitlePadding\n@docs axTitleX\n@docs axTitleY\n\n\n#### Axis Grid\n\n@docs axGrid\n@docs axGridCap\n@docs axGridColor\n@docs cAxGridColor\n@docs axGridDash\n@docs cAxGridDash\n@docs axGridDashOffset\n@docs cAxGridDashOffset\n@docs axGridOpacity\n@docs cAxGridOpacity\n@docs axGridWidth\n@docs cAxGridWidth\n\n\n### 5.1.4 Positioning Constants\n\n\n#### Text Alignment\n\n@docs haLeft\n@docs haCenter\n@docs haRight\n@docs haExpr\n\n@docs vaTop\n@docs vaLineTop\n@docs vaMiddle\n@docs vaBottom\n@docs vaLineBottom\n@docs vaAlphabetic\n@docs vaExpr\n\n\n#### Overlapping text\n\n@docs osNone\n@docs osGreedy\n@docs osParity\n@docs osExpr\n\n\n### Relative Position\n\n@docs siTop\n@docs siBottom\n@docs siLeft\n@docs siRight\n@docs siExpr\n\n\n## 5.2 Mark Channels\n\nAppearance of the visual marks in the visualization such as their color or size.\n\n@docs size\n@docs angle\n@docs color\n@docs fill\n@docs stroke\n@docs strokeDash\n@docs strokeWidth\n@docs opacity\n@docs fillOpacity\n@docs strokeOpacity\n@docs shape\n\n\n### 5.2.1 Mark Channel Properties\n\n@docs mName\n@docs mDatum\n@docs mRepeat\n@docs mRepeatDatum\n@docs mNominal\n@docs mOrdinal\n@docs mQuant\n@docs mTemporal\n@docs mGeo\n@docs mScale\n@docs mBin\n@docs mBinned\n@docs mBand\n@docs mSort\n@docs mTimeUnit\n@docs mTitle\n@docs mAggregate\n@docs mLegend\n@docs mPath\n@docs mNum\n@docs mStr\n@docs mBoo\n@docs mSymbol\n\n\n### 5.2.2 Mark Legends\n\nSee the\n[Vega-Lite legend property documentation](https://vega.github.io/vega-lite/docs/legend.html#legend-properties).\n\n@docs leNumExpr\n@docs lecoNumExpr\n@docs leNumsExpr\n@docs lecoNumsExpr\n@docs leStrExpr\n@docs lecoStrExpr\n\n@docs leAria\n@docs leGradient\n@docs leSymbol\n@docs leClipHeight\n@docs leColumnPadding\n@docs leColumns\n@docs leCornerRadius\n@docs leDirection\n@docs leFillColor\n@docs leFormat\n@docs leFormatAsNum\n@docs leFormatAsTemporal\n@docs leFormatAsCustom\n@docs leGradientLength\n@docs lecoGradientHorizontalMaxLength\n@docs lecoGradientHorizontalMinLength\n@docs lecoGradientVerticalMaxLength\n@docs lecoGradientVerticalMinLength\n@docs leGradientOpacity\n@docs leGradientThickness\n@docs leGradientStrokeColor\n@docs leGradientStrokeWidth\n@docs leGridAlign\n@docs leLabelAlign\n@docs leLabelBaseline\n@docs leLabelColor\n@docs leLabelExpr\n@docs leLabelFont\n@docs leLabelFontSize\n@docs leLabelFontStyle\n@docs leLabelFontWeight\n@docs leLabelLimit\n@docs leLabelOffset\n@docs leLabelOverlap\n@docs leOffset\n@docs leOrient\n@docs lePadding\n@docs leRowPadding\n@docs leStrokeColor\n@docs leStrokeWidth\n@docs leSymbolDash\n@docs leSymbolDashOffset\n@docs leSymbolFillColor\n@docs leSymbolLimit\n@docs leSymbolOffset\n@docs leSymbolOpacity\n@docs leSymbolSize\n@docs leSymbolStrokeColor\n@docs leSymbolStrokeWidth\n@docs leSymbolType\n@docs leTickCount\n@docs leTitle\n@docs leTitleAlign\n@docs leTitleAnchor\n@docs leTitleBaseline\n@docs leTitleColor\n@docs leTitleFont\n@docs leTitleFontSize\n@docs leTitleFontStyle\n@docs leTitleFontWeight\n@docs leTitleLimit\n@docs leTitleLineHeight\n@docs leTitleOpacity\n@docs leTitleOrient\n@docs leTitlePadding\n@docs leType\n@docs leValues\n@docs leX\n@docs leY\n@docs leZIndex\n\n\n#### Legend Constants\n\n@docs loLeft\n@docs loRight\n@docs loTop\n@docs loBottom\n@docs loTopLeft\n@docs loTopRight\n@docs loBottomLeft\n@docs loBottomRight\n@docs loNone\n\n\n## 5.3 Text Channel\n\nRelate to the appearance of the text and tooltip elements of the visualization.\nSee the\n[Vega-Lite text documentation](https://vega.github.io/vega-lite/docs/encoding.html#text)\n\n@docs text\n@docs tooltip\n@docs tooltips\n@docs tName\n@docs tRepeat\n@docs tNominal\n@docs tOrdinal\n@docs tQuant\n@docs tTemporal\n@docs tGeo\n@docs tBin\n@docs tBinned\n@docs tAggregate\n@docs tTimeUnit\n@docs tTitle\n@docs tStr\n@docs tDatum\n@docs tFormat\n@docs tFormatAsNum\n@docs tFormatAsTemporal\n@docs tFormatAsCustom\n@docs FontWeight\n@docs fwBold\n@docs fwBolder\n@docs fwLighter\n@docs fwNormal\n@docs fwValue\n@docs fwExpr\n\n\n## 5.4 Hyperlink Channel\n\nRelates to a clickable URL destination of a mark. Unlike most other channels, the\nhyperlink channel has no direct visual expression other than the option of changing\nthe cursor style when hovering, so an encoding will usually pair hyperlinks with\nother visual channels such as marks or texts. See the\n[Vega-Lite hyperlink documentation](https://vega.github.io/vega-lite/docs/encoding.html#href)\n\n@docs hyperlink\n@docs hName\n@docs hRepeat\n@docs hNominal\n@docs hOrdinal\n@docs hQuant\n@docs hTemporal\n@docs hGeo\n@docs hBin\n@docs hBinned\n@docs hAggregate\n@docs hTimeUnit\n@docs hStr\n\n\n## 5.5 URL Channel\n\nData-driven URL used for [image](#image) specification. A data field can contain\nURL strings defining the location of image files that can be shown with the [image](#image)\nmark.\n\n@docs url\n\n\n## 5.6 Order Channel\n\nChannel that relate to the order of data fields such as for sorting stacking order\nor order of data points in a connected scatterplot. See the\n[Vega-Lite order documentation](https://vega.github.io/vega-lite/docs/encoding.html#order).\n\n@docs order\n@docs oName\n@docs oRepeat\n@docs oNominal\n@docs oOrdinal\n@docs oQuant\n@docs oTemporal\n@docs oGeo\n@docs oBin\n@docs oAggregate\n@docs oSort\n@docs oTimeUnit\n@docs oNum\n\n\n## 5.7 Facet Channels\n\nChannel for faceting single plots into small multiples. Can be used to create\ntrellis plots or other arrangements in rows and columns. See the\n[Vega-Lite facet documentation](https://vega.github.io/vega-lite/docs/facet.html).\nSee also, 'faceted view composition' for a more flexible (but more verbose) way\nof defining faceted views.\n\n@docs row\n@docs column\n\n\n## 5.8 Level of Detail Channel\n\nUsed for grouping data but without changing the visual appearance of a mark. When,\nfor example, a field is encoded by color, all data items with the same value for\nthat field are given the same color. When a detail channel encodes a field, all\ndata items with the same value are placed in the same group. See the\n[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/encoding.html#detail).\n\n@docs detail\n@docs dName\n@docs dNominal\n@docs dOrdinal\n@docs dQuant\n@docs dTemporal\n@docs dGeo\n@docs dAggregate\n@docs dBin\n@docs dTimeUnit\n\n\n## 5.9 Key Channel\n\nEnables object constancy for transitions over dynamic data. When a visualization’s\ndata is updated (via the [Vega View API](https://vega.github.io/vega/docs/api/view/#data),\nthe key value will be used to match data elements to existing mark instances. See the\n[Vega-Lite key channel documentation](https://vega.github.io/vega-lite/docs/encoding.html#key).\n\n@docs key\n\n@docs kName\n@docs kNominal\n@docs kOrdinal\n@docs kQuant\n@docs kTemporal\n@docs kGeo\n\n\n## 5.10 Scaling\n\nUsed to specify how the encoding of a data field should be applied. See the\n[Vega-Lite scale documentation](https://vega.github.io/vega-lite/docs/scale.html).\n\n@docs scType\n@docs scNumExpr\n@docs scBooExpr\n\n\n### 5.10.1 Scale Domain\n\nDescribes the data values that will be encoded.\n\n@docs doNumExpr\n\n@docs scDomain\n@docs scDomainExpr\n@docs categoricalDomainMap\n@docs domainRangeMap\n@docs doNums\n@docs doMin\n@docs doMid\n@docs doMax\n@docs doStrs\n@docs doDts\n@docs doDtsExpr\n@docs doMinDt\n@docs doMinDtExpr\n@docs doMaxDt\n@docs doMaxDtExpr\n@docs doUnaggregated\n@docs doUnionWith\n@docs doSelection\n@docs doSelectionChannel\n@docs doSelectionField\n\n\n### 5.10.2 Scale Range\n\nDescribes the values after data have been encoded (e.g. pixel positions or color values).\n\n@docs raNumExpr\n\n@docs scRange\n@docs raExprs\n@docs raName\n@docs raNums\n@docs raMin\n@docs raMax\n@docs raNumLists\n@docs raStrs\n@docs raField\n\n\n### 5.10.3 Scaling Properties\n\n@docs scScheme\n@docs scSchemeExpr\n@docs scAlign\n@docs scPadding\n@docs scPaddingInner\n@docs scPaddingOuter\n@docs scReverse\n@docs scRound\n@docs scClamp\n@docs scInterpolate\n@docs scNice\n@docs scZero\n@docs scBand\n@docs scBinOrdinal\n@docs scLinear\n@docs scLog\n@docs scSymLog\n@docs scConstant\n@docs scBase\n@docs scOrdinal\n@docs scPoint\n@docs scPow\n@docs scExponent\n@docs scQuantile\n@docs scQuantize\n@docs scSqrt\n@docs scThreshold\n@docs scTime\n@docs scUtc\n\n\n#### Scaling Constants\n\n@docs niTrue\n@docs niFalse\n@docs niMillisecond\n@docs niSecond\n@docs niMinute\n@docs niHour\n@docs niDay\n@docs niWeek\n@docs niMonth\n@docs niYear\n@docs niTickCount\n@docs niInterval\n@docs niExpr\n\n\n### 5.10.4 Color Scaling\n\nFor color interpolation types, see the\n[Vega-Lite continuous scale documentation](https://vega.github.io/vega-lite/docs/scale.html#continuous).\n\n@docs cubeHelix\n@docs cubeHelixLong\n@docs hcl\n@docs hclLong\n@docs hsl\n@docs hslLong\n@docs lab\n@docs rgb\n\n---\n\n\n# 6. View Composition\n\nViews can be combined to create more complex multi-view displays. This may involve\nlayering views on top of each other (superposition) or laying them out in adjacent\nspaces (juxtaposition using [repeatFlow](#repeatFlow), [repeat](#repeat),\n[facetFlow](#facetFlow), [facet](#facet), [concat](#concat), [hConcat](#hConcat)\nor [vConcat](#vConcat)). Where different views have potentially conflicting channels\n(e.g. two position scales in a layered visualization) the rules for resolving them\ncan be defined with `resolve`. For details, see the\n[Vega-Lite composition documentation](https://vega.github.io/vega-lite/docs/composition.html)\n\n  - 6.1 [Resolution](#6-1-resolution)\n  - 6.2 [Faceted Views](#6-2-faceted-views)\n\n@docs layer\n@docs concat\n@docs columns\n@docs hConcat\n@docs vConcat\n@docs align\n@docs alignRC\n@docs caAll\n@docs caEach\n@docs caNone\n@docs bounds\n@docs boFull\n@docs boFlush\n@docs spacing\n@docs spacingRC\n@docs center\n@docs centerRC\n\n\n## 6.1 Resolution\n\nControlling the (in)dependence between composed views. See the\n[Vega-Lite resolve documentation](https://vega.github.io/vega-lite/docs/resolve.html).\n\n@docs resolve\n@docs resolution\n@docs reShared\n@docs reIndependent\n@docs reAxis\n@docs reLegend\n@docs reScale\n@docs chX\n@docs chY\n@docs chX2\n@docs chY2\n@docs chXOffset\n@docs chYOffset\n@docs chColor\n@docs chOpacity\n@docs chShape\n@docs chSize\n@docs chStrokeDash\n\n\n## 6.2 Faceted Views\n\nSmall multiples each of which show subsets of the same dataset. The specification\ndetermines which field should be used to determine subsets along with their spatial\narrangement. See the\n[Vega-Lite facet documentation](https://vega.github.io/vega-lite/docs/facet.html)\n\n@docs repeatFlow\n@docs repeat\n@docs rowFields\n@docs columnFields\n@docs layerFields\n@docs facetFlow\n@docs facet\n@docs columnBy\n@docs rowBy\n\n@docs fName\n@docs fNominal\n@docs fOrdinal\n@docs fQuant\n@docs fTemporal\n@docs fGeo\n@docs fAggregate\n@docs fBin\n@docs fSort\n@docs fHeader\n@docs fTimeUnit\n@docs fAlign\n@docs fCenter\n@docs fSpacing\n\n@docs asSpec\n@docs specification\n@docs arLayer\n@docs arFlow\n@docs arColumn\n@docs arRow\n\n\n### 6.2.1 Facet Headers\n\nSee\n[Vega-Lite header documentation](https://vega.github.io/vega-lite/docs/header.html)\n\n@docs hdNumExpr\n@docs hdStrExpr\n\n\n#### Header Labels\n\n@docs hdLabelAngle\n@docs hdLabelAlign\n@docs hdLabelAnchor\n@docs hdLabelBaseline\n@docs hdLabelColor\n@docs hdLabelExpr\n@docs hdLabelFont\n@docs hdLabelFontSize\n@docs hdLabelFontStyle\n@docs hdLabelFontWeight\n@docs hdLabelLimit\n@docs hdLabelLineHeight\n@docs hdLabelOrient\n@docs hdLabelPadding\n@docs hdLabels\n\n\n#### Header Title\n\n@docs hdTitle\n@docs hdTitleAlign\n@docs hdTitleAnchor\n@docs hdTitleAngle\n@docs hdTitleBaseline\n@docs hdTitleColor\n@docs hdTitleFont\n@docs hdTitleFontStyle\n@docs hdTitleFontSize\n@docs hdTitleFontWeight\n@docs hdTitleLimit\n@docs hdTitleLineHeight\n@docs hdTitleOrient\n@docs hdOrient\n@docs hdTitlePadding\n\n\n#### Header Formatting\n\n@docs hdFormat\n@docs hdFormatAsNum\n@docs hdFormatAsTemporal\n@docs hdFormatAsCustom\n\n---\n\n\n# 7. Parameters\n\nVega-Lite _parameters_ allow named objects whose values can change to persist within\na specification. In the case of simple variables, it is often easier to use Elm\ndirectly to store persistent values. The main benefits of parameters are for storing\n_interaction selections_ such as mouse selections or slider values. See the Vega-Lite\n[parameter documentation](https://vega.github.io/vega-lite/docs/parameter.html) for\ndetails.\n\n  - 7.1 [Selection Parameters](#7-1-selection-parameters)\n  - 7.2 [Selection Resolution](#7-2-selection-resolution)\n  - 7.3 [Conditional Channel Encodings](#7-3-conditional-channel-encodings)\n\n@docs params\n@docs param\n@docs paValue\n@docs paValues\n@docs paExpr\n\n\n## 7.1 Selection Parameters\n\n@docs paSelect\n@docs sePoint\n@docs seInterval\n@docs seClear\n@docs seEncodings\n@docs seFields\n@docs seNearest\n@docs seOn\n@docs seToggle\n@docs tpFalse\n@docs tpExpr\n@docs tpShiftKey\n@docs tpAltKey\n@docs tpCtrlKey\n@docs seTranslate\n@docs seZoom\n\n\n### Selection Bindings\n\n@docs paBind\n@docs paBindings\n@docs paBindScales\n@docs paBindLegend\n\n\n### Input Elements\n\n@docs ipRange\n@docs ipCheckbox\n@docs ipRadio\n@docs ipSelect\n@docs ipText\n@docs ipNumber\n@docs ipDate\n@docs ipTime\n@docs ipMonth\n@docs ipWeek\n@docs ipDateTimeLocal\n@docs ipTel\n@docs ipColor\n\n@docs inDebounce\n@docs inElement\n@docs inOptions\n@docs inDatumOptions\n@docs inDataOptions\n@docs inMin\n@docs inMax\n@docs inName\n@docs inStep\n@docs inPlaceholder\n\n### Selection Marks\n\nCustomising the appearance of interval selection rectangles.\n\n@docs seSelectionMark\n@docs smFill\n@docs smFillOpacity\n@docs smStroke\n@docs smStrokeDash\n@docs smStrokeDashOffset\n@docs smStrokeOpacity\n@docs smStrokeWidth\n@docs smCursor\n\n\n## 7.2 Selection Resolution\n\nDetermines how selections are made across multiple views.\nSee the [Vega-lite resolve selection documentation](https://vega.github.io/vega-lite/docs/selection.html#resolve).\n\n@docs seResolve\n@docs seGlobal\n@docs seUnion\n@docs seIntersection\n\n\n## 7.3 Conditional Channel Encodings\n\nChannel encoding can be made conditional on a parameter value, therefore allowing\nit to be the result of some interaction or data expression. It does this via\n[mCondition](#mCondition) (and its 'o', 't' and 'h' variants). Mark appearance can\ntherefore depend on some properties such as whether a datum is null or whether it\nhas been interactively selected. The condition to test (predicate) is usually\nspecified either as a parameter with [prParam](#prParam) or an expression with\n[prTest](#prTest).\n\n@docs mCondition\n@docs mConditions\n@docs oCondition\n@docs oConditions\n@docs tCondition\n@docs tConditions\n@docs hCondition\n\n@docs prParam\n@docs prParamEmpty\n@docs prTest\n@docs bParam\n@docs expr\n@docs and\n@docs or\n@docs not\n\n---\n\n\n# 8. Top-Level Settings\n\nThese are in addition to the data and transform options described above. See the\n[Vega-Lite top-level spec documentation](https://vega.github.io/vega-lite/docs/spec.html#top-level-specifications)\n\n  - 8.1 [Title](#8-1-title)\n  - 8.2 [View Background](#8-2-view-background)\n  - 8.3 [Configuration of Default Appearance](#8-3-configuration-of-default-appearance)\n\n@docs name\n@docs description\n@docs height\n@docs heightOfContainer\n@docs width\n@docs widthOfContainer\n@docs widthStep\n@docs widthStepOffset\n@docs heightStep\n@docs heightStepOffset\n@docs padding\n@docs paSize\n@docs paNumExpr\n@docs paEdges\n@docs paEdgesExpr\n@docs autosize\n@docs asContent\n@docs asFit\n@docs asFitX\n@docs asFitY\n@docs asNone\n@docs asPad\n@docs asPadding\n@docs asResize\n@docs background\n@docs backgroundExpr\n\n\n## 8.1 Title\n\nPer-title settings. To standardize the appearance of all titles in a multi-view\nspecification, use [coTitle](#coTitle) instead.\n\n@docs tiNumExpr\n@docs ticoNumExpr\n@docs tiStrExpr\n@docs ticoStrExpr\n\n@docs title\n@docs titleExpr\n@docs tiAnchor\n@docs tiAngle\n@docs tiBaseline\n@docs tiColor\n@docs tiDx\n@docs tiDy\n@docs tiFont\n@docs tiFontSize\n@docs tiFontStyle\n@docs tiFontWeight\n@docs tiLineHeight\n@docs tiSubtitle\n@docs tiSubtitleColor\n@docs tiSubtitleFont\n@docs tiSubtitleFontSize\n@docs tiSubtitleFontStyle\n@docs tiSubtitleFontWeight\n@docs tiSubtitleLineHeight\n@docs tiSubtitlePadding\n@docs tiFrame\n@docs tfBounds\n@docs tfGroup\n@docs tfExpr\n@docs tiLimit\n@docs tiOffset\n@docs tiOrient\n@docs tiStyle\n@docs tiZIndex\n\n\n## 8.2 View Background\n\nThe background of a single view in a view composition can be styled independently\nof other views. For more details see the\n[Vega-Lite view background documentation](https://vega.github.io/vega-lite/docs/spec.html#view-background)\n\n@docs viewBackground\n@docs vbNumExpr\n@docs vicoNumExpr\n@docs vbNumsExpr\n@docs vicoNumsExpr\n@docs vbStrExpr\n@docs vicoStrExpr\n@docs vicoBooExpr\n\n@docs viewStyle\n@docs viewCornerRadius\n@docs viewFill\n@docs viewFillOpacity\n@docs viewOpacity\n@docs viewStroke\n@docs viewStrokeCap\n@docs viewStrokeDash\n@docs viewStrokeDashOffset\n@docs viewStrokeJoin\n@docs viewStrokeMiterLimit\n@docs viewStrokeOpacity\n@docs viewStrokeWidth\n\n\n## 8.3 Configuration of Default Appearance\n\nAllows default properties for most marks and guides to be set. See the\n[Vega-Lite configuration documentation](https://vega.github.io/vega-lite/docs/config.html).\n\n@docs configure\n@docs configuration\n\n@docs coBooExpr\n@docs coStrExpr\n\n@docs coArea\n@docs coAria\n@docs coAutosize\n@docs coAxis\n@docs coAxisXFilter\n@docs coAxisYFilter\n@docs axX\n@docs axY\n@docs coAxisLeft\n@docs coAxisRight\n@docs coAxisTop\n@docs coAxisBottom\n@docs coAxisBand\n@docs coAxisDiscrete\n@docs coAxisPoint\n@docs coAxisQuant\n@docs coAxisTemporal\n@docs coAxisStyles\n@docs coBackground\n@docs coBar\n@docs coCircle\n@docs coConcat\n@docs coCountTitle\n@docs coCustomFormatTypes\n@docs coFieldTitle\n@docs coFont\n@docs coGeoshape\n@docs coFacet\n@docs coHeader\n@docs coLegend\n@docs coLine\n@docs coLocale\n@docs coMark\n@docs coMarkStyles\n@docs coNumberFormat\n@docs coPadding\n@docs coPoint\n@docs coProjection\n@docs coRange\n@docs coRect\n@docs coRule\n@docs coScale\n@docs coSelection\n@docs coSquare\n@docs coText\n@docs coTick\n@docs coTitle\n@docs coTimeFormat\n@docs coTrail\n@docs coView\n\n\n### 8.3.1 Axis Configuration\n\nSee the\n[Vega-Lite axis config documentation](https://vega.github.io/vega-lite/docs/axis.html#general-config).\n\n@docs axcoAria\n@docs axcoBandPosition\n@docs axcoDisable\n@docs axcoDomain\n@docs axcoDomainDash\n@docs axcoDomainDashOffset\n@docs axcoDomainCap\n@docs axcoDomainColor\n@docs axcoDomainOpacity\n@docs axcoDomainWidth\n@docs axcoMaxExtent\n@docs axcoMinExtent\n@docs axcoTranslate\n@docs axcoGrid\n@docs axcoGridCap\n@docs axcoGridColor\n@docs axcoGridDash\n@docs axcoGridDashOffset\n@docs axcoGridOpacity\n@docs axcoGridWidth\n@docs axcoLabels\n@docs axcoLabelAlign\n@docs axcoLabelAngle\n@docs axcoLabelBaseline\n@docs axcoLabelBound\n@docs axcoLabelBoundExpr\n@docs axcoLabelColor\n@docs axcoLabelExpr\n@docs axcoLabelFlush\n@docs axcoLabelFlushOffset\n@docs axcoLabelFont\n@docs axcoLabelFontSize\n@docs axcoLabelFontStyle\n@docs axcoLabelFontWeight\n@docs axcoLabelLimit\n@docs axcoLabelLineHeight\n@docs axcoLabelOffset\n@docs axcoLabelOpacity\n@docs axcoLabelOverlap\n@docs axcoLabelPadding\n@docs axcoLabelSeparation\n@docs axcoOffset\n@docs axcoStyle\n@docs axcoTicks\n@docs axcoTickBand\n@docs axcoTickCap\n@docs axcoTickColor\n@docs axcoTickCount\n@docs axcoTickDash\n@docs axcoTickDashOffset\n@docs axcoTickExtra\n@docs axcoTickOffset\n@docs axcoTickOpacity\n@docs axcoTickRound\n@docs axcoTickSize\n@docs axcoTickMinStep\n@docs axcoTickWidth\n@docs axcoTitleAlign\n@docs axcoTitleAnchor\n@docs axcoTitleAngle\n@docs axcoTitleBaseline\n@docs axcoTitleColor\n@docs axcoTitleFont\n@docs axcoTitleFontSize\n@docs axcoTitleFontStyle\n@docs axcoTitleFontWeight\n@docs axcoTitleLimit\n@docs axcoTitleLineHeight\n@docs axcoTitleOpacity\n@docs axcoTitlePadding\n@docs axcoTitleX\n@docs axcoTitleY\n\n\n## 8.3.2 Legend Configuration\n\nSee the\n[Vega-Lite legend configuration documentation](https://vega.github.io/vega-lite/docs/legend.html#config).\n\n@docs lecoAria\n@docs lecoClipHeight\n@docs lecoColumnPadding\n@docs lecoColumns\n@docs lecoCornerRadius\n@docs lecoDirection\n@docs lecoDisable\n@docs lecoFillColor\n@docs lecoOrient\n@docs lecoOffset\n@docs lecoStrokeColor\n@docs lecoStrokeDash\n@docs lecoStrokeWidth\n@docs lecoPadding\n@docs lecoRowPadding\n@docs lecoGradientDirection\n@docs lecoGradientLabelLimit\n@docs lecoGradientLabelOffset\n@docs lecoGradientLength\n@docs lecoGradientOpacity\n@docs lecoGradientStrokeColor\n@docs lecoGradientStrokeWidth\n@docs lecoGradientThickness\n@docs lecoGridAlign\n@docs lecoLabelAlign\n@docs lecoLabelBaseline\n@docs lecoLabelColor\n@docs lecoLabelFont\n@docs lecoLabelFontSize\n@docs lecoLabelFontStyle\n@docs lecoLabelFontWeight\n@docs lecoLabelLimit\n@docs lecoLabelOffset\n@docs lecoLabelOverlap\n@docs lecoSymbolBaseFillColor\n@docs lecoSymbolBaseStrokeColor\n@docs lecoSymbolDash\n@docs lecoSymbolDashOffset\n@docs lecoSymbolDirection\n@docs lecoSymbolFillColor\n@docs lecoSymbolLimit\n@docs lecoSymbolOffset\n@docs lecoSymbolOpacity\n@docs lecoSymbolSize\n@docs lecoSymbolStrokeColor\n@docs lecoSymbolStrokeWidth\n@docs lecoSymbolType\n@docs lecoNoTitle\n@docs lecoTitleAlign\n@docs lecoTitleAnchor\n@docs lecoTitleBaseline\n@docs lecoTitleColor\n@docs lecoTitleFont\n@docs lecoTitleFontSize\n@docs lecoTitleFontStyle\n@docs lecoTitleFontWeight\n@docs lecoTitleLimit\n@docs lecoTitleLineHeight\n@docs lecoTitleOpacity\n@docs lecoTitlePadding\n@docs lecoUnselectedOpacity\n@docs lecoX\n@docs lecoY\n\n\n### 8.3.3 Scale Configuration\n\nSee the\n[Vega-Lite scale configuration documentation](https://vega.github.io/vega-lite/docs/scale.html#scale-config)\n\n@docs sacoBooExpr\n@docs sacoNumExpr\n\n@docs sacoBandPaddingInner\n@docs sacoBarBandPaddingInner\n@docs sacoRectBandPaddingInner\n@docs sacoBandPaddingOuter\n@docs sacoContinuousPadding\n@docs sacoPointPadding\n@docs sacoClamp\n@docs sacoMaxBandSize\n@docs sacoMinBandSize\n@docs sacoMaxFontSize\n@docs sacoMinFontSize\n@docs sacoMaxOpacity\n@docs sacoMinOpacity\n@docs sacoMaxSize\n@docs sacoMinSize\n@docs sacoMaxStrokeWidth\n@docs sacoMinStrokeWidth\n@docs sacoRound\n@docs sacoUseUnaggregatedDomain\n@docs sacoXReverse\n\n\n### 8.3.4 Scale Range Configuration\n\nSee the\n[Vega-Lite scheme configuration documentation](https://vega.github.io/vega/docs/schemes/#scheme-properties).\n\n@docs racoCategory\n@docs racoDiverging\n@docs racoHeatmap\n@docs racoOrdinal\n@docs racoRamp\n@docs racoSymbols\n@docs racoSymbolsExpr\n\n\n### 8.3.5 Title Configuration\n\nUnlike [title](#title) title configuration applies to all titles if multiple views\nare created. See the\n[Vega-Lite title configuration documentation](https://vega.github.io/vega-lite/docs/title.html#config)\n\n@docs ticoAnchor\n@docs ticoAngle\n@docs ticoBaseline\n@docs ticoColor\n@docs ticoDx\n@docs ticoDy\n@docs ticoFont\n@docs ticoFontSize\n@docs ticoFontStyle\n@docs ticoFontWeight\n@docs ticoLineHeight\n@docs ticoSubtitleColor\n@docs ticoSubtitleFont\n@docs ticoSubtitleFontSize\n@docs ticoSubtitleFontStyle\n@docs ticoSubtitleFontWeight\n@docs ticoSubtitleLineHeight\n@docs ticoSubtitlePadding\n@docs ticoFrame\n@docs ticoLimit\n@docs ticoOffset\n@docs ticoOrient\n@docs ticoStyle\n@docs ticoZIndex\n\n\n### 8.3.6 View Configuration\n\nSee the\n[Vega-Lite view configuration documentation](https://vega.github.io/vega-lite/docs/spec.html#config)\n\n@docs vicoBackground\n@docs vicoContinuousWidth\n@docs vicoContinuousHeight\n@docs vicoCursor\n@docs vicoDiscreteWidth\n@docs vicoDiscreteHeight\n@docs vicoClip\n@docs vicoCornerRadius\n@docs vicoFill\n@docs vicoFillOpacity\n@docs vicoOpacity\n@docs vicoStep\n@docs vicoStroke\n@docs vicoStrokeCap\n@docs vicoStrokeDash\n@docs vicoStrokeDashOffset\n@docs vicoStrokeJoin\n@docs vicoStrokeMiterLimit\n@docs vicoStrokeOpacity\n@docs vicoStrokeWidth\n\n@docs anStart\n@docs anMiddle\n@docs anEnd\n@docs anExpr\n\n@docs ftVerbal\n@docs ftFunction\n@docs ftPlain\n\n\n### 8.3.7 Facet Configuration\n\nSee the\n[Vega-Lite facet configuration documentation](https://vega.github.io/vega-lite/docs/facet.html#facet-configuration).\n\n@docs facoColumns\n@docs facoSpacing\n\n\n### 8.3.8 Concatenated View Configuration\n\nSee the\n[Vega-Lite concat configuration documentation](https://vega.github.io/vega-lite/docs/concat.html#concat-configuration).\n\n@docs cocoColumns\n@docs cocoSpacing\n\n\n### 8.3.9 Locale Configuration\n\nSee the [Vega locale documentation](https://vega.github.io/vega/docs/api/locale/).\n\n@docs loDecimal\n@docs loThousands\n@docs loGrouping\n@docs loCurrency\n@docs loNumerals\n@docs loPercent\n@docs loMinus\n@docs loNan\n@docs loDateTime\n@docs loDate\n@docs loTime\n@docs loPeriods\n@docs loDays\n@docs loShortDays\n@docs loMonths\n@docs loShortMonths\n\n---\n\n\n# 9. General Data Functions\n\nIn addition to more general data types like integers and strings, the following types\ncan carry data used in specifications and Vega-Lite parameters.\n\n  - 9.1 [Temporal Data](#9-1-temporal-data)\n\n@docs boo\n@docs true\n@docs false\n@docs dt\n@docs num\n@docs str\n@docs datumExpr\n@docs dataExpr\n@docs datumArray\n@docs dataArrays\n@docs dataObject\n@docs dataObjects\n@docs nullValue\n@docs daConcat\n@docs boos\n@docs dts\n@docs nums\n@docs strs\n\n\n## 9.1 Temporal Data\n\nSee the\n[Vega-Lite dateTime documentation](https://vega.github.io/vega-lite/docs/types.html#datetime)\nand the [Vega-Lite time unit documentation](https://vega.github.io/vega-lite/docs/timeunit.html).\n\n@docs dtYear\n@docs dtQuarter\n@docs dtMonth\n@docs dtMonthNum\n@docs dtDate\n@docs dtDay\n@docs dtHour\n@docs dtMinute\n@docs dtSecond\n@docs dtMillisecond\n@docs MonthName\n@docs DayName\n\n@docs date\n@docs dayOfYear\n@docs day\n@docs dayHours\n@docs dayHoursMinutes\n@docs dayHoursMinutesSeconds\n@docs hours\n@docs hoursMinutes\n@docs hoursMinutesSeconds\n@docs milliseconds\n@docs minutes\n@docs minutesSeconds\n@docs month\n@docs monthDate\n@docs monthDateHours\n@docs monthDateHoursMinutes\n@docs monthDateHoursMinutesSeconds\n@docs quarter\n@docs quarterMonth\n@docs seconds\n@docs secondsMilliseconds\n@docs week\n@docs weekDay\n@docs weekDayHours\n@docs weekDayHoursMinutes\n@docs weekDayHoursMinutesSeconds\n@docs year\n@docs yearQuarter\n@docs yearQuarterMonth\n@docs yearMonth\n@docs yearMonthDate\n@docs yearMonthDateHours\n@docs yearMonthDateHoursMinutes\n@docs yearMonthDateHoursMinutesSeconds\n@docs yearWeek\n@docs yearWeekDay\n@docs yearWeekDayHours\n@docs yearWeekDayHoursMinutes\n@docs yearWeekDayHoursMinutesSeconds\n@docs yearDayOfYear\n@docs utc\n@docs tuMaxBins\n@docs tuStep\n\n---\n\n\n# 10. Type Reference\n\nTypes that are not specified directly, provided here for reference with links\nto the functions that generate them.\n\n@docs Anchor\n@docs Aria\n@docs Arrangement\n@docs Autosize\n@docs AxisProperty\n@docs AxisChoice\n@docs AxisConfig\n@docs BinProperty\n@docs BlendMode\n@docs BooleanOp\n@docs Bounds\n@docs CInterpolate\n@docs Channel\n@docs ClipRect\n@docs ColorGradient\n@docs CompositionAlignment\n@docs ConcatConfig\n@docs ConditionalAxisProperty\n@docs ConfigurationProperty\n@docs Cursor\n@docs DataType\n@docs DataValue\n@docs DataValues\n@docs DateTime\n@docs DensityProperty\n@docs DetailChannel\n@docs FacetChannel\n@docs FacetConfig\n@docs FacetMapping\n@docs FieldTitleProperty\n@docs Filter\n@docs FilterRange\n@docs Format\n@docs Geometry\n@docs GradientProperty\n@docs GraticuleProperty\n@docs HAlign\n@docs HeaderProperty\n@docs HyperlinkChannel\n@docs ImMethod\n@docs ImputeProperty\n@docs InputProperty\n@docs KeyChannel\n@docs Legend\n@docs LegendConfig\n@docs LegendOrientation\n@docs LegendProperty\n@docs LineMarker\n@docs LoessProperty\n@docs LookupFields\n@docs Mark\n@docs MarkChannel\n@docs MarkInterpolation\n@docs MarkOrientation\n@docs MarkProperty\n@docs Operation\n@docs OrderChannel\n@docs OverlapStrategy\n@docs Padding\n@docs ParamProperty\n@docs PBinding\n@docs PivotProperty\n@docs PointMarker\n@docs PositionChannel\n@docs Predicate\n@docs Projection\n@docs ProjectionProperty\n@docs QuantileProperty\n@docs RangeConfig\n@docs RegressionMethod\n@docs RegressionProperty\n@docs RepeatFields\n@docs Resolution\n@docs Resolve\n@docs Scale\n@docs ScaleDomain\n@docs ScaleNice\n@docs ScaleProperty\n@docs ScaleConfig\n@docs ScaleRange\n@docs Selection\n@docs SelectionMarkProperty\n@docs SelectionProperty\n@docs SelectionResolution\n@docs Side\n@docs SortField\n@docs SortProperty\n@docs StackOffset\n@docs StackProperty\n@docs StrokeCap\n@docs StrokeJoin\n@docs SummaryExtent\n@docs Symbol\n@docs TextChannel\n@docs TimeUnit\n@docs TitleConfig\n@docs TitleFrame\n@docs TitleProperty\n@docs TogglePredicate\n@docs TooltipContent\n@docs VAlign\n@docs ViewBackground\n@docs ViewConfig\n@docs Window\n@docs WOperation\n@docs WindowProperty\n\n",
        "unions": [
            {
                "name": "Anchor",
                "comment": " Generated by [anStart](#anStart), [anMiddle](#anMiddle), [anEnd](#anEnd) and\n[anExpr](#anExpr).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "Aria",
                "comment": " Generated by [arEnable](#arEnable), [arDisable](#arDisable), [arDescription](#arDescription)\nand [arExpr](#arExpr).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "Arrangement",
                "comment": " Generated by [arFlow](#arFlow), [arColumn](#arColumn), [arRow](#arRow) and\n[arLayer](#arLayer).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "Autosize",
                "comment": " Generated by [asContent](#asContent), [asFit](#asFit), [asFitX](#asFitX),\n[asFitY](#asFitY), [asNone](#asNone), [asPad](#asPad), [asPadding](#asPadding)\nand [asResize](#asResize).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "AxisChoice",
                "comment": " Generated by [axBoth](#axBoth), [axX](#axX) and [axY](#axY).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "AxisConfig",
                "comment": " Generated by [axcoAria](#axcoAria), [axcoBandPosition](#axcoBandPosition),\n[axcoDisable](#axcoDisable), [axcoDomain](#axcoDomain), [axcoDomainCap](#axcoDomainCap),\n[axcoDomainColor](#axcoDomainColor), [axcoDomainDash](#axcoDomainDash),\n[axcoDomainDashOffset](#axcoDomainDashOffset), [axcoDomainOpacity](#axcoDomainOpacity),\n[axcoDomainWidth](#axcoDomainWidth), [axcoMaxExtent](#axcoMaxExtent), [axcoMinExtent](#axcoMinExtent),\n[axcoGrid](#axcoGrid), [axcoGridCap](#axcoGridCap), [axcoGridColor](#axcoGridColor),\n[axcoGridDash](#axcoGridDash), [axcoGridDashOffset](#axcoGridDashOffset),\n[axcoGridOpacity](#axcoGridOpacity), [axcoGridWidth](#axcoGridWidth),\n[axcoLabels](#axcoLabels), [axcoLabelAlign](#axcoLabelAlign), [axcoLabelAngle](#axcoLabelAngle),\n[axcoLabelBaseline](#axcoLabelBaseline), [axcoLabelBound](#axcoLabelBound), [axcoLabelBoundExpr](#axcoLabelBoundExpr)\n[axcoLabelColor](#axcoLabelColor), [axcoLabelExpr](#axcoLabelExpr), [axcoLabelFlush](#axcoLabelFlush),\n[axcoLabelFlushOffset](#axcoLabelFlushOffset), [axcoLabelFont](#axcoLabelFont),\n[axcoLabelFontSize](#axcoLabelFontSize), [axcoLabelFontStyle](#axcoLabelFontStyle),\n[axcoLabelFontWeight](#axcoLabelFontWeight), [axcoLabelLimit](#axcoLabelLimit),\n[axcoLabelLineHeight](#axcoLabelLineHeight), [axcoLabelOffset](#axcoLabelOffset),\n[axcoLabelOpacity](#axcoLabelOpacity), [axcoLabelOverlap](#axcoLabelOverlap),\n[axcoLabelPadding](#axcoLabelPadding), [axcoLabelSeparation](#axcoLabelSeparation),\n[axcoOffset](#axcoOffset), [axcoTicks](#axcoTicks), [axcoTickColor](#axcoTickColor),\n[axcoTickCount](#axcoTickCount), [axcoGridDash](#axcoGridDash), [axcoGridDashOffset](#axcoGridDashOffset),\n[axcoTickCap](#axcoTickCap), [axcoTickExtra](#axcoTickExtra), [axcoTickOffset](#axcoTickOffset),\n[axcoTickOpacity](#axcoTickOpacity), [axcoTickRound](#axcoTickRound), [axcoTickSize](#axcoTickSize),\n[axcoTickMinStep](#axcoTickMinStep), [axcoTickWidth](#axcoTickWidth), [axcoTitleAlign](#axcoTitleAlign),\n[axcoTitleAnchor](#axcoTitleAnchor), [axcoTitleAngle](#axcoTitleAngle), [axcoTitleBaseline](#axcoTitleBaseline),\n[axcoTitleColor](#axcoTitleColor), [axcoTitleFont](#axcoTitleFont), [axcoTitleFontSize](#axcoTitleFontSize),\n[axcoTitleFontStyle](#axcoTitleFontStyle), [axcoTitleFontWeight](#axcoTitleFontWeight),\n[axcoTitleLimit](#axcoTitleLimit), [axcoTitleLineHeight](#axcoTitleLineHeight),\n[axcoTitleOpacity](#axcoTitleOpacity), [axcoTitlePadding](#axcoTitlePadding),\n[axcoTitleX](#axcoTitleX), [axcoTitleY](#axcoTitleY) and [axcoTranslate](#axcoTranslate).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "AxisProperty",
                "comment": " Generated by [axAria](#axAria), [axBandPosition](#axBandPosition),\n[axMaxExtent](#axMaxExtent), [axMinExtent](#axMinExtent), [axOrient](#axOrient),\n[axOffset](#axOffset), [axPosition](#axPosition), [axZIndex](#axZIndex),\n[axDataCondition](#axDataCondition), [axDomain](#axDomain), [axDomainCap](#axDomainCap),\n[axDomainColor](#axDomainColor), [axDomainDash](#axDomainDash),\n[axDomainDashOffset](#axDomainDashOffset), [axDomainOpacity](#axDomainOpacity),\n[axDomainWidth](#axDomainWidth), [axFormat](#axFormat), [axFormatAsNum](#axFormatAsNum),\n[axFormatAsTemporal](#axFormatAsTemporal), [axFormatAsCustom](#axFormatAsCustom),\n[axLabels](#axLabels), [axLabelAlign](#axLabelAlign), [axLabelAngle](#axLabelAngle),\n[axLabelBaseline](#axLabelBaseline), [axLabelBound](#axLabelBound), [axLabelColor](#axLabelColor),\n[axLabelExpr](#axLabelExpr), [axLabelFlush](#axLabelFlush), [axLabelFlushOffset](#axLabelFlushOffset),\n[axLabelFont](#axLabelFont), [axLabelFontSize](#axLabelFontSize), [axLabelFontStyle](#axLabelFontStyle),\n[axLabelFontWeight](#axLabelFontWeight), [axLabelLimit](#axLabelLimit),\n[axLabelLineHeight](#axLabelLineHeight), [axLabelOffset](#axLabelOffset),\n[axLabelOpacity](#axLabelOpacity), [axLabelOverlap](#axLabelOverlap), [axLabelPadding](#axLabelPadding),\n[axLabelSeparation](#axLabelSeparation), [axStyle](#axStyle), [axTranslate](#axTranslate),\n[axTicks](#axTicks), [axTickCap](#axTickCap), [axTickColor](#axTickColor), [axTickCount](#axTickCount),\n[axTickDash](#axTickDash), [axTickDashOffset](#axTickDashOffset),\n[axTickExtra](#axTickExtra), [axTickOffset](#axTickOffset), [axTickOpacity](#axTickOpacity),\n[axTickRound](#axTickRound), [axTickSize](#axTickSize), [axTickMinStep](#axTickMinStep),\n[axTickWidth](#axTickWidth), [axValues](#axValues), [axTitle](#axTitle), [axTitleAlign](#axTitleAlign),\n[axTitleAnchor](#axTitleAnchor), [axTitleAngle](#axTitleAngle), [axTitleBaseline](#axTitleBaseline),\n[axTitleColor](#axTitleColor), [axTitleFont](#axTitleFont), [axTitleFontSize](#axTitleFontSize),\n[axTitleFontStyle](#axTitleFontStyle), [axTitleFontWeight](#axTitleFontWeight),\n[axTitleLimit](#axTitleLimit), [axTitleLineHeight](#axTitleLineHeight), [axTitleOpacity](#axTitleOpacity),\n[axTitlePadding](#axTitlePadding), [axTitleX](#axTitleX), [axTitleY](#axTitleY),\n[axGrid](#axGrid), [axGridCap](#axGridCap), [axGridColor](#axGridColor), [axGridDash](#axGridDash),\n[axGridDashOffset](#axGridDashOffset), [axGridOpacity](#axGridOpacity)\nand [axGridWidth](#axGridWidth).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "BinProperty",
                "comment": " Generated by [biAnchor](#biAnchor), [biBase](#biBase), [biDivide](#biDivide),\n[biExtent](#biExtent),[biSelectionExtent](#biSelectionExtent), [biMaxBins](#biMaxBins),\n[biMinStep](#biMinStep), [biNice](#biNice), [biStep](#biStep) and [biSteps](#biSteps).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "BlendMode",
                "comment": " Generated by [bmNormal](#bmNormal), [bmMultiply](#bmMultiply), [bmScreen](#bmScreen),\n[bmOverlay](#bmOverlay), [bmDarken](#bmDarken), [bmLighten](#bmLighten), [bmColorDodge](#bmColorDodge),\n[bmColorBurn](#bmColorBurn), [bmHardLight](#bmHardLight), [bmSoftLight](#bmSoftLight),\n[bmDifference](#bmDifference), [bmExclusion](#bmExclusion), [bmHue](#bmHue),\n[bmSaturation](#bmSaturation), [bmColor](#bmColor), [bmLuminosity](#bmLuminosity)\nand [bmExpr](#bmExpr).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "BooleanOp",
                "comment": " Generated by [expr](#expr), [fiOp](#fiOp), [fiOpTrans](#fiOpTrans),[bParam](#bParam),\n[and](#and),[or](#or) and [not](#not).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "Bounds",
                "comment": " Generated by [boFull](#boFull) and [boFlush](#boFlush).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "CInterpolate",
                "comment": " Generated by [cubeHelix](#cubeHelix), [cubeHelixLong](#cubeHelixLong), [hcl](#hcl),\n[hclLong](#hclLong), [hsl](#hsl), [hslLong](#hslLong), [lab](#lab) and [rgb](#rgb).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "Channel",
                "comment": " Generated by [chX](#chX), [chY](#chY), [chX2](#chX2), [chY2](#chY2),\n[chXOffset](#chXOffset), [chYOffset](#chYOffset), [chColor](#chColor),\n[chOpacity](#chOpacity), [chShape](#chShape), [chStrokeDash](#chStrokeDash)\nand [chSize](#chSize).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "ClipRect",
                "comment": " Generated by [noClip](#noClip), [clipRect](#clipRect) and [clipRectExpr](#clipRectExpr).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "ColorGradient",
                "comment": " Generated by [grLinear](#grLinear) and [grRadial](#grRadial).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "CompositionAlignment",
                "comment": " Generated by [caNone](#caNone), [caEach](#caEach) and [caAll](#caAll).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "ConcatConfig",
                "comment": " Generated by [cocoColumns](#cocoColumns) and [cocoSpacing](#cocoSpacing).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "ConditionalAxisProperty",
                "comment": " Generated by [cAxLabelAlign](#cAxLabelAlign), [cAxLabelBaseline](#cAxLabelBaseline),\n[cAxLabelColor](#cAxLabelColor), [cAxLabelFont](#cAxLabelFont), [cAxLabelFontSize](#cAxLabelFontSize),\n[cAxLabelFontStyle](#cAxLabelFontStyle), [cAxLabelFontWeight](#cAxLabelFontWeight),\n[cAxLabelOffset](#cAxLabelOffset), [cAxLabelOpacity](#cAxLabelOpacity),\n[cAxLabelPadding](#cAxLabelPadding), [cAxTickColor](#cAxTickColor), [cAxTickDash](#cAxTickDash),\n[cAxTickDashOffset](#cAxTickDashOffset), [cAxTickOpacity](#cAxOpacity),\n[cAxTickSize](#cAxTickSize), [cAxTickWidth](#cAxTickWidth), [cAxGridColor](#cAxGridColor),\n[cAxGridDash](#cAxGridDash), [cAxTickDashOffset](#cAxTickDashOffset),\n[cAxGridOpacity](#cAxGridOpacity) and [cAxGridWidth](#cAxGridWidth).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "ConfigurationProperty",
                "comment": " Generated by [coArea](#coArea),[coAria](#coAria), [coAutosize](#coAutosize),\n[coAxis](#coAxis), [coAxisStyles](#coAxisStyles), [coAxisXFilter](#coAxisXFilter),\n[coAxisYFilter](#coAxisYFilter), [coAxisLeft](#coAxisLeft), [coAxisRight](#coAxisRight),\n[coAxisTop](#coAxisTop), [coAxisBottom](#coAxisBottom), [coAxisBand](#coAxisBand),\n[coAxisDiscrete](#coAxisDiscrete), [coAxisPoint](#coAxisPoint), [coAxisTemporal](#coAxisTemporal),\n[coAxisQuant](#coAxisQuant), [coBackground](#coBackground), [coBar](#coBar), [coCircle](#coCircle),\n[coConcat](#coConcat), [coCountTitle](#coCountTitle), [coCustomFormatTypes](#coCustomFormatTypes),\n[coFieldTitle](#coFieldTitle),[coGeoshape](#coGeoshape), [coFacet](#coFacet), [coHeader](#coHeader),\n[coLegend](#coLegend), [coLocale](#coLocale), [coLine](#coLine), [coMark](#coMark),\n[coMarkStyles](#coMarkStyles), [coNumberFormat](#coNumberFormat), [coPadding](#coPadding),\n[coPoint](#coPoint), [coProjection](#coProjection), [coRange](#coRange), [coRect](#coRect),\n[coRule](#coRule), [coScale](#coScale), [coSelection](#coSelection), [coSquare](#coSquare),\n[coText](#coText), [coFont](#coFont), [coTick](#coTick), [coTitle](#coTitle),\n[coTimeFormat](#coTimeFormat), [coTrail](#coTrail) and [coView](#coView).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "Cursor",
                "comment": " Generated by [cuAuto](#cuAuto), [cuDefault](#cuDefault), [cuNone](#cuNone),\n[cuContextMenu](#cuContextMenu), [cuHelp](#cuHelp), [cuPointer](#cuPointer),\n[cuProgress](#cuProgress), [cuWait](#cuWait), [cuCell](#cuCell), [cuCrosshair](#cuCrosshair),\n[cuText](#cuText), [cuVerticalText](#cuVerticalText), [cuAlias](#cuAlias),\n[cuCopy](#cuCopy), [cuMove](#cuMove), [cuNoDrop](#cuNoDrop), [cuNotAllowed](#cuNotAllowed),\n[cuAllScroll](#cuAllScroll), [cuColResize](#cuColResize), [cuRowResize](#cuRowResize),\n[cuNResize](#cuNResize), [cuEResize](#cuEResize), [cuSResize](#cuSResize),\n[cuWResize](#cuWResize), [cuNEResize](#cuNEResize), [cuNWResize](#cuNWResize),\n[cuSEResize](#cuSEResize), [cuSWResize](#cuSWResize), [cuEWResize](#cuEWResize),\n[cuNSResize](#cuNSResize), [cuNESWResize](#cuNESWResize), [cuNWSEResize](#cuNWSEResize),\n[cuZoomIn](#cuZoomIn), [cuZoomOut](#cuZoomOut), [cuGrab](#cuGrab), [cuGrabbing](#cuGrabbing)\nand [cuExpr](#cuExpr).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "DataType",
                "comment": " Generated by [foBoo](#foBoo), [foNum](#foNum), [foDate](#foDate) and [foUtc](#foUtc).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "DataValue",
                "comment": " Generated by [boo](#boo), [true](#true), [false](#false), [dt](#dt),\n[num](#num), [str](#str), [datumExpr](#datumExpr), [daConcat](#daConcat),\n[dataObject](#dataObject), [datumArray](#datumArray) and [nullValue](#nullValue).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "DataValues",
                "comment": " Generated by [boos](#boos), [dts](#dts), [nums](#nums), [strs](#strs),\n[dataExpr](#dataExpr), [dataArrays](#dataArrays) and [dataObjects](#dataObjects).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "DateTime",
                "comment": " Generated by [dtYear](#dtYear), [dtQuarter](#dtQuarter), [dtMonth](#dtMonth),\n[dtMonthNum](#dtMonthNum), [dtDate](#DTDate), [dtDay](#dtDay), [dtHour](#dtHour),\n[dtMinute](#dtMinute), [dtSecond](#dtSecond) and [dtMillisecond](#dtMillisecond).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "DayName",
                "comment": " Day of the week.\n",
                "args": [],
                "cases": [
                    [
                        "Mon",
                        []
                    ],
                    [
                        "Tue",
                        []
                    ],
                    [
                        "Wed",
                        []
                    ],
                    [
                        "Thu",
                        []
                    ],
                    [
                        "Fri",
                        []
                    ],
                    [
                        "Sat",
                        []
                    ],
                    [
                        "Sun",
                        []
                    ]
                ]
            },
            {
                "name": "DensityProperty",
                "comment": " Generated by [dnGroupBy](#dnGroupBy), [dnCumulative](#dnCumulative),\n[dnCounts](#dnCounts), [dnBandwidth](#dnBandwidth), [dnExtent](#dnExtent),\n[dnMinSteps](#dnMinSteps), [dnMaxSteps](#dnMaxSteps), [dnSteps](#dnSteps) and\n[dnAs](#dnAs).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "DetailChannel",
                "comment": " Generated by [dName](#dName), [dQuant](#dQuant), [dNominal](#dNominal),\n[dOrdinal](#dOrdinal), [dTemporal](#dTemporal), [dGeo](#dGeo),\n[dAggregate](#dAggregate), [dBin](#dBin) and [dTimeUnit](#dTimeUnit).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "FacetChannel",
                "comment": " Generated by [fName](#fName), [fQuant](#fQuant), [fNominal](#fNominal),\n[fOrdinal](#fOrdinal), [fTemporal](#fTemporal), [fGeo](#fGeo), [fAggregate](#fAggregate),\n[fBin](#fBin), [fSort](#fSort), [fHeader](#fHeader), [fTimeUnit](#fTimeUnit),\n[fAlign](#fAlign), [fCenter](#fCenter) and [fSpacing](#fSpacing).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "FacetConfig",
                "comment": " Generated by [facoColumns](#facoColumns) and [facoSpacing](#facoSpacing).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "FacetMapping",
                "comment": " Generated by [columnBy](#columnBy) and [rowBy](#rowBy).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "FieldTitleProperty",
                "comment": " Generated by [ftVerbal](#ftVerbal), [ftFunction](#ftFunction) and [ftPlain](#ftPlain).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "Filter",
                "comment": " Generated by [fiEqual](#fiEqual), [fiLessThan](#fiLessThan),\n[fiLessThanEq](#fiLessThanEq), [fiGreaterThan](#fiEqGreaterThan),\n[fiGreaterThanEq](#fiGreaterThanEq), [fiExpr](#fiExpr), [fiCompose](#fiCompose),\n[fiSelection](#fiSelection), [fiSelectionEmpty](#fiSelectionEmpty),\n[fiOneOf](#fiOneOf), [fiRange](#fiRange) and [fiValid](#fiValid).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "FilterRange",
                "comment": " Generated by [numRange](#numRange) and [dtRange](#dtRange).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "FontWeight",
                "comment": " Generated by [fwBold](#fwBold), [fwBolder](#fwBolder), [fwLighter](#fwLighter),\n[fwNormal](#fwNormal), [fwValue](#fwValue) and [fwExpr](#fwExpr).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "Format",
                "comment": " Generated by [csv](#csv), [dsv](#dsv), [tsv](#tsv), [arrow](#arrow), [parse](#parse),\n[jsonProperty](#jsonProperty), [topojsonFeature](#topojsonFeature) and\n[topojsonMesh](#topojsonMesh).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "Geometry",
                "comment": " Generated by [geoPoint](#geoPoint), [geoPoints](#geoPoints),\n[geoLine](#geoLine), [geoLines](#geoLines), [geoPolygon](#geoPolygon) and\n[geoPolygons](#geoPolygons).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "GradientProperty",
                "comment": " Generated by [grX1](#grX1), [grY1](#grY1), [grX2](#grX2), [grY2](#grY2),\n[grR1](#grR1), [grR2](#grR2) and [grStops](#grStops).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "GraticuleProperty",
                "comment": " Generated by [grExtent](#grExtent), [grExtentMajor](#grExtentMajor),\n[grExtentMinor](#grExtentMinor), [grStep](#grStep), [grExtentMajor](#grExtentMajor),\n[grExtentMinor](#grExtentMinor) and [grPrecision](#grPrecision).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "HAlign",
                "comment": " Generated by [haLeft](#haLeft), [haCenter](#haCenter), [haRight](#haRight)\nand [haExpr](#haExpr).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "HeaderProperty",
                "comment": " Generated by [hdFormat](#hdFormat), [hdFormatAsNum](#hdFormatAsNum),\n[hdFormatAsTemporal](#hdFormatAsTemporal), [hdFormatAsCustom](#hdFormatAsCustom),\n[hdLabelAlign](#hdLabelAlign), [hdLabelAnchor](#hdLabelAnchor), [hdLabelAngle](#hdLabelAngle),\n[hdLabelBaseline](#hdLabelBaseline), [hdLabelColor](#hdLabelColor), [hdLabelExpr](#hdLabelExpr),\n[hdLabelFont](#hdLabelFont), [hdLabelFontSize](#hdLabelFontSize), [hdLabelFontStyle](#hdLabelFontStyle),\n[hdLabelFontWeight](#hdLabelFontWeight), [hdLabelLimit](#hdLabelLimit), [hdLabelLineHeight](#hdLabelLineHeight),\n[hdLabelOrient](#hdLabelOrient), [hdLabelPadding](#hdLabelPadding), [hdLabels](#hdLabels),\n[hdOrient](#hdOrient), [hdTitle](#hdTitle), [hdTitleAlign](#hdTitleAlign), [hdTitleAnchor](#hdTitleAnchor),\n[hdTitleAngle](#hdTitleAngle), [hdTitleBaseline](#hdTitleBaseline), [hdTitleColor](#hdTitleColor),\n[hdTitleFont](#hdTitleFont), [hdTitleFontWeight](#hdTitleFontWeight), [hdTitleFontSize](#hdTitleFontSize),\n[hdTitleFontStyle](#hdTitleFontStyle), [hdTitleLimit](#hdTitleLimit), [hdTitleOrient](#hdTitleOrient)\nand [hdTitlePadding](#hdTitlePadding).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "HyperlinkChannel",
                "comment": " Generated by [hName](#hName), [hRepeat](#hRepeat), [hQuant](#hQuant),\n[hNominal](#hNominal), [hOrdinal](#hOrdinal), [hTemporal](#hTemporal), [hGeo](#hGeo),\n[hBin](#hBin), [hBinned](#hBinned), [hAggregate](#hAggregate), [hTimeUnit](#hTimeUnit),\n[hCondition](#hCondition) and [hStr](#hStr).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "ImMethod",
                "comment": " Generated by [imValue](#imValue), [imMean](#imMean), [imMedian](#imMedian),\n[imMax](#imMax) and [imMin](#imMin).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "ImputeProperty",
                "comment": " Generated by [imKeyVals](#imKeyVals), [imKeyValSequence](#imKeyValSequence)\n[imFrame](#imFrame), [imGroupBy](#imGroupBy), [imMethod](#imMethod) and [imNewValue](#imNewValue).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "InputProperty",
                "comment": " Generated by [inDebounce](#inDebounce), [inElement](#inElement),\n[inOptions](#inOptions), [inDatumOptions](#inDatumOptions), [inDataOptions](#inDataOptions),\n[inMin](#inMin), [inMax](#inMax), [inName](#inName), [inStep](#inStep) and\n[inPlaceholder](#inPlaceholder).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "KeyChannel",
                "comment": " Generated by [kName](#kName) and [kQuant](#kQuant), [kNominal](#kNominal),\n[kOrdinal](#kOrdinal), [kTemporal](#kTemporal) and [kGeo](#kGeo).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "Legend",
                "comment": " Generated by [leGradient](#leGradient) and [leSymbol](#leSymbol).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "LegendConfig",
                "comment": " Generated by [lecoAria](#lecoAria), [lecoClipHeight](#lecoClipHeight),\n[lecoColumnPadding](#lecoColumnPadding), [lecoColumns](#lecoColumns),\n[lecoCornerRadius](#lecoCornerRadius), [lecoDirection](#lecoDirection), [lecoDisable](#lecoDisable),\n[lecoFillColor](#lecoFillColor), [lecoOrient](#lecoOrient), [lecoOffset](#lecoOffset),\n[lecoStrokeColor](#lecoStrokeColor), [lecoStrokeDash](#lecoStrokeDash), [lecoStrokeWidth](#lecoStrokeWidth),\n[lecoPadding](#lecoPadding), [lecoRowPadding](#lecoRowPadding), [lecoGradientDirection](#lecoGradientDirection),\n[lecoGradientLabelLimit](#lecoGradientLabelLimit),[lecoGradientLabelOffset](#lecoGradientLabelOffset),\n[lecoGradientOpacity](#lecoGradientOpacity), [lecoGradientStrokeColor](#lecoGradientStrokeColor),\n[lecoGradientStrokeWidth](#lecoGradientStrokeWidth), [lecoGradientLength](#lecoGradientLength),\n[lecoGradientThickness](#lecoGradientThickness), [lecoGridAlign](#lecoGridAlign),\n[lecoLabelAlign](#lecoLabelAlign), [lecoLabelBaseline](#lecoLabelBaseline),\n[lecoLabelColor](#lecoLabelColor), [lecoLabelFont](#lecoLabelFont), [lecoLabelFontSize](#lecoLabelFontSize),\n[lecoLabelFontStyle](#lecoLabelFontStyle), [lecoLabelFontWeight](#lecoLabelFontWeight),\n[lecoLabelLimit](#lecoLabelLimit), [lecoLabelOffset](#lecoLabelOffset), [lecoLabelOverlap](#lecoLabelOverlap),\n[lecoSymbolBaseFillColor](#lecoSymbolBaseFillColor), [lecoSymbolBaseStrokeColor](#lecoSymbolBaseStrokeColor),\n[lecoSymbolDash](#lecoSymbolDash), [lecoSymbolDashOffset](#lecoSymbolDashOffset),\n[lecoSymbolDirection](#lecoSymbolDirection), [lecoSymbolFillColor](#lecoSymbolFillColor),\n[lecoSymbolLimit](#lecoSymbolLimit), [lecoSymbolOffset](#lecoSymbolOffset), [lecoSymbolOpacity](#lecoSymbolOpacity),\n[lecoSymbolSize](#lecoSymbolSize), [lecoSymbolStrokeColor](#lecoSymbolStrokeColor),\n[lecoSymbolStrokeWidth](#lecoSymbolStrokeWidth), [lecoSymbolType](#lecoSymbolType),\n[lecoNoTitle](#lecoNoTitle), [lecoTitleAlign](#lecoTitleAlign), [lecoTitleAnchor](#lecoTitleAnchor),\n[lecoTitleBaseline](#lecoTitleBaseline), [lecoTitleColor](#lecoTitleColor), [lecoTitleFont](#lecoTitleFont),\n[lecoTitleFontSize](#lecoTitleFontSize), [lecoTitleFontStyle](#lecoTitleFontStyle),\n[lecoTitleFontWeight](#lecoTitleFontWeight), [lecoTitleLimit](#lecoTitleLimit),\n[lecoTitleLineHeight](#lecoTitleLineHeight), [lecoTitlePadding](#lecoTitlePadding),\n[lecoUnselectedOpacity](#lecoUnselectedOpacity), [lecoX](#lecoX) and [lecoY](#lecoY).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "LegendOrientation",
                "comment": " Generated by [loLeft](#loLeft), [loTopLeft](#loTopLeft), [loTop](#loTop),\n[loTopRight](#loTopRight), [loRight](#loRight), [loBottomRight](#loBottomRight),\n[loBottom](#loBottom), [loBottomLeft](#loBottomLeft) and [loNone](#loNone).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "LegendProperty",
                "comment": " Generated by [leAria](#leAria), [leGradient](#leGradient), [leSymbol](#leSymbol),\n[leClipHeight](#leClipHeight), [leColumnPadding](#leColumnPadding), [leColumns](#leColumns),\n[leCornerRadius](#leCornerRadius), [leDirection](#leDirection), [leFillColor](#leFillColor),\n[leFormat](#leFormat), [leFormatAsNum](#leFormatAsNum), [leFormatAsTemporal](#leFormatAsTemporal),\n[leFormatAsCustom](#leFormatAsCustom) [leGradientLength](#leGradientLength),\n[leGradientOpacity](#leGradientOpacity) [leGradientThickness](#leGradientThickness),\n[leGradientStrokeColor](#leGradientStrokeColor), [leGradientStrokeWidth](#leGradientStrokeWidth),\n[leGridAlign](#leGridAlign), [leLabelAlign](#leLabelAlign), [leLabelBaseline](#leLabelBaseline),\n[leLabelColor](#leLabelColor), [leLabelFont](#leLabelFont), [leLabelFontSize](#leLabelFontSize),\n[leFontStyle](#leFontStyle), [leFontWeight](#leFontWeight), [leLabelLimit](#leLabelLimit),\n[leLabelOffset](#leLabelOffset), [leLabelOverlap](#leLabelOverlap), [leOffset](#leOffset),\n[leOrient](#leOrient), [lePadding](#lePadding), [leRowPadding](#leRowPadding),\n[leStrokeColor](#leStrokeColor), [leStrokeWidth](#leStrokeWidth), [leSymbolDash](#leSymbolDash),\n[leSymbolDashOffset](#leSymbolDashOffset) [leSymbolFillColor](#leSymbolFillColor),\n[leSymbolLimit](#leSymbolLimit), [leSymbolOffset](#leSymbolOffset), [leSymbolOpacity](#leSymbolOpacity),\n[leSymbolSize](#leSymbolSize), [leSymbolStrokeColor](#leSymbolStrokeColor),\n[leSymbolStrokeWidth](#leSymbolStrokeWidth), [leSymbolType](#leSymbolType), [leTickCount](#leTickCount),\n[leTitle](#leTitle), [leTitleAlign](#leTitleAlign), [leTitleAnchor](#leTitleAnchor),\n[leTitleBaseline](#leTitleBaseline), [leTitleColor](#leTitleColor), [leTitleFont](#leTitleFont),\n[leTitleFontStyle](#leTitleFontStyle), [leTitleFontSize](#leTitleFontSize),\n[leTitleFontWeight](#leTitleFontWeight), [leTitleLimit](#leTitleLimit), [leTitleLineHeight](#leTitleLineHeight),\n[leTitleOrient](#leTitleOrient), [leTitlePadding](#leTitlePadding), [leType](#leType),\n[leValues](#leValues), [leX](#leX), [leY](#leY) and [leZIndex](#leZIndex).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "LineMarker",
                "comment": " Generated by [lmMarker](#lmMarker) and [lmNone](#lmNone).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "LoessProperty",
                "comment": " Generated by [lsGroupBy](#lsGroupBy), [lsBandwidth](#lsBandwidth) and [lsAs](#lsAs).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "LookupFields",
                "comment": " Generated by [luFields](#luFields), [luFieldsAs](#luFieldsAs), [luAs](#luAs),\n[luFieldsWithDefault](#luFieldsWithDefault), [luFieldsAsWithDefault](#luFieldsAsWithDefault)\nand [luAsWithDefault](#luAsWithDefault)\n",
                "args": [],
                "cases": []
            },
            {
                "name": "Mark",
                "comment": " Generated by [arc](#arc), [area](#area), [bar](#bar), [boxplot](#boxplot),\n[circle](#circle), [errorband](#errorband), [errorbar](#errorbar), [geoshape](#geoshape),\n[image](#image), [line](#line), [point](#point), [rect](#rect), [rule](#rule),\n[square](#square), [textMark](#textMark), [tick](#tick) and [trail](#trail).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "MarkChannel",
                "comment": " Generated by [mName](#mName), [mDatum](#mDatum), [mQuant](#mQuant), [mNominal](#mNominal),\n[mOrdinal](#mOrdinal), [mTemporal](#mTemporal), [mGeo](#mGeo), [mRepeat](#mRepeat),\n[mRepeatDatum](#mRepeatDatum), [mScale](#mScale), [mBand](#mBand), [mBin](#mBin),\n[mBinned](#mBinned) [mTimeUnit](#mTimeUnit), [mTitle](#mTitle), [mAggregate](#mAggregate),\n[mLegend](#mLegend), [mSort](#mSort), [mCondition](#mCondition), [mConditions](#mConditions),\n[mPath](#mPath), [mNum](#mNum), [mStr](#mStr) and [mBoo](#mBoo).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "MarkInterpolation",
                "comment": " Generated by [miBasis](#miBasis), [miBasisClosed](#miBasisClosed),\n[miBasisOpen](#miBasisOpen), [miBundle](#miBundle), [miCardinal](#miCardinal),\n[miCardinalClosed](#miCardinalClosed), [miCardinalOpen](#miCardinalOpen),\n[miLinear](#miLinear), [miLinearClosed](#miLinearClosed), [miMonotone](#miMonotone),\n[miStepwise](#miStepwise), [miStepAfter](#miStepAfter), [miStepBefore](#miStepBefore)\nand [miExpr](#miExpr).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "MarkOrientation",
                "comment": " Generated by [moHorizontal](#moHorizontal) and [moVertical](#moVertical).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "MarkProperty",
                "comment": " Generated by [maAlign](#maAlign), [maAngle](#maAngle), [maAria](#maAria),\n[maBandSize](#maBandSize), [maBaseline](#maBaseline), [maBinSpacing](#maBinSpacing),\n[maBlend](#maBlend), [maBorders](#maBorders), [maBox](#maBox), [maClip](#maClip),\n[maColor](#maColor), [maColorGradient](#maColorGradient), [maCornerRadius](#maCornerRadius),\n[maCornerRadiusEnd](#maCornerRadiusEnd), [maCornerRadiusTopLeft](#maCornerRadiusTopLeft),\n[maCornerRadiusTopRight](#maCornerRadiusTopRightR), [maCornerRadiusBottomLeft](#maCornerRadiusBottomLeft),\n[maCornerRadiusBottomRight](#maCornerRadiusBottomRight), [maCursor](#maCursor),\n[maHRef](#maHRef), [maContinuousBandSize](#maContinuousBandSize), [maDir](#maDir),\n[maDiscreteBandSize](#maDiscreteBandSize), [maDx](#maDx), [maDy](#maDy), [maEllipsis](#maEllipsis),\n[maExtent](#maExtent), [maFill](#maFill), [maFillGradient](#maFillGradient), [maFilled](#maFilled),\n[maFillOpacity](#maFillOpacity), [maFont](#maFont), [maFontSize](#maFontSize),\n[maFontStyle](#maFontStyle), [maFontWeight](#maFontWeight), [maInnerRadius](#maInnerRadius),\n[maOuterRadius](#maOuterRadius), [maInterpolate](#maInterpolate), [maLimit](#maLimit),\n[maLine](#maLine), [maLineHeight](#maLineHeight), [maMedian](#maMedian), [maOpacity](#maOpacity),\n[maOutliers](#maOutliers), [maOrient](#maOrient), [maPadAngle](#maPadAngle),\n[maPoint](#maPoint), [maRadius](#maRadius), [maRadiusOffset](#maRadiusOffset),\n[maRadius2Offset](#maRadius2Offset), [maRemoveInvalid](#maRemoveInvalid),\n[maRule](#maRule), [maShape](#maShape), [maShortTimeLabels](#maShortTimeLabels), [maSize](#maSize),\n[maStroke](#maStroke), [maStrokeGradient](#maStrokeGradient), [maStrokeCap](#maStrokeCap),\n[maStrokeDash](#maStrokeDash), [maStrokeDashOffset](#maStrokeDashOffset), [maStrokeJoin](#maStrokeJoin),\n[maStrokeMiterLimit](#maStrokeMiterLimit), [maStrokeOpacity](#maStrokeOpacity),\n[maStrokeWidth](#maStrokeWidth), [maStyle](#maStyle), [maTension](#maTension),\n[maText](#maText), [maTheta](#maTheta), [maTheta2](#maTheta2), [maThetaOffset](#maThetaOffset),\n[maTheta2Offset](#maTheta2Offset),[maThickness](#maThickness), [maTicks](#maTicks),\n[maTooltip](#maTooltip), [maUrl](#maUrl), [maX](#maX), [maWidth](#maWidth), [maWidthBand](#maWidthBand),\n[maHeight](#maHeight), [maHeightBand](#maHeightBand), [maY](#maY), [maXOffset](#maXOffset),\n[maYOffset](#maYOffset), [maX2](#maX2), [maY2](#maY2),[maX2Offset](#maX2Offset)\nand [maY2Offset](#maY2Offset).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "Measurement",
                "comment": " Type of measurement to be associated with some channel.\n\n  - `Nominal` indicates categories that have no order. e.g. people's names; country names.\n  - `Ordinal` indicates ordered categories. e.g. Small / Medium / Large; 1st, 2nd, 3rd.\n  - `Quantitative` indicates numerical measurements and counts. e.g. price; temperature; frequency.\n  - `Temporal` indicates time-related data.\n  - `GeoFeature` indicates one or more geographic locations. e.g. a longitude/latitude; country outline.\n\n",
                "args": [],
                "cases": []
            },
            {
                "name": "MonthName",
                "comment": " Identify a month of the year.\n",
                "args": [],
                "cases": [
                    [
                        "Jan",
                        []
                    ],
                    [
                        "Feb",
                        []
                    ],
                    [
                        "Mar",
                        []
                    ],
                    [
                        "Apr",
                        []
                    ],
                    [
                        "May",
                        []
                    ],
                    [
                        "Jun",
                        []
                    ],
                    [
                        "Jul",
                        []
                    ],
                    [
                        "Aug",
                        []
                    ],
                    [
                        "Sep",
                        []
                    ],
                    [
                        "Oct",
                        []
                    ],
                    [
                        "Nov",
                        []
                    ],
                    [
                        "Dec",
                        []
                    ]
                ]
            },
            {
                "name": "Operation",
                "comment": " Generated by [opArgMax](#opArgMax), [opArgMin](#opArgMin), [opCI0](#opCI0),\n[opCI1](#opCI1), [opCount](#opCount), [opDistinct](#opDistinct), [opMax](#opMax),\n[opMean](#opMean), [opMedian](#opMedian), [opMin](#opMin), [opMissing](#opMissing),\n[opProduct](#opProduct), [opQ1](#opQ1), [opQ3](#opQ3), [opStderr](#opStderr),\n[opStdev](#opStdev), [opStdevP](#opStdevP), [opSum](#opSum), [opValid](#opValid),\n[opVariance](#opVariance) and [opVarianceP](#opVarianceP).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "OrderChannel",
                "comment": " Generated by [oName](#oName), [oRepeat](#oRepeat), [oQuant](#oQuant), [oNominal](#oNominal),\n[oOrdinal](#oOrdinal), [oTemporal](#oTemporal), [oGeo](#oGeo), [oBin](#oBin),\n[oAggregate](#oAggregate), [oTimeUnit](#oTimeUnit), [oSort](#oSort), [oNum](#oNum),\n[oCondition](#oCondition) and [oConditions](#oConditions).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "OverlapStrategy",
                "comment": " Generated by [osNone](#osNone), [osGreedy](#osGreedy), [osParity](#osParity)\nand [osExpr].\n",
                "args": [],
                "cases": []
            },
            {
                "name": "PBinding",
                "comment": " Generated by [ipRange](#ipRange), [ipCheckbox](#ipCheckbox),\n[ipRadio](#ipRadio), [ipSelect](#ipSelect), [ipText](#ipText), [ipNumber](#ipNumber),\n[ipDate](#ipDate), [ipTime](#ipTime), [ipMonth](#ipMonth), [ipWeek](#ipWeek),\n[ipDateTimeLocal](#ipDateTimeLocal), [ipTel](#ipTel) and [ipColor](#ipColor).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "Padding",
                "comment": " Generated by [paSize](#paSize), [paEdges](#paEdges) and [paEdgesExpr](#paEdgesExpr).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "ParamProperty",
                "comment": " Generated by [paBind](#paBind), [paBindings](#paBindings), [paBindLegend](#paBindLegend),\n[paBindScales](#paBindScales), [paExpr](#paExpr), [paValue](#paValue), [paValues](#paValues)\nand [paSelect](#paSelect).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "PivotProperty",
                "comment": " Generated by [piGroupBy](#piGroupBy), [piLimit](#piLimit) and [piOp](#piOp).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "PointMarker",
                "comment": " Generated by [pmNone](#pmNone), [pmTransparent](#pmTransparent) and [pmMarker](#pmMarker).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "Position",
                "comment": " Type of position channel. `X` and `Y` position marks along the horizontal and\nvertical axes. `X2` and `Y2` are used in combination with `X` and `Y` when two\nboundaries of a mark need to be specified (e.g. a [rule](#rule) mark). `XOffset`\nand `YOffset` can additional shift position in response to some field, for example\nto create a grouped bar chart or jitter-plot.\n\n`Theta` positions an [arc](#arc) mark's angular offset allowing, for example, pie\nchart segments to be specified. `Theta2` allows an end angle to be specified in\nradians (where 0 is 'north'), useful for individual 'pie' segments.\n\n`R` and `R2` position the outer and inner radial edges of an arc segment. Useful\nfor rose diagrams where arc radii are data-driven.\n\n`Longitude`/`Longitude2` and `Latitude`/`Latitude2` are the equivalent for\ngeographic positioning subject to [projection](#projection).\n\n`XError`/`XError2` and `YError`/`YError2` are used when specifying bounds of an\n[errorbar](#errorbar) mark.\n\n",
                "args": [],
                "cases": [
                    [
                        "X",
                        []
                    ],
                    [
                        "Y",
                        []
                    ],
                    [
                        "X2",
                        []
                    ],
                    [
                        "Y2",
                        []
                    ],
                    [
                        "XOffset",
                        []
                    ],
                    [
                        "YOffset",
                        []
                    ],
                    [
                        "Theta",
                        []
                    ],
                    [
                        "Theta2",
                        []
                    ],
                    [
                        "R",
                        []
                    ],
                    [
                        "R2",
                        []
                    ],
                    [
                        "Longitude",
                        []
                    ],
                    [
                        "Latitude",
                        []
                    ],
                    [
                        "Longitude2",
                        []
                    ],
                    [
                        "Latitude2",
                        []
                    ],
                    [
                        "XError",
                        []
                    ],
                    [
                        "YError",
                        []
                    ],
                    [
                        "XError2",
                        []
                    ],
                    [
                        "YError2",
                        []
                    ]
                ]
            },
            {
                "name": "PositionChannel",
                "comment": " Generated by [pName](#pName), [pDatum](#pDatum), [pQuant](#pQuant), [pNominal](#pNominal),\n[pOrdinal](#pOrdinal), [pTemporal](#pTemporal), [pGeo](#pGeo), [pRepeat](#pRepeat),\n[pRepeatDatum](#pRepeatDatum), [pBin](#PBin), [pBinned](#pBinned), [pTimeUnit](#pTimeUnit),\n[pTitle](#pTitle), [pAggregate](#pAggregate), [pScale](#pScale), [pAxis](#pAxis), [pSort](#pSort),\n[pBandPosition](#pBandPosition), [pStack](#pStack), [pWidth](#pWidth), [pHeight](#pHeight),\n[pNum](#pNum) and [pImpute](#pImpute).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "Predicate",
                "comment": " Generated by [prParam](#prParam), [prParamEmpty](#prParamEmpty) and [prTest](#prTest).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "Projection",
                "comment": " Generated by [albers](#albers), [albersUsa](#albersUsa),\n[azimuthalEqualArea](#azimuthalEqualArea), [azimuthalEquidistant](#azimuthalEquidistant),\n[conicConformal](#conicConformal), [conicEqualArea](#conicEqualArea),\n[conicEquidistant](#conicEquidistant), [equalEarth](#equalEarth),\n[equirectangular](#equirectangular), [gnomonic](#gnomonic),\n[identityProjection](#identityProjection), [mercator](#mercator), [naturalEarth1](#naturalEarth1)\n[orthographic](#orthographic), [stereographic](#stereographic),\n[transverseMercator](#transverseMercator), [customProjection](#customProjection)\nand [prExpr](#prExpr).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "ProjectionProperty",
                "comment": " Generated by [prType](#prType), [prClipAngle](#prClipAngle), [prClipExtent](#prClipExtent),\n[prCenter](#prCenter), [prFit](#prFit), [prScale](#prScale), [prTranslate](#prTranslate),\n[prRotate](#prRotate), [prRotateExpr](#prRotateExpr), [prPrecision](#prPrecision),\n[prCoefficient](#prCoefficient), [prDistance](#prDistance), [prFraction](#prFraction),\n[prLobes](#prLobes), [prParallels](#prParallels), [prParallelsExpr](#prParallelsExpr),\n[prReflectX](#prReflectX), [prReflectY](#prReflectY), [prParallel](#prParallel),\n[prPointRadius](#prPointRadius), [prRadius](#prRadius), [prRatio](#prRatio),\n[prSpacing](#prSpacing) and [prTilt](#prTilt).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "QuantileProperty",
                "comment": " Generated by [qtGroupBy](#qtGroupBy), [qtProbs](#qtProbs), [qtStep](#qtStep)\nand [qtAs](#qtAs).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "RangeConfig",
                "comment": " Generated by [racoCategory](#racoCategory), [racoDiverging](#racoDiverging),\n[racoHeatmap](#racoHeatmap), [racoOrdinal](#racoOrdinal), [racoRamp](#racoRamp),\n[racoSymbols](#racoSymbols) and <racoSymbolsExpr>.\n",
                "args": [],
                "cases": []
            },
            {
                "name": "RegressionMethod",
                "comment": " Generated by [rgLinear](#rgLinear), [rgLog](#rgLog), [rgExp](#rgExp), [rgPow](#rgPow),\n[rgQuad](#rgQuad) and [rgPoly](#rgPoly).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "RegressionProperty",
                "comment": " Generated by [rgGroupBy](#rgGroupBy), [rgMethod](#rgMethod), [rgOrder](#rgOrder),\n[rgExtent](#rgExtent), [rgParams](#rgParams) and [rgAs](#rgAs).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "RepeatFields",
                "comment": " Generated by [rowFields](#rowFields), [columnFields](#columnFields) and\n[layerFields](#layerFields).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "Resolution",
                "comment": " Generated by [reShared](#reShared) and [reIndependent](#reIndependent).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "Resolve",
                "comment": " Generated by [reAxis](#reAxis), [reLegend](#reLegend) and [reScale](#reScale).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "Scale",
                "comment": " Generated by [scLinear](#scLinear), [scPow](#scPow), [scSqrt](#scSqrt),\n[scLog](#scLog), [scSymLog](#scSymLog), [scTime](#scTime), [scUtc](#scUtc),\n[scOrdinal](#scOrdinal), [scBand](#scBand), [scPoint](#scPoint),\n[scBinOrdinal](#scBinOrdinal), [scQuantile](#scQuantile), [scQuantize](#scQuantize)\nand [scThreshold](#scThreshold).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "ScaleConfig",
                "comment": " Generated by [sacoBandPaddingInner](#sacoBandPaddingInner), [sacoBandPaddingOuter](#sacoBandPaddingOuter),\n[sacoBarBandPaddingInner](#sacoBarBandPaddingInner), [sacoRectBandPaddingInner](#sacoRectBandPaddingInner),\n[sacoClamp](#sacoClamp), [sacoContinuousPadding](#sacoContinuousPadding), [sacoMaxBandSize](#sacoMaxBandSize),\n[sacoMinBandSize](#sacoMinBandSize), [sacoMaxFontSize](#sacoMaxFontSize), [sacoMinFontSize](#sacoMinFontSize),\n[sacoMaxOpacity](#sacoMaxOpacity), [sacoMinOpacity](#sacoMinOpacity), [sacoMaxSize](#sacoMaxSize),\n[sacoMinSize](#sacoMinSize), [sacoMaxStrokeWidth](#sacoMaxStrokeWidth), [sacoMinStrokeWidth](#sacoMinStrokeWidth),\n[sacoPointPadding](#sacoPointPadding), [sacoRound](#sacoRound),\n[sacoUseUnaggregatedDomain](#sacoUseUnaggregatedDomain) and [sacoXReverse](#sacoXReverse).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "ScaleDomain",
                "comment": " Generated by [doNums](#doNums), [doMin](#doMin), [doMid](#doMid), [doMax](#doMax),\n[doStrs](#doStrs), [doDts](#doDts), [doDtsExpr](#doDtsExpr), [doMinDt](#doMinDt),\n[doMinDtExpr](#doMinDtExpr), [doMaxDt](#doMaxDt), [doMaxDtExpr](#doMaxDtExpr),\n[doSelection](#doSelection), [doSelectionChannel](#doSelectionChannel), [doSelectionField](#doSelectionField),\n[doUnionWith](#doUnionWith) and [doUnaggregated](#doUnaggregated).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "ScaleNice",
                "comment": " Generated by [niTrue](#niTrue), [niFalse](#niFalse), [niMillisecond](#niMillisecond),\n[niSecond](#niSecond), [niMinute](#niMinute), [niHour](#niHour), [niDay](#niDay),\n[niWeek](#niWeek), [niMonth](#niMonth), [niYear](#niYear), [niTickCount](#niTickCount),\n[niInterval](#niInterval) and [niExpr](#niExpr).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "ScaleProperty",
                "comment": " Generated by [scType](#scType), [scDomain](#scDomain), [scDomainExpr](#scDomainExpr),\n[scRange](#scRange), [scScheme](#scScheme), [scSchemeExpr](#scSchemeExpr), [scAlign](#scAlign),\n[scPadding](#scPadding), [scPaddingInner](#scPaddingInner), [scPaddingOuter](#scPaddingOuter),\n[scReverse](#scReverse), [scRound](#scRound), [scClamp](#scClamp), [scInterpolate](#scInterpolate),\n[scNice](#scNice), [scExponent](#scExponent), [scConstant](#scConstant), [scBase](#scBase)\nand [scZero](#scZero).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "ScaleRange",
                "comment": " Generated by [raNums](#raNums), [raExprs](#raExprs), [raMin](#raMin), [raMax](#raMax),\n[raStrs](#raStrs), [raNumLists](#raNumLists), [raName](#raName) and [raField](#raField).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "Selection",
                "comment": " Generated by [sePoint](#sePoint) and [seInterval](#seInterval).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "SelectionMarkProperty",
                "comment": " Generated by [smFill](#smFill), [smFillOpacity](#smFillOpacity), [smStroke](#smStroke),\n[smStrokeDash](#smStrokeDash), [smStrokeDashOffset](#smStrokeDashOffset),\n[smStrokeOpacity](#smStrokeOpacity), [smStrokeWidth](#smStrokeWidth) and\n[smCursor](#smCursor).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "SelectionProperty",
                "comment": " Generated by [seClear](#seClear), [seEncodings](#seEncodings),[seFields](#seFields),\n[seNearest](#seNearest), [seOn](#seOn), [seResolve](#seResolve),\n[seSelectionMark](#seSelectionMark), [seToggle](#seToggle), [seTranslate](#seTranslate)\nand [seZoom](#seZoom).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "SelectionResolution",
                "comment": " Generated by [seGlobal](#seGlobal), [seUnion](#seUnion) and\n[seIntersection](#seIntersection).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "Side",
                "comment": " Generated by [siLeft](#siLeft), [siRight](#siRight), [siTop](#siTop),\n[siBottom](#siBottom) and [siExpr](#siExpr).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "SortField",
                "comment": " Generated by [stAscending](#stAscending), [wiAscending](#wiAscending),\n[stDescending](#stDescending) and [wiDescending](#wiDescending).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "SortProperty",
                "comment": " Generated by [soAscending](#soAscending), [soDescending](#soDescending),\n[soByField](#soByField), [soByChannel](#soByChannel), [soByRepeat](#soByRepeat)\nand [soCustom](#soCustom).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "StackOffset",
                "comment": " Generated by [stZero](#stZero), [stCenter](#stCenter), [stNormalize](#stNormalize)\nand [stNone](#stNone).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "StackProperty",
                "comment": " Generated by [stOffset](#stOffset) and [stSort](#stSort).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "StrokeCap",
                "comment": " Generated by [caButt](#caButt), [caRound](#caRound), [caSquare](#caSquare) and\n[caExpr](#caExpr).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "StrokeJoin",
                "comment": " Generated by [joMiter](#joMiter), [joRound](#joRound), [joBevel](#joBevel) and\n[joExpr](#joExpr).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "SummaryExtent",
                "comment": " Generated by [exCi](#exCi), [exIqr](#exIqr), [exIqrScale](#exIqrScale), [exRange](#exRange),\n[exStderr](#exStderr) and [exStdev](#exStdev).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "Symbol",
                "comment": " Generated by [symCircle](#symCircle), [symSquare](#symSquare), [symCross](#symCross),\n[symDiamond](#symDiamond), [symTriangleUp](#symTriangleUp), [symTriangleDown](#symTriangleDown),\n[symTriangleLeft](#symTriangleLeft), [symTriangleRight](#symTriangleRight), [symPath](#symPath),\n[symStroke](#symStroke), [symArrow](#symArrow), [symWedge](#symWedge),[symTriangle](#symTriangle)\nand [symExpr](#symExpr).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "TextChannel",
                "comment": " Generated by [tName](#tName), [tRepeat](#tRepeat), [tQuant](#tQuant),\n[tNominal](#tNominal), [tOrdinal](#tOrdinal), [tTemporal](#tTemporal), [tGeo](#tGeo),\n[tBin](#tBin), [tBinned](#tBinned), [tAggregate](#tAggregate), [tTimeUnit](#tTimeUnit),\n[tTitle](#tTitle), [tCondition](#tCondition), [tConditions](#tConditions),\n[tFormat](#tFormat), [tFormatAsNum](#tFormatAsNum), [tFormatAsTemporal](#tFormatAsTemporal),\n[tFormatAsCustom](#tFormatAsCustom), [tStr](#tStr) and [tDatum](#tDatum).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "TimeUnit",
                "comment": " Generated by [date](#date), [day](#day), [dayOfYear](#dayOfYear), [dayHours](#dayHours),\n[dayHoursMinutes](#dayHoursMinutes), [dayHoursMinutesSeconds](#dayHoursMinutesSeconds),\n[hours](#hours), [hoursMinutes](#hoursMinutes), [hoursMinutesSeconds](#hoursMinutesSeconds),\n[milliseconds](#milliseconds), [minutes](#minutes), [minutesSeconds](#minutesSeconds),\n[month](#month), [monthDate](#monthDate), [monthDateHoursMinutes](#monthDateHoursMinutes),\n[monthDateHoursMinutesSeconds](#monthDateHoursMinutesSeconds), [quarter](#quarter),\n[quarterMonth](#quarterMonth), [seconds](#seconds), [secondsMilliseconds](#secondsMilliseconds),\n[week](#week), [weekDay](#weekDay), [weekDayHours](#weekDayHours), [weekDayHoursMinutes](#weekDayHoursMinutes),\n[weekDayHoursMinutesSeconds](#weekDayHoursMinutesSeconds), [year](#year), [yearQuarter](#yearQuarter),\n[yearQuarterMonth](#yearQuarterMonth), [yearMonth](#yearMonth), [yearMonthDate](#yearMonthDate),\n[yearMonthDateHours](#yearMonthDateHours), [yearMonthDateHoursMinutes](#yearMonthDateHoursMinutes),\n[yearMonthDateHoursMinutesSeconds](#yearMonthDateHoursMinutesSeconds), [yearWeek](#yearWeek),\n[yearWeekDay](#yearWeekDay), [yearWeekDayHours](#yearWeekDayHours),\n[yearWeekDayHoursMinutes](#yearWeekDayHoursMinutes),\n[yearWeekDayHoursMinutesSeconds](#yearWeekDayHoursMinutesSeconds),\n[yearDayOfYear](#yearDayOfYear), [utc](#utc), [tuMaxBins](#tuMaxBins) and\n[tuStep](#tuStep).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "TitleFrame",
                "comment": " Generated by [tfBounds](#tfBounds), [tfGroup](#tfGroup) and [tfExpr](#tfExpr).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "TitleProperty",
                "comment": " Generated by [tiAnchor](#tiAnchor), [tiAngle](#tiAngle), [tiBaseline](#tiBaseline),\n[tiColor](#tiColor), [tiDx](#tiDx), [tiDy](#tiDy), [tiFont](#tiFont), [tiFontSize](#tiFontSize),\n[tiFontStyle](#tiFontStyle), [tiFontWeight](#tiFontWeight), [tiFrame](#tiFrame),\n[tiLimit](#tiLimit), [tiLineHeight](#tiLineHeight),[tiOffset](#tiOffset),\n[tiOrient](#tiOrient), [tiStyle](#tiStyle) [tiSubtitle](#tiSubtitle),\n[tiSubtitleColor](#tiSubtitleColor), [tiSubtitleFont](#tiSubtitleFont),\n[tiSubtitleFontSize](#tiSubtitleFontSize), [tiSubtitleFontStyle](#tiSubtitleFontStyle),\n[tiSubtitleFontWeight](#tiSubtitleFontWeight), [tiSubtitleLineHeight](#tiSubtitleLineHeight),\n[tiSubtitlePadding](#tiSubtitlePadding) and [tiZIndex](#tiZIndex).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "TogglePredicate",
                "comment": " Generate by [tpFalse](#tpFalse), [tpShiftKey](#tpShiftKey), [tpCtrlKey](#tpCtrlKey),\n[tpAltKey](#tpAltKey) and [tpExpr](#tpExpr).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "TooltipContent",
                "comment": " Generated by [ttEncoding](#ttEncoding), [ttData](#ttData) and [ttNone](#ttNone).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "VAlign",
                "comment": " Generated by [vaTop](#vaTop), [vaLineTop](#vaLineTop), [vaMiddle](#vaMiddle),\n[vaAlphabetic](#vaAlphabetic), [vaBottom](#vaBottom), [vaLineBottom](#vaLineBottom)\nand [vaExpr](#vaExpr).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "VLProperty",
                "comment": " Top-level Vega-Lite properties. These are the ones that define the core of the\nvisualization grammar. All `VLProperties` are created by functions in seven broad groups.\n\n**Data properties** relate to the input data to be visualized. Generated by\n[`dataFromColumns`](#dataFromColumns), [`dataFromRows`](#dataFromRows),\n[`dataFromUrl`](#dataFromUrl), [`dataFromSource`](#dataFromSource),\n[`dataFromJson`](#dataFromJson), [`dataSequence`](#dataSequence), [`sphere`](#sphere)\nand [`graticule`](#graticule).\n\n**Transform properties** indicate that some transformation of input data should\nbe applied before encoding them visually. Generated by [`transform`](#transform)\nand [`projection`](#projection) they can include data transformations such as\n[`filter`](#filter), [`binAs`](#binAs) and [`calculateAs`](#calculateAs) and geo\ntransformations of longitude, latitude coordinates used by marks such as\n[`geoshape`](#geoshape), [`point`](#point) and [`line`](#line).\n\n**Mark functions** specify the graphical symbols used to visualize data items.\nGenerated by functions such as [`circle`](#circle), [`bar`](#bar) and [`line`](#line).\n\n**Encoding properties** specify which data elements are mapped to which mark\ncharacteristics (known as _channels_). Generated by [`encoding`](#encoding) they\ninclude encodings such as [`position`](#position), [`color`](#color), [`size`](#size),\n[`shape`](#shape), [`text`](#text), [`hyperlink`](#hyperlink) and [`order`](#order).\n\n**Composition properties** allow visualization views to be combined to form more\ncomplex visualizations. Generated by [`layer`](#layer), [`repeatFlow`](#repeatFlow),\n[`repeat`](#repeat), [`facetFlow`](#facetFlow), [`facet`](#facet), [`concat`](#concat),\n[`columns`](#columns), [`hConcat`](#hConcat), [`vConcat`](#vConcat),\n[`specification`](#specification) and [`resolve`](#resolve).\n\n**Interaction properties** allow clicking, dragging and other interactions generated\nvia a GUI or data stream to influence the visualization. Generated by\n[`params`](#7-parameters) with a [paSelect](#paSelect) parameter.\n\n**Supplementary and configuration properties** provide a means to add metadata and\nstyling to one or more visualizations. Generated by [`name`](#name), [`title`](#title),\n[`description`](#description), [`background`](#background), [`backgroundExpr`](#backgroundExpr),\n[`width`](#width), [`height`](#height), [`widthStep`](#widthStep), [`heightStep`](#heightStep),\n[`padding`](#padding), [`autosize`](#autosize), [`viewBackground`](#viewBackground)\nand [`configure`](#configure).\n\n",
                "args": [],
                "cases": []
            },
            {
                "name": "ViewBackground",
                "comment": " Generated by [viewStyle](#viewStyle), [viewCornerRadius](#viewCornerRadius),\n[viewFill](#viewFill), [viewFillOpacity](#viewFillOpacity), [viewOpacity](#viewOpacity),\n[viewStroke](#viewStroke), [viewStrokeOpacity](#viewStrokeOpacity), [viewStrokeWidth](#viewStrokeWidth),\n[viewStrokeCap](#viewStrokeCap), [viewStrokeDash](#viewStrokeDash), [viewStrokeDashOffset](#viewStrokeDashOffset),\n[viewStrokeJoin](#viewStrokeJoin) and [viewStrokeMiterLimit](#viewStrokeMiterLimit).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "ViewConfig",
                "comment": " Generated by [vicoBackground](#vicoBackground), [vicoClip](#vicoClip),\n[vicoContinuousHeight](#vicoContinuousHeight), [vicoContinuousWidth](#vicoContinuousWidth),\n[vicoCursor](#vicoCursor), [vicoDiscreteHeight](#vicoDiscreteHeight),\n[vicoDiscreteWidth](#vicoDiscreteWidth), [vicoCornerRadius](#vicoCornerRadius),\n[vicoFill](#vicoFill), [vicoFillOpacity](#vicoFillOpacity), [vicoOpacity](#vicoOpacity),\n[vicoStep](#vicoStep), [vicoStroke](#vicoStroke), [vicoStrokeCap](#vicoStrokeCap),\n[vicoStrokeDash](#vicoStrokeDash), [vicoStrokeDashOffset](#vicoStrokeDashOffset),\n[vicoStrokeJoin](#vicoStrokeJoin), [vicoStrokeMiterLimit](#vicoStrokeMiterLimit),\n[vicoStrokeOpacity](#vicoStrokeOpacity) and [vicoStrokeWidth](#vicoStrokeWidth).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "WOperation",
                "comment": " Generated by [woRowNumber](#woRowNumber), [woRank](#woRank), [woDenseRank](#woDenseRank),\n[woPercentRank](#woPercentRank), [woCumeDist](#woCumeDist), [woPercentile](#woPercentile),\n[woLag](#woLag), [woLead](#woLead), [woFirstValue](#woFirstValue), [woLastValue](#woLastValue),\nand [woNthValue](#woNthValue).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "Window",
                "comment": " Generated by [wiAggregateOp](#wiAggregateOp), [wiOp](#wiOp), [wiParam](#wiParam)\nand [wiField](#wiField).\n",
                "args": [],
                "cases": []
            },
            {
                "name": "WindowProperty",
                "comment": " Generated by [wiFrame](#wiFrame), [wiIgnorePeers](#wiIgnorePeers), [wiGroupBy](#wiGroupBy)\nand [wiSort](#wiSort).\n",
                "args": [],
                "cases": []
            }
        ],
        "aliases": [
            {
                "name": "Data",
                "comment": " Convenience type annotation label for use with data generation functions.\n\n    myRegion : List DataColumn -> Data\n    myRegion =\n        dataFromColumns []\n            << dataColumn \"easting\" (nums [ -3, 4, 4, -3, -3 ])\n            << dataColumn \"northing\" (nums [ 52, 52, 45, 45, 52 ])\n\n",
                "args": [],
                "type": "( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "DataColumn",
                "comment": " A single column of data. Used when generating inline data with [dataColumn](#dataColumn).\n",
                "args": [],
                "type": "List.List VegaLite.LabelledSpec"
            },
            {
                "name": "DataRow",
                "comment": " A single row of data. Used when generating inline data with [dataRow](#dataRow).\n",
                "args": [],
                "type": "VegaLite.Spec"
            },
            {
                "name": "LabelledSpec",
                "comment": " A named Vega-Lite specification, usually generated by an elm-vega\nfunction. You shouldn't need to create `LabelledSpec` tuples directly, but are\nuseful for type annotations.\n",
                "args": [],
                "type": "( String.String, VegaLite.Spec )"
            },
            {
                "name": "Spec",
                "comment": " Part or all of a Vega-Lite specification. Specs are usually nested and can\nrange from a single Boolean value up to the full visualization specification.\n",
                "args": [],
                "type": "Json.Encode.Value"
            },
            {
                "name": "TitleConfig",
                "comment": " Generated by [ticoAnchor](#ticoAnchor), [ticoAngle](#ticoAngle), [ticoBaseline](#ticoBaseline),\n[ticoColor](#ticoColor), [ticoDx](#ticoDx), [ticoDy](#ticoDy), [ticoFont](#ticoFont),\n[ticoFontSize](#ticoFontSize), [ticoFontStyle](#ticoFontStyle), [ticoFontWeight](#ticoFontWeight),\n[ticoFrame](#ticoFrame), [ticoLimit](#ticoLimit), [ticoLineHeight](#ticoLineHeight),\n[ticoOffset](#ticoOffset), [ticoOrient](#ticoOrient), [ticoStyle](#ticoStyle),\n[ticoSubtitleColor](#ticoSubtitleColor), [ticoSubtitleFont](#ticoSubtitleFont),\n[ticoSubtitleFontSize](#ticoSubtitleFontSize), [ticoSubtitleFontStyle](#ticoSubtitleFontStyle),\n[ticoSubtitleFontWeight](#ticoSubtitleFontWeight), [ticoSubtitleLineHeight](#ticoSubtitleLineHeight),\n[ticoSubtitlePadding](#ticoSubtitlePadding) and [ticoZIndex](#ticoZIndex).\n",
                "args": [],
                "type": "VegaLite.TitleProperty"
            }
        ],
        "values": [
            {
                "name": "aggregate",
                "comment": " Aggregation transformations to be used when encoding channels. Useful when for\napplying the same transformation to a number of channels without defining it each\ntime. The first parameter is a list of the named aggregation operations to apply.\nThe second is a list of 'group by' fields.\n\n    trans =\n        transform\n            << aggregate\n                [ opAs opMin \"people\" \"lowerBound\", opAs opMax \"people\" \"upperBound\" ]\n                [ \"age\" ]\n\n",
                "type": "List.List VegaLite.Spec -> List.List String.String -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"
            },
            {
                "name": "albers",
                "comment": " An Albers equal-area conic map projection.\n",
                "type": "VegaLite.Projection"
            },
            {
                "name": "albersUsa",
                "comment": " An Albers USA map projection that combines continental USA with Alaska and Hawaii.\nUnlike other projection types, this remains unaffected by [prRotate](#prRotate).\n",
                "type": "VegaLite.Projection"
            },
            {
                "name": "align",
                "comment": " Alignment to apply to grid rows and columns generated by a composition\noperator. This version sets the same alignment for rows and columns.\n",
                "type": "VegaLite.CompositionAlignment -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "alignRC",
                "comment": " Similar to [align](#align) but with independent alignments for rows (first\nparameter) and columns (second parameter).\n",
                "type": "VegaLite.CompositionAlignment -> VegaLite.CompositionAlignment -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "anEnd",
                "comment": " Anchor some text at its end.\n",
                "type": "VegaLite.Anchor"
            },
            {
                "name": "anExpr",
                "comment": " Specify an anchor style (\"start\", \"middle\", \"end\") with an expression.\n",
                "type": "String.String -> VegaLite.Anchor"
            },
            {
                "name": "anMiddle",
                "comment": " Anchor some text in its start.\n",
                "type": "VegaLite.Anchor"
            },
            {
                "name": "anStart",
                "comment": " Anchor some text at its start.\n",
                "type": "VegaLite.Anchor"
            },
            {
                "name": "and",
                "comment": " Apply an 'and' Boolean operation as part of a logical composition.\n\n    and (expr \"datum.IMDB_Rating === null\") (expr \"datum.Rotten_Tomatoes_Rating === null\")\n\n",
                "type": "VegaLite.BooleanOp -> VegaLite.BooleanOp -> VegaLite.BooleanOp"
            },
            {
                "name": "angle",
                "comment": " Encode an angle (orientation) channel. This allows data-driven rotation of\ntext, point-based marks.\n",
                "type": "List.List VegaLite.MarkChannel -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"
            },
            {
                "name": "arColumn",
                "comment": " Column arrangement in a repeated/faceted view.\n",
                "type": "VegaLite.Arrangement"
            },
            {
                "name": "arDescription",
                "comment": " Description to be provided in [ARIA tag](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA)\nwhen generating SVG output. If not specified, the an auto-generated description\nwill be provided.\n",
                "type": "String.String -> VegaLite.Aria"
            },
            {
                "name": "arDisable",
                "comment": " Disable [ARIA attributes](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA)\nwhen generating SVG output. Default is that Aria is enabled.\n",
                "type": "VegaLite.Aria"
            },
            {
                "name": "arEnable",
                "comment": " Enable [ARIA attributes](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA)\nwhen generating SVG output. Default is that Aria is enabled, so this is only useful\nwhen overriding more global disabling of Aria attributes.\n",
                "type": "VegaLite.Aria"
            },
            {
                "name": "arExpr",
                "comment": " Set [ARIA attributes](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA)\nwith the the given expression. For example,\n\n    params\n        << param \"barDesc\"\n            [ paValue (dataObject [ ( \"description\", str \"Bar chart bar\" ) ]) ]\n\n    bar [ maAria [ arExpr \"barDesc\" ] ]\n\n",
                "type": "String.String -> VegaLite.Aria"
            },
            {
                "name": "arFlow",
                "comment": " Flow arrangement in a repeated/faceted view.\n",
                "type": "VegaLite.Arrangement"
            },
            {
                "name": "arLayer",
                "comment": " Layer arrangement in a repeated view.\n",
                "type": "VegaLite.Arrangement"
            },
            {
                "name": "arRow",
                "comment": " Row arrangement in a repeated/faceted view.\n",
                "type": "VegaLite.Arrangement"
            },
            {
                "name": "arc",
                "comment": " [Arc mark](https://vega.github.io/vega-lite/docs/arc.html) for radial plots\nsuch as pie charts or rose diagrams.\n",
                "type": "List.List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "area",
                "comment": " An [area mark](https://vega.github.io/vega-lite/docs/area.html) for representing\na series of data elements, such as in a stacked area chart or streamgraph.\n",
                "type": "List.List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "arrow",
                "comment": " [Apache arrow](https://observablehq.com/@theneuralbit/introduction-to-apache-arrow)\ndata file format.\n\n    data =\n        dataFromUrl \"https://gicentre.github.io/data/scrabble.arrow\" [ arrow ]\n\n",
                "type": "VegaLite.Format"
            },
            {
                "name": "asContent",
                "comment": " Interpret visualization dimensions to be for the data rectangle (external\npadding added to this size).\n",
                "type": "VegaLite.Autosize"
            },
            {
                "name": "asFit",
                "comment": " Interpret visualization dimensions to be for the entire visualization (data\nrectangle is shrunk to accommodate external decorations padding).\n",
                "type": "VegaLite.Autosize"
            },
            {
                "name": "asFitX",
                "comment": " Interpret visualization width to be for the entire visualization width (data\nrectangle width is shrunk to accommodate external decorations padding).\n",
                "type": "VegaLite.Autosize"
            },
            {
                "name": "asFitY",
                "comment": " Interpret visualization height to be for the entire visualization height\n(data rectangle height is shrunk to accommodate external decorations padding).\n",
                "type": "VegaLite.Autosize"
            },
            {
                "name": "asNone",
                "comment": " No autosizing to be applied.\n",
                "type": "VegaLite.Autosize"
            },
            {
                "name": "asPad",
                "comment": " Automatically expand size of visualization from the given dimensions in order\nto fit in all supplementary decorations (legends etc.).\n",
                "type": "VegaLite.Autosize"
            },
            {
                "name": "asPadding",
                "comment": " Interpret visualization width to be for the entire visualization (data\nrectangle is shrunk to accommodate external padding).\n",
                "type": "VegaLite.Autosize"
            },
            {
                "name": "asResize",
                "comment": " Recalculate autosizing on every view update.\n",
                "type": "VegaLite.Autosize"
            },
            {
                "name": "asSpec",
                "comment": " Create a specification sufficient to define an element in a composed visualization\nsuch as a superposed layer or juxtaposed facet. Typically a layer will contain a\nfull set of specifications that define a visualization with the exception of the\ndata specification which is usually defined outside of any one\nlayer. For repeated and faceted specs, the entire specification is provided.\n",
                "type": "List.List ( VegaLite.VLProperty, VegaLite.Spec ) -> VegaLite.Spec"
            },
            {
                "name": "autosize",
                "comment": " Declare the way the view is sized. See the\n[Vega-Lite autosize documentation](https://vega.github.io/vega-lite/docs/size.html#autosize).\n\n    enc = ...\n    toVegaLite\n        [ width 250\n        , height 300\n        , autosize [ asFit, asPadding, asResize ]\n        , dataFromUrl \"data/population.json\" []\n        , bar []\n        , enc []\n        ]\n\n",
                "type": "List.List VegaLite.Autosize -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "axAria",
                "comment": " [ARIA](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA) properties\nfor providing accessible SVG output associated with an axis. If an empty list is\nprovided, ARIA tagging will be switched off.\n",
                "type": "List.List VegaLite.Aria -> VegaLite.AxisProperty"
            },
            {
                "name": "axBandPosition",
                "comment": " Position of axis tick relative to a band (0 to 1).\n",
                "type": "Basics.Float -> VegaLite.AxisProperty"
            },
            {
                "name": "axBooExpr",
                "comment": " Provide an [expression](https://vega.github.io/vega/docs/expressions/) to an\naxis property function requiring a Boolean value. This can be used to provide an\ninteractive parameterisation of an axis property when an expression is bound to\nan input element. For example,\n\n    ps =\n        params\n            << param \"lbls\"\n                [ paValue (boo True)\n                , paBind (ipCheckbox [])\n                ]\n\n    enc =\n        encoding\n            << position X\n                [ pName \"x\"\n                , pAxis [ axBooExpr \"lbls\" axLabels ]\n                ]\n\n",
                "type": "String.String -> (Basics.Bool -> VegaLite.AxisProperty) -> VegaLite.AxisProperty"
            },
            {
                "name": "axDataCondition",
                "comment": " Make an axis property (tick, grid or label) conditional on one or more predicate\nexpressions. The first parameter is the test to apply. The second is a pair of properties\nto set if the test evaluates to true or false.\n\nThe test parameter has access to the axis properties `value` and `label` corresponding\nto the value associated with an individual axis element and its text label. These\nshould be used rather than the underlying data field when referencing a data value.\n\n     pAxis\n        [ axDataCondition (expr \"datum.value <= 2\")\n            (cAxTickColor \"red\" \"blue\")\n        , axDataCondition (expr \"datum.label =='4.0'\")\n            (cAxTickWidth 5 2)\n        ]\n\nYou can also apply inline aggregation before applying the test using\n[fiOpTrans](#fiOpTrans), which can be particularly useful for filtering temporal\ndata. For example, the following will apply solid grid lines for January 1st of\neach year and dashes for all other dates:\n\n    pAxis\n        [ axDataCondition\n            (fiEqual \"value\" (dt [ dtMonth Jan, dtDate 1 ])\n                |> fiOpTrans (mTimeUnit monthDate)\n            )\n            (cAxGridDash [] [ 2, 2 ])\n        ]\n\n",
                "type": "VegaLite.BooleanOp -> VegaLite.ConditionalAxisProperty -> VegaLite.AxisProperty"
            },
            {
                "name": "axDomain",
                "comment": " Whether or not an axis baseline (domain) should be included as part of an axis.\n",
                "type": "Basics.Bool -> VegaLite.AxisProperty"
            },
            {
                "name": "axDomainCap",
                "comment": " How the ends of the axis baseline (domain) are capped.\n",
                "type": "VegaLite.StrokeCap -> VegaLite.AxisProperty"
            },
            {
                "name": "axDomainColor",
                "comment": " Color of axis domain line.\n",
                "type": "String.String -> VegaLite.AxisProperty"
            },
            {
                "name": "axDomainDash",
                "comment": " Dash style of axis baseline (domain). The parameter should list number of pixels\nin alternating dash and gap lengths.\n",
                "type": "List.List Basics.Float -> VegaLite.AxisProperty"
            },
            {
                "name": "axDomainDashOffset",
                "comment": " Number of pixels before the first axis baseline (domain) line dash is drawn.\n",
                "type": "Basics.Float -> VegaLite.AxisProperty"
            },
            {
                "name": "axDomainOpacity",
                "comment": " Opacity of axis domain line.\n",
                "type": "Basics.Float -> VegaLite.AxisProperty"
            },
            {
                "name": "axDomainWidth",
                "comment": " Width of axis domain line.\n",
                "type": "Basics.Float -> VegaLite.AxisProperty"
            },
            {
                "name": "axFormat",
                "comment": " [Formatting pattern](https://vega.github.io/vega-lite/docs/format.html) for\naxis labels. To distinguish between formatting as numeric values and data/time values,\nadditionally use [axFormatAsNum](#axFormatAsNum), [axFormatAsTemporal](#axFormatAsTemporal)\nor [axFormatAsCustom](#axFormatAsCustom).\n",
                "type": "String.String -> VegaLite.AxisProperty"
            },
            {
                "name": "axFormatAsCustom",
                "comment": " Indicate that axis labels should be formatted with a registered custom formatter\nwith the given name. See [how to register a Vega-Lite custom formatter](https://vega.github.io/vega-lite/usage/compile.html#format-type).\n",
                "type": "String.String -> VegaLite.AxisProperty"
            },
            {
                "name": "axFormatAsNum",
                "comment": " Indicate that axis labels should be formatted as numbers. To control the precise\nnumeric format, additionally use [axFormat](#axFormat) providing a\n[d3 numeric format string](https://github.com/d3/d3-format#locale_format).\n",
                "type": "VegaLite.AxisProperty"
            },
            {
                "name": "axFormatAsTemporal",
                "comment": " Indicate that axis labels should be formatted as dates/times. To control the\nprecise temporal format, additionally use [axFormat](#axFormat) providing a\n[d3 date/time format string](https://github.com/d3/d3-time-format#locale_format).\n",
                "type": "VegaLite.AxisProperty"
            },
            {
                "name": "axGrid",
                "comment": " Whether or not grid lines should be included as part of an axis.\n",
                "type": "Basics.Bool -> VegaLite.AxisProperty"
            },
            {
                "name": "axGridCap",
                "comment": " How the ends of gridlines are capped.\n",
                "type": "VegaLite.StrokeCap -> VegaLite.AxisProperty"
            },
            {
                "name": "axGridColor",
                "comment": " Color of grid lines associated with an axis.\n",
                "type": "String.String -> VegaLite.AxisProperty"
            },
            {
                "name": "axGridDash",
                "comment": " Axis grid lines dash style. The parameter is a list of alternating 'on' and\n'off' lengths in pixels representing the dashed line.\n",
                "type": "List.List Basics.Float -> VegaLite.AxisProperty"
            },
            {
                "name": "axGridDashOffset",
                "comment": " Default number of pixels before the first axis grid line dash is drawn.\n",
                "type": "Basics.Float -> VegaLite.AxisProperty"
            },
            {
                "name": "axGridOpacity",
                "comment": " Opacity of grid lines associated with an axis.\n",
                "type": "Basics.Float -> VegaLite.AxisProperty"
            },
            {
                "name": "axGridWidth",
                "comment": " Width of grid lines associated with an axis.\n",
                "type": "Basics.Float -> VegaLite.AxisProperty"
            },
            {
                "name": "axLabelAlign",
                "comment": " Horizontal alignment of axis tick labels.\n",
                "type": "VegaLite.HAlign -> VegaLite.AxisProperty"
            },
            {
                "name": "axLabelAngle",
                "comment": " Rotation angle of axis labels (degrees from horizontal).\n",
                "type": "Basics.Float -> VegaLite.AxisProperty"
            },
            {
                "name": "axLabelBaseline",
                "comment": " Vertical alignment of axis tick labels.\n",
                "type": "VegaLite.VAlign -> VegaLite.AxisProperty"
            },
            {
                "name": "axLabelBound",
                "comment": " How or if labels should be hidden if they exceed the axis range. If\n`Nothing`, no check for label size is made. A number specifies the permitted\noverflow in pixels.\n",
                "type": "Maybe.Maybe Basics.Float -> VegaLite.AxisProperty"
            },
            {
                "name": "axLabelBoundExpr",
                "comment": " Expression that evaluates to True, False or a number depending whether a check\nis to be made for an axis label size. A number specifies the permitted overflow\nin pixels.\n",
                "type": "String.String -> VegaLite.AxisProperty"
            },
            {
                "name": "axLabelColor",
                "comment": " Color of axis tick label.\n",
                "type": "String.String -> VegaLite.AxisProperty"
            },
            {
                "name": "axLabelExpr",
                "comment": " An expression to generate axis labels. The parameter is a valid\n[Vega expression](https://vega.github.io/vega/docs/expressions/). Can reference\n`datum.value` and `datum.label` for access to the underlying data values and\ndefault label text respectively. For example, to provide 4 digit years every decade\nand 2-digit years for all other tick marks:\n\n    pAxis\n        [ axLabelExpr \"if(year(datum.value) % 10 == 0\"\n            ++ \", utcFormat(datum.value,'%Y')\"\n            ++ \", utcFormat(datum.value,'%y'))\"\n        ]\n\n",
                "type": "String.String -> VegaLite.AxisProperty"
            },
            {
                "name": "axLabelFlush",
                "comment": " How or if labels at beginning and end of the axis should be aligned. Specifies\nthe distance threshold from an end-point within which labels are flush-adjusted\nor if `Nothing`, no flush-adjustment made.\n",
                "type": "Maybe.Maybe Basics.Float -> VegaLite.AxisProperty"
            },
            {
                "name": "axLabelFlushOffset",
                "comment": " Number of pixels by which to offset flush-adjusted labels.\n",
                "type": "Basics.Float -> VegaLite.AxisProperty"
            },
            {
                "name": "axLabelFont",
                "comment": " Font name of an axis label.\n",
                "type": "String.String -> VegaLite.AxisProperty"
            },
            {
                "name": "axLabelFontSize",
                "comment": " Font size of an axis label.\n",
                "type": "Basics.Float -> VegaLite.AxisProperty"
            },
            {
                "name": "axLabelFontStyle",
                "comment": " Font style of an axis label (e.g. \"italic\")\n",
                "type": "String.String -> VegaLite.AxisProperty"
            },
            {
                "name": "axLabelFontWeight",
                "comment": " Font weight of an axis label.\n",
                "type": "VegaLite.FontWeight -> VegaLite.AxisProperty"
            },
            {
                "name": "axLabelLimit",
                "comment": " Maximum length in pixels of axis tick labels.\n",
                "type": "Basics.Float -> VegaLite.AxisProperty"
            },
            {
                "name": "axLabelLineHeight",
                "comment": " Axis label line height (useful for multi-line labels).\n",
                "type": "Basics.Float -> VegaLite.AxisProperty"
            },
            {
                "name": "axLabelOffset",
                "comment": " Offset in pixels of an axis's labels relative to its ticks.\n",
                "type": "Basics.Float -> VegaLite.AxisProperty"
            },
            {
                "name": "axLabelOpacity",
                "comment": " Opacity of an axis label.\n",
                "type": "Basics.Float -> VegaLite.AxisProperty"
            },
            {
                "name": "axLabelOverlap",
                "comment": " Overlap strategy for labels when they are too large to fit within the space\ndevoted to an axis.\n",
                "type": "VegaLite.OverlapStrategy -> VegaLite.AxisProperty"
            },
            {
                "name": "axLabelPadding",
                "comment": " Padding in pixels between an axis and its text labels.\n",
                "type": "Basics.Float -> VegaLite.AxisProperty"
            },
            {
                "name": "axLabelSeparation",
                "comment": " The minimum separation between labels (in pixel units) before they are considered\nnon-overlapping. Ignored if [axLabelOverlap](#axLabelOverlap) is [osNone](#osNone).\n",
                "type": "Basics.Float -> VegaLite.AxisProperty"
            },
            {
                "name": "axLabels",
                "comment": " Whether or not axis labels should be displayed.\n",
                "type": "Basics.Bool -> VegaLite.AxisProperty"
            },
            {
                "name": "axMaxExtent",
                "comment": " Maximum extent in pixels that axis ticks and labels should use.\n",
                "type": "Basics.Float -> VegaLite.AxisProperty"
            },
            {
                "name": "axMinExtent",
                "comment": " Minimum extent in pixels that axis ticks and labels should use.\n",
                "type": "Basics.Float -> VegaLite.AxisProperty"
            },
            {
                "name": "axNumExpr",
                "comment": " Provide an [expression](https://vega.github.io/vega/docs/expressions/) to an\naxis property function requiring a numeric value. This can be used for interactive\nparameterisation when an expression is bound to an input element. For example,\n\n    ps =\n        params\n            << param \"axo\"\n                [ paValue (num 0)\n                , paBind (ipRange [ inMax 20 ])\n                ]\n\n    enc =\n        encoding\n            << position X\n                [ pName \"x\"\n                , pAxis [ axNumExpr \"axo\" axOffset ]\n                ]\n\n",
                "type": "String.String -> (number -> VegaLite.AxisProperty) -> VegaLite.AxisProperty"
            },
            {
                "name": "axNumsExpr",
                "comment": " Provide an [expression](https://vega.github.io/vega/docs/expressions/) to\nan axis property function requiring a list of numbers (for dash styles). This can\nbe used to provide an interactive parameterisation of an axis dash property when\nan expression is bound to an input element. For example,\n\n    ps =\n        params\n            << param \"gridDash\"\n                [ paValue (nums [ 2, 2 ])\n                , paBind (ipSelect [ inDataOptions [ nums [ 2, 2 ], nums [ 8, 8 ] ] ])\n                ]\n\n    enc =\n        encoding\n            << position X [ pAxis [ axNumsExpr \"gridDash\" axGridDash ] ]\n\n",
                "type": "String.String -> (List.List number -> VegaLite.AxisProperty) -> VegaLite.AxisProperty"
            },
            {
                "name": "axOffset",
                "comment": " Offset to displace the axis from the edge of the enclosing group or data rectangle.\n",
                "type": "Basics.Float -> VegaLite.AxisProperty"
            },
            {
                "name": "axOrient",
                "comment": " Orientation of an axis relative to the plot it is describing.\n",
                "type": "VegaLite.Side -> VegaLite.AxisProperty"
            },
            {
                "name": "axPosition",
                "comment": " Anchor position of the axis in pixels. For x-axis with top or\nbottom orientation, this sets the axis group x coordinate. For y-axis with left\nor right orientation, this sets the axis group y coordinate.\n",
                "type": "Basics.Float -> VegaLite.AxisProperty"
            },
            {
                "name": "axStrExpr",
                "comment": " Provide an [expression](https://vega.github.io/vega/docs/expressions/) to\nan axis property function requiring a string value. This can be used to provide an\ninteractive parameterisation of an axis property when an expression is bound to an\ninput element. For example,\n\n    ps =\n        params\n            << param \"color\"\n                [ paValue (str \"black\")\n                , paBind (ipColor [])\n                ]\n\n    enc =\n        encoding\n            << position X\n                [ pName \"x\"\n                , pAxis [ axStrExpr \"color\" axTitleColor ]\n                ]\n\n",
                "type": "String.String -> (String.String -> VegaLite.AxisProperty) -> VegaLite.AxisProperty"
            },
            {
                "name": "axStyle",
                "comment": " A list of named styles to apply to an axis. Named styles can be specified via\n[coAxisStyles](#coAxisStyles). Later styles in the list will override earlier\nstyles if there is a conflict in any of the properties specified.\n\nWhile this is provided for compatibility with Vega-Lite style specification, for\ngreater type safety in elm-vegalite, instead create functions that generate\n[AxisProperties](#AxisProperty).\n\n",
                "type": "List.List String.String -> VegaLite.AxisProperty"
            },
            {
                "name": "axTickBand",
                "comment": " Where grid and ticks should be aligned with bands.\n",
                "type": "VegaLite.TickBand -> VegaLite.AxisProperty"
            },
            {
                "name": "axTickCap",
                "comment": " How the ends of axis ticks are capped.\n",
                "type": "VegaLite.StrokeCap -> VegaLite.AxisProperty"
            },
            {
                "name": "axTickColor",
                "comment": " Color of axis ticks.\n",
                "type": "String.String -> VegaLite.AxisProperty"
            },
            {
                "name": "axTickCount",
                "comment": " Desired number of, or interval between, axis ticks. The resulting number of\nticks may be different so that values are “nice” (multiples of 2, 5, 10).\n",
                "type": "VegaLite.ScaleNice -> VegaLite.AxisProperty"
            },
            {
                "name": "axTickDash",
                "comment": " Axis tick dash style. The parameter is a list of alternating 'on' and 'off'\nlengths in pixels representing the dashed line.\n",
                "type": "List.List Basics.Float -> VegaLite.AxisProperty"
            },
            {
                "name": "axTickDashOffset",
                "comment": " Number of pixels before the first axis tick dash is drawn.\n",
                "type": "Basics.Float -> VegaLite.AxisProperty"
            },
            {
                "name": "axTickExtra",
                "comment": " Whether or not an extra axis tick should be added for the initial position\nof an axis.\n",
                "type": "Basics.Bool -> VegaLite.AxisProperty"
            },
            {
                "name": "axTickMinStep",
                "comment": " The minimum desired step between axis ticks, in terms of scale domain values.\nFor example, a value of `1` indicates that ticks should not be less than 1 unit\napart. If specified, the tick count value will be adjusted, if necessary, to\nenforce the minimum step value.\n",
                "type": "Basics.Float -> VegaLite.AxisProperty"
            },
            {
                "name": "axTickOffset",
                "comment": " Offset in pixels of an axis's ticks, labels and gridlines.\n",
                "type": "Basics.Float -> VegaLite.AxisProperty"
            },
            {
                "name": "axTickOpacity",
                "comment": " Opacity of axis ticks.\n",
                "type": "Basics.Float -> VegaLite.AxisProperty"
            },
            {
                "name": "axTickRound",
                "comment": " Whether or not axis tick positions should be rounded to nearest integer.\n",
                "type": "Basics.Bool -> VegaLite.AxisProperty"
            },
            {
                "name": "axTickSize",
                "comment": " Tick mark size in pixels.\n",
                "type": "Basics.Float -> VegaLite.AxisProperty"
            },
            {
                "name": "axTickWidth",
                "comment": " Width of axis ticks.\n",
                "type": "Basics.Float -> VegaLite.AxisProperty"
            },
            {
                "name": "axTicks",
                "comment": " Whether or not an axis should include tick marks.\n",
                "type": "Basics.Bool -> VegaLite.AxisProperty"
            },
            {
                "name": "axTitle",
                "comment": " Title to display as part of an axis. An empty string can be used to prevent\na title being displayed. For multi-line titles, insert `\\n` at each line break or\nuse a `\"\"\"` multi-line string.\n",
                "type": "String.String -> VegaLite.AxisProperty"
            },
            {
                "name": "axTitleAlign",
                "comment": " Horizontal alignment of an axis title.\n",
                "type": "VegaLite.HAlign -> VegaLite.AxisProperty"
            },
            {
                "name": "axTitleAnchor",
                "comment": " Anchor position of an axis title.\n",
                "type": "VegaLite.Anchor -> VegaLite.AxisProperty"
            },
            {
                "name": "axTitleAngle",
                "comment": " Angle of an axis title (degrees from horizontal).\n",
                "type": "Basics.Float -> VegaLite.AxisProperty"
            },
            {
                "name": "axTitleBaseline",
                "comment": " Vertical alignment of axis title.\n",
                "type": "VegaLite.VAlign -> VegaLite.AxisProperty"
            },
            {
                "name": "axTitleColor",
                "comment": " Color of axis title.\n",
                "type": "String.String -> VegaLite.AxisProperty"
            },
            {
                "name": "axTitleFont",
                "comment": " Font name for an axis title.\n",
                "type": "String.String -> VegaLite.AxisProperty"
            },
            {
                "name": "axTitleFontSize",
                "comment": " Font size of an axis title.\n",
                "type": "Basics.Float -> VegaLite.AxisProperty"
            },
            {
                "name": "axTitleFontStyle",
                "comment": " Font style of an axis title (e.g. \"italic\").\n",
                "type": "String.String -> VegaLite.AxisProperty"
            },
            {
                "name": "axTitleFontWeight",
                "comment": " Font weight of an axis title.\n",
                "type": "VegaLite.FontWeight -> VegaLite.AxisProperty"
            },
            {
                "name": "axTitleLimit",
                "comment": " Maximum length in pixels of axis title.\n",
                "type": "Basics.Float -> VegaLite.AxisProperty"
            },
            {
                "name": "axTitleLineHeight",
                "comment": " Line height for multi-line axis titles.\n",
                "type": "Basics.Float -> VegaLite.AxisProperty"
            },
            {
                "name": "axTitleOpacity",
                "comment": " Opacity of an axis title.\n",
                "type": "Basics.Float -> VegaLite.AxisProperty"
            },
            {
                "name": "axTitlePadding",
                "comment": " Padding in pixels between a title and axis.\n",
                "type": "Basics.Float -> VegaLite.AxisProperty"
            },
            {
                "name": "axTitleX",
                "comment": " X position of an axis title relative to the axis group.\n",
                "type": "Basics.Float -> VegaLite.AxisProperty"
            },
            {
                "name": "axTitleY",
                "comment": " Y position of an axis title relative to the axis group.\n",
                "type": "Basics.Float -> VegaLite.AxisProperty"
            },
            {
                "name": "axTranslate",
                "comment": " Coordinate space translation offset for axis layout. By default, axes are translated\nby 0.5 pixels for both the x and y coordinates in order to align stroked lines with\nthe pixel grid. This translation can be changed, for example, to zero.\n",
                "type": "Basics.Float -> VegaLite.AxisProperty"
            },
            {
                "name": "axValues",
                "comment": " Set explicit tick/grid/label values along an axis. For example, for a\nquantitative field:\n\n    pAxis [ axValues (nums [ 2, 3, 5, 7, 11, 13, 17 ]) ]\n\nor a categorical field:\n\n    pAxis [ axValues (strs [ \"cats\", \"dogs\", \"parrots\" ]) ]\n\nor for a temporal field:\n\n    pAxis\n        [ axValues\n            (dts\n                [ [ dtYear 2019, dtMonth Mar, dtDate 31 ]\n                , [ dtYear 2019, dtMonth Jun, dtDate 30 ]\n                , [ dtYear 2019, dtMonth Sep, dtDate 30 ]\n                , [ dtYear 2019, dtMonth Dec, dtDate 31 ]\n                ]\n            )\n        ]\n\n",
                "type": "VegaLite.DataValues -> VegaLite.AxisProperty"
            },
            {
                "name": "axX",
                "comment": " Indicate configuration should be applied to the x-axis only.\n",
                "type": "VegaLite.AxisChoice"
            },
            {
                "name": "axY",
                "comment": " Indicate configuration should be applied to the y-axis only.\n",
                "type": "VegaLite.AxisChoice"
            },
            {
                "name": "axZIndex",
                "comment": " Drawing order of the axis and its associated features (grid lines, ticks etc.)\nrelative to the other chart elements. A value greater than 0 indicates axis is\ndrawn in front of chart marks, 0 indicates it is drawn behind them. The z-order\nof intersecting grid lines associated with x- and y- axes can be controlled by\nassigning a higher z-value to the axis to appear on top.\n",
                "type": "Basics.Int -> VegaLite.AxisProperty"
            },
            {
                "name": "axcoAria",
                "comment": " Default [ARIA](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA)\nproperties for providing accessible SVG output associated with an axis. If an empty\nlist is provided, ARIA tagging will be switched off.\n",
                "type": "List.List VegaLite.Aria -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoBandPosition",
                "comment": " Default axis band position.\n",
                "type": "Basics.Float -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoBooExpr",
                "comment": " Provide an [expression](https://vega.github.io/vega/docs/expressions/) to an\naxis configuration function requiring a Boolean value.\n",
                "type": "String.String -> (Basics.Bool -> VegaLite.AxisConfig) -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoDisable",
                "comment": " Whether or not axes are generated for positional encoding by default.\n",
                "type": "Basics.Bool -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoDomain",
                "comment": " Whether or not an axis domain should be displayed by default.\n",
                "type": "Basics.Bool -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoDomainCap",
                "comment": " Default appearance of ends of axis domain.\n",
                "type": "VegaLite.StrokeCap -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoDomainColor",
                "comment": " Default axis domain color.\n",
                "type": "String.String -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoDomainDash",
                "comment": " Default dash style of axis baseline (domain). The parameter should list\nnumber of pixels in alternating dash and gap lengths.\n",
                "type": "List.List Basics.Float -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoDomainDashOffset",
                "comment": " Default number of pixels before the first axis baseline (domain) line dash is drawn.\n",
                "type": "Basics.Float -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoDomainOpacity",
                "comment": " Default axis domain opacity.\n",
                "type": "Basics.Float -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoDomainWidth",
                "comment": " Default axis domain width style.\n",
                "type": "Basics.Float -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoGrid",
                "comment": " Whether or not an axis grid is displayed by default.\n",
                "type": "Basics.Bool -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoGridCap",
                "comment": " Default appearance of ends of grid lines.\n",
                "type": "VegaLite.StrokeCap -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoGridColor",
                "comment": " Default axis grid color style.\n",
                "type": "String.String -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoGridDash",
                "comment": " Default axis line dash style.\n",
                "type": "List.List Basics.Float -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoGridDashOffset",
                "comment": " Default number of pixels before the first axis grid line dash is drawn.\n",
                "type": "Basics.Float -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoGridOpacity",
                "comment": " Default axis grid line opacity.\n",
                "type": "Basics.Float -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoGridWidth",
                "comment": " Default axis grid line width.\n",
                "type": "Basics.Float -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoLabelAlign",
                "comment": " Default axis label horizontal alignment.\n",
                "type": "VegaLite.HAlign -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoLabelAngle",
                "comment": " Default axis label angle (degrees from horizontal).\n",
                "type": "Basics.Float -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoLabelBaseline",
                "comment": " Default axis label vertical alignment.\n",
                "type": "VegaLite.VAlign -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoLabelBound",
                "comment": " Default axis label bounding when label exceeds available space. If `Nothing`,\nno check for label size is made. A number specifies the permitted overflow in pixels.\n",
                "type": "Maybe.Maybe Basics.Float -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoLabelBoundExpr",
                "comment": " Expression that evaluates to `True`, `False` or a number depending whether,\nby default, a check is to be made for an axis label size. A number specifies the\npermitted overflow in pixels.\n",
                "type": "String.String -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoLabelColor",
                "comment": " Default axis label color.\n",
                "type": "String.String -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoLabelExpr",
                "comment": " Default expression to generate axis labels. The parameter is a valid\n[Vega expression](https://vega.github.io/vega/docs/expressions/). Can reference\n`datum.value` and `datum.label` for access to the underlying data values and\ndefault label text respectively.\n",
                "type": "String.String -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoLabelFlush",
                "comment": " Default label alignment at beginning or end of the axis. Specifies the distance\nthreshold from an end-point within which labels are flush-adjusted or if `Nothing`,\nno flush-adjustment made.\n",
                "type": "Maybe.Maybe Basics.Float -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoLabelFlushOffset",
                "comment": " Default number of pixels by which to offset flush-adjusted labels.\n",
                "type": "Basics.Float -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoLabelFont",
                "comment": " Default axis label font.\n",
                "type": "String.String -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoLabelFontSize",
                "comment": " Default axis label font size.\n",
                "type": "Basics.Float -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoLabelFontStyle",
                "comment": " Default axis label font style (e.g. \"italic\")\n",
                "type": "String.String -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoLabelFontWeight",
                "comment": " Default axis label font weight.\n",
                "type": "VegaLite.FontWeight -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoLabelLimit",
                "comment": " Default axis label limit (how much a label can extend beyond the\nleft/bottom or right/top of the axis line).\n",
                "type": "Basics.Float -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoLabelLineHeight",
                "comment": " Default axis label line height (useful for multi-line labels).\n",
                "type": "Basics.Float -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoLabelOffset",
                "comment": " Default axis offset in pixels of an axis's labels relative to its ticks.\n",
                "type": "Basics.Float -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoLabelOpacity",
                "comment": " Default axis label opacity.\n",
                "type": "Basics.Float -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoLabelOverlap",
                "comment": " Default axis label overlap strategy for cases where labels cannot\nfit within the allotted space.\n",
                "type": "VegaLite.OverlapStrategy -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoLabelPadding",
                "comment": " Default axis label padding (space between labels in pixels).\n",
                "type": "Basics.Float -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoLabelSeparation",
                "comment": " Default axis label separation (minimum spacing between axis labels).\n",
                "type": "Basics.Float -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoLabels",
                "comment": " Whether or not an axis has labels by default.\n",
                "type": "Basics.Bool -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoMaxExtent",
                "comment": " Default maximum extent style.\n",
                "type": "Basics.Float -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoMinExtent",
                "comment": " Default minimum extent style.\n",
                "type": "Basics.Float -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoNumExpr",
                "comment": " Provide an [expression](https://vega.github.io/vega/docs/expressions/) to an\naxis property configuration function requiring a numeric value.\n",
                "type": "String.String -> (number -> VegaLite.AxisConfig) -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoNumsExpr",
                "comment": " Provide an [expression](https://vega.github.io/vega/docs/expressions/) to\nan axis configuration function requiring a list of numbers (for dash styles).\n",
                "type": "String.String -> (List.List number -> VegaLite.AxisConfig) -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoOffset",
                "comment": " Default offset between the axis and the edge of the enclosing group or data\nrectangle.\n",
                "type": "Basics.Float -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoStrExpr",
                "comment": " Provide an [expression](https://vega.github.io/vega/docs/expressions/) to\nan axis property function requiring a string value. This can be used to provide an\ninteractive parameterisation of an axis property when an expression is bound to an\ninput element. For example,\n\n    ps =\n        params\n            << param \"color\"\n                [ paValue (str \"black\")\n                , paBind (ipColor [])\n                ]\n\n    enc =\n        encoding\n            << position X\n                [ pName \"x\"\n                , pAxis [ axStrExpr \"color\" axTitleColor ]\n                ]\n\n",
                "type": "String.String -> (String.String -> VegaLite.AxisConfig) -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoStyle",
                "comment": " A list of named styles to apply as defaults to axes.\n",
                "type": "List.List String.String -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoTickBand",
                "comment": " Default alignment of grid lines and ticks in band scales.\n",
                "type": "VegaLite.TickBand -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoTickCap",
                "comment": " Default axis tick end cap style.\n",
                "type": "VegaLite.StrokeCap -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoTickColor",
                "comment": " Default axis tick mark color.\n",
                "type": "String.String -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoTickCount",
                "comment": " Default number of, or interval between, axis ticks. The resulting number of\nticks may be different so that values are “nice” (multiples of 2, 5, 10).\n",
                "type": "VegaLite.ScaleNice -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoTickDash",
                "comment": " Default axis tick dash style. The parameter is a list of alternating 'on' and\n'off' lengths in pixels representing the dashed line.\n",
                "type": "List.List Basics.Float -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoTickDashOffset",
                "comment": " Default number of pixels before the first axis tick dash is drawn.\n",
                "type": "Basics.Float -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoTickExtra",
                "comment": " Whether or not by default an extra axis tick should be added for the initial\nposition of axes.\n",
                "type": "Basics.Bool -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoTickMinStep",
                "comment": " The minimum desired step between axis ticks, in terms of scale domain values.\nFor example, a value of `1` indicates that ticks should not be less than 1 unit\napart. If specified, the tick count\\` value will be adjusted, if necessary, to\nenforce the minimum step value.\n",
                "type": "Basics.Float -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoTickOffset",
                "comment": " Default offset in pixels of axis ticks, labels and gridlines.\n",
                "type": "Basics.Float -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoTickOpacity",
                "comment": " Default opacity of axis ticks.\n",
                "type": "Basics.Float -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoTickRound",
                "comment": " Whether or not axis tick labels use rounded values by default.\n",
                "type": "Basics.Bool -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoTickSize",
                "comment": " Default axis tick mark size.\n",
                "type": "Basics.Float -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoTickWidth",
                "comment": " Default axis tick mark width.\n",
                "type": "Basics.Float -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoTicks",
                "comment": " Whether or not an axis should show ticks by default.\n",
                "type": "Basics.Bool -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoTitleAlign",
                "comment": " Default axis tick label horizontal alignment.\n",
                "type": "VegaLite.HAlign -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoTitleAnchor",
                "comment": " Default anchor position of axis titles.\n",
                "type": "VegaLite.Anchor -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoTitleAngle",
                "comment": " Default axis title angle (degrees from horizontal).\n",
                "type": "Basics.Float -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoTitleBaseline",
                "comment": " Default axis title vertical alignment.\n",
                "type": "VegaLite.VAlign -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoTitleColor",
                "comment": " Default axis title color.\n",
                "type": "String.String -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoTitleFont",
                "comment": " Default axis title font.\n",
                "type": "String.String -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoTitleFontSize",
                "comment": " Default axis title font size.\n",
                "type": "Basics.Float -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoTitleFontStyle",
                "comment": " Default axis title font style (e.g. \"italic\").\n",
                "type": "String.String -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoTitleFontWeight",
                "comment": " Default axis title font weight.\n",
                "type": "VegaLite.FontWeight -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoTitleLimit",
                "comment": " Default axis title maximum size.\n",
                "type": "Basics.Float -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoTitleLineHeight",
                "comment": " Default line height for multi-line axis titles.\n",
                "type": "Basics.Float -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoTitleOpacity",
                "comment": " Default opacity of axis titles.\n",
                "type": "Basics.Float -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoTitlePadding",
                "comment": " Default axis title padding between axis line and text.\n",
                "type": "Basics.Float -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoTitleX",
                "comment": " Default axis x-position relative to the axis group.\n",
                "type": "Basics.Float -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoTitleY",
                "comment": " Default axis y-position relative to the axis group.\n",
                "type": "Basics.Float -> VegaLite.AxisConfig"
            },
            {
                "name": "axcoTranslate",
                "comment": " Default coordinate space translation offset for axis layout.\n",
                "type": "Basics.Float -> VegaLite.AxisConfig"
            },
            {
                "name": "azimuthalEqualArea",
                "comment": " An azimuthal equal area map projection.\n",
                "type": "VegaLite.Projection"
            },
            {
                "name": "azimuthalEquidistant",
                "comment": " An azimuthal equidistant map projection.\n",
                "type": "VegaLite.Projection"
            },
            {
                "name": "bParam",
                "comment": " Treat a parameter as a boolean expression that may be composed to form more\ncomplex boolean expressions. Can be used when composing selections from multiple\nparameters. For example, if we have two interval selection parameters `alex` and\n`morgan` we can conditionally colour if both selections intersect.\n\n    color\n        [ mCondition (prTest (and (bParam \"alex\") (bParam \"morgan\")))\n            [ mStr \"red\" ]\n            [ mStr \"gray\" ]\n        ]\n\n",
                "type": "String.String -> VegaLite.BooleanOp"
            },
            {
                "name": "background",
                "comment": " Background color of the entire visualization. For view compositions, single\nviews or layers can have their own background styles in addition to this global\nbackground color. Should be specified with a CSS string such as `#ffe` or\n`rgb(200,20,150)`. If not specified the background will be white.\n",
                "type": "String.String -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "backgroundExpr",
                "comment": " Expression that evaluates to a colour used for the visualization background.\nUseful when the colour is to be determined at runtime though an interaction element\nsuch as [ipColor](#ipColor).\n",
                "type": "String.String -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "bar",
                "comment": " [Bar mark](https://vega.github.io/vega-lite/docs/bar.html) for histograms,\nbar charts etc.\n",
                "type": "List.List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "biAnchor",
                "comment": " Value in the binned domain at which to anchor the binning. Boundaries are\npossibly shifted to ensure they align with the anchor value.\n",
                "type": "Basics.Float -> VegaLite.BinProperty"
            },
            {
                "name": "biBase",
                "comment": " Number base to use for automatic bin determination (default is base 10).\n",
                "type": "Basics.Float -> VegaLite.BinProperty"
            },
            {
                "name": "biDivide",
                "comment": " Scale factors indicating allowable subdivisions for binning. The default value\nis [5, 2], which indicates that for base 10 numbers (the default base), binning\nwill consider dividing bin sizes by 5 and/or 2.\n",
                "type": "List.List Basics.Float -> VegaLite.BinProperty"
            },
            {
                "name": "biExtent",
                "comment": " Desired extent of bin values when binning a collection of values.\nThe first and second parameters indicate the minimum and maximum extent.\nTo base a binning extent on an interactive selection, use\n[biSelectionExtent](#biSelectionExtent) instead.\n",
                "type": "Basics.Float -> Basics.Float -> VegaLite.BinProperty"
            },
            {
                "name": "biMaxBins",
                "comment": " Maximum number of bins when binning a collection of values.\n",
                "type": "Basics.Int -> VegaLite.BinProperty"
            },
            {
                "name": "biMinStep",
                "comment": " Step size between bins when binning a collection of values.\n",
                "type": "Basics.Float -> VegaLite.BinProperty"
            },
            {
                "name": "biNice",
                "comment": " Whether or not binning boundaries use human-friendly values such as multiples\nof ten.\n",
                "type": "Basics.Bool -> VegaLite.BinProperty"
            },
            {
                "name": "biSelectionExtent",
                "comment": " Set the desired range of bin values based on an interactive selection. The\nparameter should be the name of an interval selection parameter that defines the\nextent.\n\n    ps =\n        params\n            << param \"brush\" [ paSelect seInterval [ seEncodings [ chX ] ] ]\n\n    enc =\n        encoding\n            << position X\n                [ pName \"temperature\"\n                , pBin [ biSelectionExtent \"brush\" ]\n                ]\n\n",
                "type": "String.String -> VegaLite.BinProperty"
            },
            {
                "name": "biStep",
                "comment": " Step size between bins when binning a collection of values.\n",
                "type": "Basics.Float -> VegaLite.BinProperty"
            },
            {
                "name": "biSteps",
                "comment": " Allowable step sizes between bins when binning a collection of values.\n",
                "type": "List.List Basics.Float -> VegaLite.BinProperty"
            },
            {
                "name": "binAs",
                "comment": " Binning transformation that may be referenced in other transformations or\nencodings. The first parameter is a list of customisation options ([biBase](#biBase),\n[biDivide](#biDivide) etc.) or an empty list to use the default binning. The second\nis the field to bin and the third the name to give the output binned data.\n\n    trans =\n        transform\n            << binAs [ biMaxBins 3 ] \"IMDB_Rating\" \"ratingGroup\"\n\nNote that usually, direct binning within an encoding is preferred over this form\nof bin transformation.\n\n",
                "type": "List.List VegaLite.BinProperty -> String.String -> String.String -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"
            },
            {
                "name": "bmColor",
                "comment": " Color blend mode to be applied when drawing over some background.\n",
                "type": "VegaLite.BlendMode"
            },
            {
                "name": "bmColorBurn",
                "comment": " Color burn blend mode to be applied when drawing over some background.\n",
                "type": "VegaLite.BlendMode"
            },
            {
                "name": "bmColorDodge",
                "comment": " Color dodge blend mode to be applied when drawing over some background.\n",
                "type": "VegaLite.BlendMode"
            },
            {
                "name": "bmDarken",
                "comment": " Darken blend mode to be applied when drawing over some background.\n",
                "type": "VegaLite.BlendMode"
            },
            {
                "name": "bmDifference",
                "comment": " Difference blend mode to be applied when drawing over some background.\n",
                "type": "VegaLite.BlendMode"
            },
            {
                "name": "bmExclusion",
                "comment": " Exclusion blend mode to be applied when drawing over some background.\n",
                "type": "VegaLite.BlendMode"
            },
            {
                "name": "bmExpr",
                "comment": " Expression that evaluates to some blend mode such as \"darken\", \"hue\" or\n\"luminosity\".\n",
                "type": "String.String -> VegaLite.BlendMode"
            },
            {
                "name": "bmHardLight",
                "comment": " Hard light blend mode to be applied when drawing over some background.\n",
                "type": "VegaLite.BlendMode"
            },
            {
                "name": "bmHue",
                "comment": " Hue blend mode to be applied when drawing over some background.\n",
                "type": "VegaLite.BlendMode"
            },
            {
                "name": "bmLighten",
                "comment": " Lighten blend mode to be applied when drawing over some background.\n",
                "type": "VegaLite.BlendMode"
            },
            {
                "name": "bmLuminosity",
                "comment": " Luminosity blend mode to be applied when drawing over some background.\n",
                "type": "VegaLite.BlendMode"
            },
            {
                "name": "bmMultiply",
                "comment": " Multiplicative blend mode to be applied when drawing over some background.\n",
                "type": "VegaLite.BlendMode"
            },
            {
                "name": "bmNormal",
                "comment": " Indicate the default blend mode should be applied when drawing over some background.\n",
                "type": "VegaLite.BlendMode"
            },
            {
                "name": "bmOverlay",
                "comment": " Overlay blend mode to be applied when drawing over some background.\n",
                "type": "VegaLite.BlendMode"
            },
            {
                "name": "bmSaturation",
                "comment": " Saturation blend mode to be applied when drawing over some background.\n",
                "type": "VegaLite.BlendMode"
            },
            {
                "name": "bmScreen",
                "comment": " Screen blend mode to be applied when drawing over some background.\n",
                "type": "VegaLite.BlendMode"
            },
            {
                "name": "bmSoftLight",
                "comment": " Soft light blend mode to be applied when drawing over some background.\n",
                "type": "VegaLite.BlendMode"
            },
            {
                "name": "boFlush",
                "comment": " Bounds calculation should take only the specified width and height values for\na sub-view. Useful when attempting to place sub-plots without axes or legends into\na uniform grid structure.\n",
                "type": "VegaLite.Bounds"
            },
            {
                "name": "boFull",
                "comment": " Bounds calculation should use the entire plot area (including axes, title,\nand legend).\n",
                "type": "VegaLite.Bounds"
            },
            {
                "name": "boo",
                "comment": " A Boolean data value.\n",
                "type": "Basics.Bool -> VegaLite.DataValue"
            },
            {
                "name": "boos",
                "comment": " A list of Boolean data values. Used when declaring inline data with\n[dataColumn](#dataColumn), filtering ([fiOneOf](#fiOneOf)), imputation\n([imKeyVals](#imKeyVals)) and customised sorting ([soCustom](#soCustom)).\n",
                "type": "List.List Basics.Bool -> VegaLite.DataValues"
            },
            {
                "name": "bounds",
                "comment": " Bounds calculation method to use for determining the extent of a sub-plot in\na composed view. If set to `Full` the entire calculated bounds including axes,\ntitle and legend are used; if `Flush` only the width and height values for the\nsub-view will be used.\n",
                "type": "VegaLite.Bounds -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "boxplot",
                "comment": " [Boxplot composite mark](https://vega.github.io/vega-lite/docs/boxplot.html)\nfor showing summaries of statistical distributions. By default, just box and whiskers\nare shown, but ticks and outliers can be specified explicitly.\n\n    boxplot\n        [ maTicks [ maColor \"black\", maSize 8 ]\n        , maBox [ maFill \"grey\" ]\n        , maOutliers [ maColor \"firebrick\" ]\n        ]\n\n",
                "type": "List.List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "cAxGridColor",
                "comment": " Conditional axis grid color. The first parameter provides the color when a\npredicate is true, the second when it is false.\n",
                "type": "String.String -> String.String -> VegaLite.ConditionalAxisProperty"
            },
            {
                "name": "cAxGridDash",
                "comment": " Conditional axis grid dash. The first parameter provides the dash when a\npredicate is true, the second when it is false.\n",
                "type": "List.List Basics.Float -> List.List Basics.Float -> VegaLite.ConditionalAxisProperty"
            },
            {
                "name": "cAxGridDashOffset",
                "comment": " Conditional axis grid dash offset. The first parameter provides the dash offset\nwhen a predicate is true, the second when it is false.\n",
                "type": "Basics.Float -> Basics.Float -> VegaLite.ConditionalAxisProperty"
            },
            {
                "name": "cAxGridOpacity",
                "comment": " Conditional axis grid opacity. The first parameter provides the opacity when\na predicate is true, the second when it is false.\n",
                "type": "Basics.Float -> Basics.Float -> VegaLite.ConditionalAxisProperty"
            },
            {
                "name": "cAxGridWidth",
                "comment": " Conditional axis grid width. The first parameter provides the width when a\npredicate is true, the second when it is false.\n",
                "type": "Basics.Float -> Basics.Float -> VegaLite.ConditionalAxisProperty"
            },
            {
                "name": "cAxLabelAlign",
                "comment": " Conditional axis label alignment. The first parameter provides the alignment\nwhen a predicate is true, the second when it is false.\n",
                "type": "VegaLite.HAlign -> VegaLite.HAlign -> VegaLite.ConditionalAxisProperty"
            },
            {
                "name": "cAxLabelBaseline",
                "comment": " Conditional axis vertical label alignment. The first parameter provides the\nalignment when a predicate is true, the second when it is false.\n",
                "type": "VegaLite.VAlign -> VegaLite.VAlign -> VegaLite.ConditionalAxisProperty"
            },
            {
                "name": "cAxLabelColor",
                "comment": " Conditional axis label color. The first parameter provides the color\nwhen a predicate is true, the second when it is false.\n",
                "type": "String.String -> String.String -> VegaLite.ConditionalAxisProperty"
            },
            {
                "name": "cAxLabelFont",
                "comment": " Conditional axis label font. The first parameter provides the font\nwhen a predicate is true, the second when it is false.\n",
                "type": "String.String -> String.String -> VegaLite.ConditionalAxisProperty"
            },
            {
                "name": "cAxLabelFontSize",
                "comment": " Conditional axis label font size. The first parameter provides the size\nwhen a predicate is true, the second when it is false.\n",
                "type": "Basics.Float -> Basics.Float -> VegaLite.ConditionalAxisProperty"
            },
            {
                "name": "cAxLabelFontStyle",
                "comment": " Conditional axis label font style. The first parameter provides the style\nwhen a predicate is true, the second when it is false.\n",
                "type": "String.String -> String.String -> VegaLite.ConditionalAxisProperty"
            },
            {
                "name": "cAxLabelFontWeight",
                "comment": " Conditional axis label font weight. The first parameter provides the weight\nwhen a predicate is true, the second when it is false.\n",
                "type": "VegaLite.FontWeight -> VegaLite.FontWeight -> VegaLite.ConditionalAxisProperty"
            },
            {
                "name": "cAxLabelOffset",
                "comment": " Conditional axis label offset. The first parameter provides the offset\nwhen a predicate is true, the second when it is false.\n",
                "type": "Basics.Float -> Basics.Float -> VegaLite.ConditionalAxisProperty"
            },
            {
                "name": "cAxLabelOpacity",
                "comment": " Conditional axis label opacity. The first parameter provides the opacity\nwhen a predicate is true, the second when it is false.\n",
                "type": "Basics.Float -> Basics.Float -> VegaLite.ConditionalAxisProperty"
            },
            {
                "name": "cAxLabelPadding",
                "comment": " Conditional axis label padding. The first parameter provides the padding\nwhen a predicate is true, the second when it is false.\n",
                "type": "Basics.Float -> Basics.Float -> VegaLite.ConditionalAxisProperty"
            },
            {
                "name": "cAxTickColor",
                "comment": " Conditional axis tick color. The first parameter provides the color when a\npredicate is true, the second when it is false.\n",
                "type": "String.String -> String.String -> VegaLite.ConditionalAxisProperty"
            },
            {
                "name": "cAxTickDash",
                "comment": " Conditional axis tick dash style. The first parameter is a list of alternating\n'on' and 'off' lengths in pixels representing the dashed line when a predicate\nis true, the second when it is false.\n",
                "type": "List.List Basics.Float -> List.List Basics.Float -> VegaLite.ConditionalAxisProperty"
            },
            {
                "name": "cAxTickDashOffset",
                "comment": " Conditional axis tick dash offset. The first parameter provides the dash offset\nwhen a predicate is true, the second when it is false.\n",
                "type": "Basics.Float -> Basics.Float -> VegaLite.ConditionalAxisProperty"
            },
            {
                "name": "cAxTickOpacity",
                "comment": " Conditional axis tick opacity. The first parameter provides the opacity when\na predicate is true, the second when it is false.\n",
                "type": "Basics.Float -> Basics.Float -> VegaLite.ConditionalAxisProperty"
            },
            {
                "name": "cAxTickSize",
                "comment": " Conditional axis tick size. The first parameter provides the size when a\npredicate is true, the second when it is false.\n",
                "type": "Basics.Float -> Basics.Float -> VegaLite.ConditionalAxisProperty"
            },
            {
                "name": "cAxTickWidth",
                "comment": " Conditional axis tick width. The first parameter provides the width when a\npredicate is true, the second when it is false.\n",
                "type": "Basics.Float -> Basics.Float -> VegaLite.ConditionalAxisProperty"
            },
            {
                "name": "caAll",
                "comment": " Subviews in a composed view to be aligned into a clean grid structure where\nall rows and columns are of the same size (based on maximum subview size).\n",
                "type": "VegaLite.CompositionAlignment"
            },
            {
                "name": "caButt",
                "comment": " Butt stroke cap.\n",
                "type": "VegaLite.StrokeCap"
            },
            {
                "name": "caEach",
                "comment": " Subviews in a composed view to be aligned into a clean grid structure where\neach row or column may be of variable size.\n",
                "type": "VegaLite.CompositionAlignment"
            },
            {
                "name": "caExpr",
                "comment": " Expression that evaluates to some stroke cap style such as \"square\", \"butt\" or \"round\".\n",
                "type": "String.String -> VegaLite.StrokeCap"
            },
            {
                "name": "caNone",
                "comment": " Flow layout is to be applied to composed views, in which adjacent subviews\nare placed one after the other.\n",
                "type": "VegaLite.CompositionAlignment"
            },
            {
                "name": "caRound",
                "comment": " Rounded stroke cap.\n",
                "type": "VegaLite.StrokeCap"
            },
            {
                "name": "caSquare",
                "comment": " Square stroke cap.\n",
                "type": "VegaLite.StrokeCap"
            },
            {
                "name": "calculateAs",
                "comment": " Generate a new data field based on some calculations from existing values and fields.\nThe first parameter is an [expression](https://vega.github.io/vega/docs/expressions/)\nrepresenting the calculation and the second is the name to give the newly calculated\nfield.\n\n    trans =\n        transform << calculateAs \"datum.sex == 2 ? 'F' : 'M'\" \"gender\"\n\n",
                "type": "String.String -> String.String -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"
            },
            {
                "name": "categoricalDomainMap",
                "comment": " Create a set of discrete domain to color mappings suitable for customising categorical\nscales. The first item in each tuple should be a domain value and the second the\ncolor value with which it should be associated. It is a convenience function equivalent\nto specifying separate `scDomain` and `scRange` lists and is safer as it guarantees\na one-to-one correspondence between domain and range values.\n\n    color\n        [ mName \"weather\"\n        , mNominal\n        , categoricalDomainMap\n            [ ( \"sun\", \"yellow\" )\n            , ( \"rain\", \"blue\" )\n            , ( \"fog\", \"grey\" )\n            ]\n            |> mScale\n        ]\n\n",
                "type": "List.List ( String.String, String.String ) -> List.List VegaLite.ScaleProperty"
            },
            {
                "name": "center",
                "comment": " Whether or not sub-views specified in a composition operator should be centred\nrelative to their respective rows and columns.\n",
                "type": "Basics.Bool -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "centerRC",
                "comment": " Similar to [center](#center) but with independent centring for rows and columns.\n",
                "type": "Basics.Bool -> Basics.Bool -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "chColor",
                "comment": " Reference to whatever is being encoded on the color channel. Can be\nused in the [projection of interactive selections](#seEncodings) or in a\n[resolution specification](#resolution).\n",
                "type": "VegaLite.Channel"
            },
            {
                "name": "chOpacity",
                "comment": " Reference to whatever is being encoded on the opacity channel. Can be\nused in the [projection of interactive selections](#seEncodings) or in a\n[resolution specification](#resolution).\n",
                "type": "VegaLite.Channel"
            },
            {
                "name": "chShape",
                "comment": " Reference to whatever is being encoded on the shape channel. Can be\nused in the [projection of interactive selections](#seEncodings) or in a\n[resolution specification](#resolution).\n",
                "type": "VegaLite.Channel"
            },
            {
                "name": "chSize",
                "comment": " Reference to whatever is being encoded on the size channel. Can be\nused in the [projection of interactive selections](#seEncodings) or in a\n[resolution specification](#resolution).\n",
                "type": "VegaLite.Channel"
            },
            {
                "name": "chStrokeDash",
                "comment": " Reference to whatever is being encoded on the stroke dash channel. Can be\nused in the [projection of interactive selections](#seEncodings) or in a\n[resolution specification](#resolution).\n",
                "type": "VegaLite.Channel"
            },
            {
                "name": "chX",
                "comment": " Reference to whatever is being encoded on the X channel. Can be used in the\n[projection of interactive selections](#seEncodings) or in a\n[resolution specification](#resolution).\n",
                "type": "VegaLite.Channel"
            },
            {
                "name": "chX2",
                "comment": " Reference to whatever is being encoded on the X2 channel. Can be used in a\n[resolution specification](#resolution).\n",
                "type": "VegaLite.Channel"
            },
            {
                "name": "chXOffset",
                "comment": " Reference to whatever is being encoded on the XOffset channel. Can be used\nin a [resolution specification](#resolution).\n",
                "type": "VegaLite.Channel"
            },
            {
                "name": "chY",
                "comment": " Reference to whatever is being encoded on the Y channel. Can be used in the\n[projection of interactive selections](#seEncodings) or in a\n[resolution specification](#resolution).\n",
                "type": "VegaLite.Channel"
            },
            {
                "name": "chY2",
                "comment": " Reference to whatever is being encoded on the Y2 channel. Can be used in a\n[resolution specification](#resolution).\n",
                "type": "VegaLite.Channel"
            },
            {
                "name": "chYOffset",
                "comment": " Reference to whatever is being encoded on the Y offset channel. Can be used in a\n[resolution specification](#resolution).\n",
                "type": "VegaLite.Channel"
            },
            {
                "name": "circle",
                "comment": " [Circle mark](https://vega.github.io/vega-lite/docs/circle.html) for\nsymbolising points. Unlike the [point](#point) mark, circles are filled by default\nand may be sized via a separate [size](#size) encoding.\n",
                "type": "List.List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "clipRect",
                "comment": " Clipping rectangle in pixel units. The four parameters are respectively\n'left', 'top', 'right' and 'bottom' of the rectangular clipping bounds.\n",
                "type": "Basics.Float -> Basics.Float -> Basics.Float -> Basics.Float -> VegaLite.ClipRect"
            },
            {
                "name": "clipRectExpr",
                "comment": " Expression that evaluates to the left, top, bottom, and right of a clipping\nrectangle in pixel coordinates.\n",
                "type": "String.String -> String.String -> String.String -> String.String -> VegaLite.ClipRect"
            },
            {
                "name": "coArea",
                "comment": " Configure the default appearance of area marks.\n",
                "type": "List.List VegaLite.MarkProperty -> VegaLite.ConfigurationProperty"
            },
            {
                "name": "coAria",
                "comment": " Whether or not [ARIA attributes](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA)\nshould be included for marks and guides when generating SVG output. If not specified,\nthe default is `True`.\n",
                "type": "Basics.Bool -> VegaLite.ConfigurationProperty"
            },
            {
                "name": "coAutosize",
                "comment": " Configure the default sizing of visualizations.\n",
                "type": "List.List VegaLite.Autosize -> VegaLite.ConfigurationProperty"
            },
            {
                "name": "coAxis",
                "comment": " Configure the default appearance of axes.\n",
                "type": "List.List VegaLite.AxisConfig -> VegaLite.ConfigurationProperty"
            },
            {
                "name": "coAxisBand",
                "comment": " Configure the default appearance of any axes using a band (binned) scale.\n",
                "type": "List.List VegaLite.AxisConfig -> VegaLite.ConfigurationProperty"
            },
            {
                "name": "coAxisBottom",
                "comment": " Configure the default appearance of bottom-side axes.\n",
                "type": "List.List VegaLite.AxisConfig -> VegaLite.ConfigurationProperty"
            },
            {
                "name": "coAxisDiscrete",
                "comment": " Configure the default appearance of any axes using a discrete scale.\n",
                "type": "List.List VegaLite.AxisConfig -> VegaLite.ConfigurationProperty"
            },
            {
                "name": "coAxisLeft",
                "comment": " Configure the default appearance of left-side axes.\n",
                "type": "List.List VegaLite.AxisConfig -> VegaLite.ConfigurationProperty"
            },
            {
                "name": "coAxisPoint",
                "comment": " Configure the default appearance of any axes using a point scale.\n",
                "type": "List.List VegaLite.AxisConfig -> VegaLite.ConfigurationProperty"
            },
            {
                "name": "coAxisQuant",
                "comment": " Configure the default appearance of any quantitative axes.\n",
                "type": "List.List VegaLite.AxisConfig -> VegaLite.ConfigurationProperty"
            },
            {
                "name": "coAxisRight",
                "comment": " Configure the default appearance of right-side axes.\n",
                "type": "List.List VegaLite.AxisConfig -> VegaLite.ConfigurationProperty"
            },
            {
                "name": "coAxisStyles",
                "comment": " Specify a list of named styles that each define a list of axis properties.\nProvided for compatibility with Vega-Lite, but generally greater type safety is\nachieved in elm-vegalite by creating elm functions that generate lists of\n[AxisProperties](#AxisProperty).\n",
                "type": "List.List ( String.String, List.List VegaLite.AxisProperty ) -> VegaLite.ConfigurationProperty"
            },
            {
                "name": "coAxisTemporal",
                "comment": " Configure the default appearance of any temporal axes.\n",
                "type": "List.List VegaLite.AxisConfig -> VegaLite.ConfigurationProperty"
            },
            {
                "name": "coAxisTop",
                "comment": " Configure the default appearance of top-side axes.\n",
                "type": "List.List VegaLite.AxisConfig -> VegaLite.ConfigurationProperty"
            },
            {
                "name": "coAxisXFilter",
                "comment": " Filter an axis configuration so that it only applies to x-axes. For example,\nto configure all band X-axes to be red:\n\n    configuration (coAxisBand [ axcoTitleColor \"red\" ] |> coAxisXFilter)\n\n",
                "type": "VegaLite.ConfigurationProperty -> VegaLite.ConfigurationProperty"
            },
            {
                "name": "coAxisYFilter",
                "comment": " Filter an axis configuration so that it only applies to y-axes. For example,\nto configure all temporal Y-axes to be red:\n\n    configuration (coAxisTemporal [ axcoTitleColor \"red\" ] |> coAxisYFilter)\n\n",
                "type": "VegaLite.ConfigurationProperty -> VegaLite.ConfigurationProperty"
            },
            {
                "name": "coBackground",
                "comment": " Configure the default background color of visualizations.\n",
                "type": "String.String -> VegaLite.ConfigurationProperty"
            },
            {
                "name": "coBar",
                "comment": " Configure the default appearance of bar marks.\n",
                "type": "List.List VegaLite.MarkProperty -> VegaLite.ConfigurationProperty"
            },
            {
                "name": "coBooExpr",
                "comment": " Provide an [expression](https://vega.github.io/vega/docs/expressions/) to a\ntop-level configuration function requiring a Boolean value. This can be used to\nprovide an interactive parameterisation when an expression is bound to an input\nelement.\n",
                "type": "String.String -> (Basics.Bool -> VegaLite.ConfigurationProperty) -> VegaLite.ConfigurationProperty"
            },
            {
                "name": "coCircle",
                "comment": " Configure the default appearance of circle marks.\n",
                "type": "List.List VegaLite.MarkProperty -> VegaLite.ConfigurationProperty"
            },
            {
                "name": "coConcat",
                "comment": " Configure the default appearance of concatenated layouts.\n",
                "type": "List.List VegaLite.ConcatConfig -> VegaLite.ConfigurationProperty"
            },
            {
                "name": "coCountTitle",
                "comment": " Configure the default title style for count fields.\n",
                "type": "String.String -> VegaLite.ConfigurationProperty"
            },
            {
                "name": "coCustomFormatTypes",
                "comment": " Allow formatting of text marks and guides (e.g. [axFormatAsCustom](#axFormatAsCustom))\nto accept a custom formatter function registered as a Vega expression. See\n[how to register a Vega-Lite custom formatter](https://vega.github.io/vega-lite/usage/compile.html#format-type).\n",
                "type": "Basics.Bool -> VegaLite.ConfigurationProperty"
            },
            {
                "name": "coFacet",
                "comment": " Configure the default appearance of facet layouts.\n",
                "type": "List.List VegaLite.FacetConfig -> VegaLite.ConfigurationProperty"
            },
            {
                "name": "coFieldTitle",
                "comment": " Configure the default title generation style for fields.\n",
                "type": "VegaLite.FieldTitleProperty -> VegaLite.ConfigurationProperty"
            },
            {
                "name": "coFont",
                "comment": " Configure the default font for all titles, labels and text marks.\n",
                "type": "String.String -> VegaLite.ConfigurationProperty"
            },
            {
                "name": "coGeoshape",
                "comment": " Configure the default appearance of geoshape marks.\n",
                "type": "List.List VegaLite.MarkProperty -> VegaLite.ConfigurationProperty"
            },
            {
                "name": "coHeader",
                "comment": " Configure the default appearance of facet headers.\n",
                "type": "List.List VegaLite.HeaderProperty -> VegaLite.ConfigurationProperty"
            },
            {
                "name": "coLegend",
                "comment": " Configure the default appearance of legends.\n",
                "type": "List.List VegaLite.LegendConfig -> VegaLite.ConfigurationProperty"
            },
            {
                "name": "coLine",
                "comment": " Configure the default appearance of line marks.\n",
                "type": "List.List VegaLite.MarkProperty -> VegaLite.ConfigurationProperty"
            },
            {
                "name": "coLocale",
                "comment": " Specify the default locale settings. Allows, for example, local currency, time\nand thousands separators to be defined as the default. For example a German locale\nmight be defined as\n\n    coLocale\n        [ loDecimal \",\"\n        , loThousands \".\"\n        , loGrouping 3\n        , loCurrency \"\" \"\\\\u00a0€\"\n        ]\n\n",
                "type": "List.List VegaLite.LocaleProperty -> VegaLite.ConfigurationProperty"
            },
            {
                "name": "coMark",
                "comment": " Configure the default mark appearance.\n",
                "type": "List.List VegaLite.MarkProperty -> VegaLite.ConfigurationProperty"
            },
            {
                "name": "coMarkStyles",
                "comment": " Specify a list of named styles that each define a list of mark properties.\nCan be used when configuring views, titles etc. Provided for compatibility with\nVega-Lite, but generally greater type safety is achieved in elm-vegalite by creating\nelm functions that generate lists of [MarkProperties](#MarkProperty).\n",
                "type": "List.List ( String.String, List.List VegaLite.MarkProperty ) -> VegaLite.ConfigurationProperty"
            },
            {
                "name": "coNumberFormat",
                "comment": " Configure the default number formatting for axis and text labels.\n",
                "type": "String.String -> VegaLite.ConfigurationProperty"
            },
            {
                "name": "coPadding",
                "comment": " Configure the default padding in pixels from the edge of the of visualization\nto the data rectangle.\n",
                "type": "VegaLite.Padding -> VegaLite.ConfigurationProperty"
            },
            {
                "name": "coPoint",
                "comment": " Configure the default appearance of point marks.\n",
                "type": "List.List VegaLite.MarkProperty -> VegaLite.ConfigurationProperty"
            },
            {
                "name": "coProjection",
                "comment": " Configure the default style of map projections.\n",
                "type": "List.List VegaLite.ProjectionProperty -> VegaLite.ConfigurationProperty"
            },
            {
                "name": "coRange",
                "comment": " Configure the default range properties used when scaling.\n",
                "type": "List.List VegaLite.RangeConfig -> VegaLite.ConfigurationProperty"
            },
            {
                "name": "coRect",
                "comment": " Configure the default appearance of rectangle marks.\n",
                "type": "List.List VegaLite.MarkProperty -> VegaLite.ConfigurationProperty"
            },
            {
                "name": "coRule",
                "comment": " Configure the default appearance of rule marks.\n",
                "type": "List.List VegaLite.MarkProperty -> VegaLite.ConfigurationProperty"
            },
            {
                "name": "coScale",
                "comment": " Configure the default scale properties used when scaling.\n",
                "type": "List.List VegaLite.ScaleConfig -> VegaLite.ConfigurationProperty"
            },
            {
                "name": "coSelection",
                "comment": " Configure the default appearance of selection marks.\n",
                "type": "List.List ( VegaLite.Selection, List.List VegaLite.SelectionProperty ) -> VegaLite.ConfigurationProperty"
            },
            {
                "name": "coSquare",
                "comment": " Configure the default appearance of square marks.)\n",
                "type": "List.List VegaLite.MarkProperty -> VegaLite.ConfigurationProperty"
            },
            {
                "name": "coStrExpr",
                "comment": " Provide an [expression](https://vega.github.io/vega/docs/expressions/) to a\ntop-level configuration function requiring a string value. This can be used to\nprovide an interactive parameterisation when an expression is bound to an input\nelement.\n",
                "type": "String.String -> (String.String -> VegaLite.ConfigurationProperty) -> VegaLite.ConfigurationProperty"
            },
            {
                "name": "coText",
                "comment": " Configure the default appearance of text marks.\n",
                "type": "List.List VegaLite.MarkProperty -> VegaLite.ConfigurationProperty"
            },
            {
                "name": "coTick",
                "comment": " Configure the default appearance of tick marks.\n",
                "type": "List.List VegaLite.MarkProperty -> VegaLite.ConfigurationProperty"
            },
            {
                "name": "coTimeFormat",
                "comment": " Configure the default time format for axis and legend labels.\n",
                "type": "String.String -> VegaLite.ConfigurationProperty"
            },
            {
                "name": "coTitle",
                "comment": " Configure the default style of visualization titles.\n",
                "type": "List.List VegaLite.TitleConfig -> VegaLite.ConfigurationProperty"
            },
            {
                "name": "coTrail",
                "comment": " Configure the default style of trail marks.\n",
                "type": "List.List VegaLite.MarkProperty -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"
            },
            {
                "name": "coView",
                "comment": " Configure the default single view style.\n",
                "type": "List.List VegaLite.ViewConfig -> VegaLite.ConfigurationProperty"
            },
            {
                "name": "cocoColumns",
                "comment": " Configuration option for the maximum number of columns to use in a concatenated\nflow layout.\n",
                "type": "Basics.Int -> VegaLite.ConcatConfig"
            },
            {
                "name": "cocoSpacing",
                "comment": " Configuration option for the spacing in pixels between sub-views in a\nconcatenated view.\n",
                "type": "Basics.Float -> VegaLite.ConcatConfig"
            },
            {
                "name": "color",
                "comment": " Encode a color channel. The first parameter is a list of color encoding options\nsuch as the data to encode, colour scaling etc.\n\n    enc =\n        encoding\n            << color [ mName \"avHireTime\", mQuant ]\n\n",
                "type": "List.List VegaLite.MarkChannel -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"
            },
            {
                "name": "column",
                "comment": " Encodes a new facet to be arranged in columns. The first parameter is a list\nof properties that define the faceting channel. This should include at least the\nname of the data field and its measurement type. See the\n[Vega-Lite column documentation](https://vega.github.io/vega-lite/docs/facet.html#row--column-encoding-channels)\n\nNote that when faceting, dimensions specified with [width](#width) and [height](#height)\nrefer to the individual faceted plots, not the assemblage as a whole.\n\n    let\n        data =\n            dataFromUrl \"crimeData.csv\"\n\n        enc =\n            encoding\n                << position X [ pName \"month\", pTemporal ]\n                << position Y [ pName \"reportedCrimes\", pQuant, pAggregate opSum ]\n                << column [ fName \"crimeType\", fNominal ]\n    in\n    toVegaLite [ width 100, data [], bar [], enc [] ]\n\n",
                "type": "List.List VegaLite.FacetChannel -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"
            },
            {
                "name": "columnBy",
                "comment": " The mapping between a column and its field definitions in a set of faceted\nsmall multiples. This is used when specifying a more flexible [facet](#facet)\nrather than the compact, but simplified, [column](#column).\n",
                "type": "List.List VegaLite.FacetChannel -> VegaLite.FacetMapping"
            },
            {
                "name": "columnFields",
                "comment": " Create a list of fields to use in set of repeated small multiples arranged in\ncolumns. The list of fields named here can be referenced in an encoding with\n`pRepeat column`, `mRepeat column` etc.\n",
                "type": "List.List String.String -> VegaLite.RepeatFields"
            },
            {
                "name": "columns",
                "comment": " Maximum number of columns to include in a view composition flow layout. If the\nnumber of faceted small multiples exceeds this number, flow moves to the next row.\nOnly applies to flow layouts generated by [concat](#concat), [facetFlow](#facetFlow)\nand [repeatFlow](#repeatFlow). If 0, negative or not defined, faceted small multiples\nwill be arranged in a single row.\n",
                "type": "Basics.Int -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "combineSpecs",
                "comment": " Combine a list of labelled specifications to be passed to JavaScript for rendering.\nUseful when you wish to create a single page with multiple visualizations.\n\n    combineSpecs\n        [ ( \"vis1\", myFirstVis )\n        , ( \"vis2\", mySecondVis )\n        , ( \"vis3\", myOtherVis )\n        ]\n\n",
                "type": "List.List VegaLite.LabelledSpec -> VegaLite.Spec"
            },
            {
                "name": "concat",
                "comment": " Specifications to be juxtaposed in a flow layout of views. The number of columns\nin the flow layout can be set with [columns](#columns) and if not specified will\ndefault to a single row of unlimited columns.\n\n    let\n        data =\n            dataSequenceAs 0 6.28 0.1 \"x\"\n\n        trans =\n            transform\n                << calculateAs \"sin(datum.x)\" \"sinX\"\n                << calculateAs \"cos(datum.x)\" \"cosX\"\n\n        enc =\n            encoding\n                << position X [ pName \"x\", pQuant ]\n\n        encCos =\n            enc << position Y [ pName \"cosX\", pQuant ]\n\n        encSin =\n            enc << position Y [ pName \"sinX\", pQuant ]\n    in\n    toVegaLite\n        [ data\n        , trans []\n        , concat\n            [ asSpec [ encCos [], line [] ]\n            , asSpec [ encSin [], line [] ]\n            ]\n        ]\n\n",
                "type": "List.List VegaLite.Spec -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "configuration",
                "comment": " A configuration option to be applied globally across the visualization.\n",
                "type": "VegaLite.ConfigurationProperty -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"
            },
            {
                "name": "configure",
                "comment": " Create a single global configuration from a list of configuration specifications.\nEach [configuration](#configuration) that makes up the global list of customisations\nrefers to a specific part of all visualizations to which it is applied, such as\naxes, legends, selections etc. See the\n[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/config.html).\n\nIndividual configuration functions are prefixed with an abbreviation of the part\nof the visualization to configure followed by `co`. For example, axis configuration\nfunctions `axco`, legends `leco`, titles `tico`, faceting `faco` etc.\n\nThe following makes all axis lines (domain) 2 pixels wide, removes the border\nrectangle and requires interactive selection of items to use a double-click.\n\n    let\n        cfg =\n            configure\n                << configuration (coAxis [ axcoDomainWidth 2 ])\n                << configuration (coView [ vicoStroke Nothing ])\n                << configuration (coSelection [ ( sePoint, [ seOn \"dblclick\" ] ) ])\n    in\n    toVegaLite [ cfg [], data [], enc [], bar [] ]\n\n",
                "type": "List.List VegaLite.LabelledSpec -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "conicConformal",
                "comment": " A conformal conic map projection.\n",
                "type": "VegaLite.Projection"
            },
            {
                "name": "conicEqualArea",
                "comment": " An equal area conic map projection.\n",
                "type": "VegaLite.Projection"
            },
            {
                "name": "conicEquidistant",
                "comment": " An equidistant conic map projection.\n",
                "type": "VegaLite.Projection"
            },
            {
                "name": "csv",
                "comment": " CSV data file format (only necessary if the file extension does not indicate the\ntype).\n",
                "type": "VegaLite.Format"
            },
            {
                "name": "cuAlias",
                "comment": " Alias cursor.\n",
                "type": "VegaLite.Cursor"
            },
            {
                "name": "cuAllScroll",
                "comment": " Scrolling cursor.\n",
                "type": "VegaLite.Cursor"
            },
            {
                "name": "cuAuto",
                "comment": " Automatically determine a cursor type depending on interaction context.\n",
                "type": "VegaLite.Cursor"
            },
            {
                "name": "cuCell",
                "comment": " Cell cursor.\n",
                "type": "VegaLite.Cursor"
            },
            {
                "name": "cuColResize",
                "comment": " Resizing cursor.\n",
                "type": "VegaLite.Cursor"
            },
            {
                "name": "cuContextMenu",
                "comment": " Context menu cursor.\n",
                "type": "VegaLite.Cursor"
            },
            {
                "name": "cuCopy",
                "comment": " Copy cursor.\n",
                "type": "VegaLite.Cursor"
            },
            {
                "name": "cuCrosshair",
                "comment": " Crosshair cursor.\n",
                "type": "VegaLite.Cursor"
            },
            {
                "name": "cuDefault",
                "comment": " Default cursor.\n",
                "type": "VegaLite.Cursor"
            },
            {
                "name": "cuEResize",
                "comment": " Resizing cursor.\n",
                "type": "VegaLite.Cursor"
            },
            {
                "name": "cuEWResize",
                "comment": " Resizing cursor.\n",
                "type": "VegaLite.Cursor"
            },
            {
                "name": "cuExpr",
                "comment": " Expression that evaluates to some cursor style such as \"crosshair\", \"grab\"\nor \"help\".\n",
                "type": "String.String -> VegaLite.Cursor"
            },
            {
                "name": "cuGrab",
                "comment": " Grab cursor.\n",
                "type": "VegaLite.Cursor"
            },
            {
                "name": "cuGrabbing",
                "comment": " Grabbing cursor.\n",
                "type": "VegaLite.Cursor"
            },
            {
                "name": "cuHelp",
                "comment": " Help cursor.\n",
                "type": "VegaLite.Cursor"
            },
            {
                "name": "cuMove",
                "comment": " Move cursor.\n",
                "type": "VegaLite.Cursor"
            },
            {
                "name": "cuNEResize",
                "comment": " Resizing cursor.\n",
                "type": "VegaLite.Cursor"
            },
            {
                "name": "cuNESWResize",
                "comment": " Resizing cursor.\n",
                "type": "VegaLite.Cursor"
            },
            {
                "name": "cuNResize",
                "comment": " Resizing cursor.\n",
                "type": "VegaLite.Cursor"
            },
            {
                "name": "cuNSResize",
                "comment": " Resizing cursor.\n",
                "type": "VegaLite.Cursor"
            },
            {
                "name": "cuNWResize",
                "comment": " Resizing cursor.\n",
                "type": "VegaLite.Cursor"
            },
            {
                "name": "cuNWSEResize",
                "comment": " Resizing cursor.\n",
                "type": "VegaLite.Cursor"
            },
            {
                "name": "cuNoDrop",
                "comment": " 'No drop' cursor.\n",
                "type": "VegaLite.Cursor"
            },
            {
                "name": "cuNone",
                "comment": " No cursor.\n",
                "type": "VegaLite.Cursor"
            },
            {
                "name": "cuNotAllowed",
                "comment": " 'Not allowed' cursor.\n",
                "type": "VegaLite.Cursor"
            },
            {
                "name": "cuPointer",
                "comment": " Pointer cursor.\n",
                "type": "VegaLite.Cursor"
            },
            {
                "name": "cuProgress",
                "comment": " Progress cursor.\n",
                "type": "VegaLite.Cursor"
            },
            {
                "name": "cuRowResize",
                "comment": " Resizing cursor.\n",
                "type": "VegaLite.Cursor"
            },
            {
                "name": "cuSEResize",
                "comment": " Resizing cursor.\n",
                "type": "VegaLite.Cursor"
            },
            {
                "name": "cuSResize",
                "comment": " Resizing cursor.\n",
                "type": "VegaLite.Cursor"
            },
            {
                "name": "cuSWResize",
                "comment": " Resizing cursor.\n",
                "type": "VegaLite.Cursor"
            },
            {
                "name": "cuText",
                "comment": " Text cursor.\n",
                "type": "VegaLite.Cursor"
            },
            {
                "name": "cuVerticalText",
                "comment": " Vertical text cursor.\n",
                "type": "VegaLite.Cursor"
            },
            {
                "name": "cuWResize",
                "comment": " Resizing cursor.\n",
                "type": "VegaLite.Cursor"
            },
            {
                "name": "cuWait",
                "comment": " Waiting cursor.\n",
                "type": "VegaLite.Cursor"
            },
            {
                "name": "cuZoomIn",
                "comment": " Zooming cursor.\n",
                "type": "VegaLite.Cursor"
            },
            {
                "name": "cuZoomOut",
                "comment": " Zooming cursor.\n",
                "type": "VegaLite.Cursor"
            },
            {
                "name": "cubeHelix",
                "comment": " Cube helix color interpolation for continuous color scales using the given\ngamma value (anchored at 1).\n",
                "type": "Basics.Float -> VegaLite.CInterpolate"
            },
            {
                "name": "cubeHelixLong",
                "comment": " Long-path cube helix color interpolation for continuous color scales using\nthe given gamma value (anchored at 1).\n",
                "type": "Basics.Float -> VegaLite.CInterpolate"
            },
            {
                "name": "customProjection",
                "comment": " Custom projection type. Additional custom projections from d3 can be defined\nvia the [Vega API](https://vega.github.io/vega/docs/projections/#register) and\ncalled from with this function where the parameter is the name of the D3\nprojection to use (e.g. `customProjection \"winkel3\"`).\n",
                "type": "String.String -> VegaLite.Projection"
            },
            {
                "name": "dAggregate",
                "comment": " Compute some aggregate summary statistics for a field to be encoded with a\nlevel of detail (grouping) channel. The type of aggregation is determined by the\ngiven operation parameter.\n",
                "type": "VegaLite.Operation -> VegaLite.DetailChannel"
            },
            {
                "name": "dBin",
                "comment": " Discretize numeric values into bins when encoding with a level of detail\n(grouping) channel.\n",
                "type": "List.List VegaLite.BinProperty -> VegaLite.DetailChannel"
            },
            {
                "name": "dGeo",
                "comment": " Indicate a data field encoded with a detail channel is a geo feature.\n",
                "type": "VegaLite.DetailChannel"
            },
            {
                "name": "dName",
                "comment": " Name of field used for encoding with a level of detail (grouping) channel.\n",
                "type": "String.String -> VegaLite.DetailChannel"
            },
            {
                "name": "dNominal",
                "comment": " Indicate a data field encoded with a detail channel is nominal. This is the\ndefault data type.\n",
                "type": "VegaLite.DetailChannel"
            },
            {
                "name": "dOrdinal",
                "comment": " Indicate a data field encoded with a detail channel is ordinal.\n",
                "type": "VegaLite.DetailChannel"
            },
            {
                "name": "dQuant",
                "comment": " Indicate a data field encoded with a detail channel is quantitative.\n",
                "type": "VegaLite.DetailChannel"
            },
            {
                "name": "dTemporal",
                "comment": " Indicate a data field encoded with a detail channel is temporal.\n",
                "type": "VegaLite.DetailChannel"
            },
            {
                "name": "dTimeUnit",
                "comment": " Form of time unit aggregation of field values when encoding with a level of\ndetail (grouping) channel.\n",
                "type": "VegaLite.TimeUnit -> VegaLite.DetailChannel"
            },
            {
                "name": "daConcat",
                "comment": " Concatenate a list of data values as a single data value. For example,\n\n    param \"location\" [ paValue (daConcat (nums [ 4000, 8000 ])) ]\n\n",
                "type": "VegaLite.DataValues -> VegaLite.DataValue"
            },
            {
                "name": "dataArrays",
                "comment": " Like [datumArray](#datumArray) except stores a collection of [DataValues](#DataValues)\n(like [strs](#strs), [nums](#nums)) instead of singular datum items. This is just\na convenience function for replicating a `datumArray` that contains lists of items\nof the same type. For example,\n\n    dataArrays [ nums [ 10, 20, 30 ], strs [ \"a\", \"b\", \"c\" ] ]\n\nis equivalent to\n\n    datumArray\n        [ datumArray [ num 10, num 20, num 30 ]\n        , datumArray [ str \"a\", str \"b\", str \"c\" ]\n        ]\n\n",
                "type": "List.List VegaLite.DataValues -> VegaLite.DataValues"
            },
            {
                "name": "dataColumn",
                "comment": " Create a column of data. A column has a name and a list of values.\n",
                "type": "String.String -> VegaLite.DataValues -> List.List VegaLite.DataColumn -> List.List VegaLite.DataColumn"
            },
            {
                "name": "dataExpr",
                "comment": " A list of data values created by the given expression.\n",
                "type": "String.String -> VegaLite.DataValues"
            },
            {
                "name": "dataFromColumns",
                "comment": " Declare a data source from a list of column values. Each column should contain\nvalues of the same type, but columns each with a different type are permitted.\nIf columns do not contain the same number of items the dataset will be truncated\nto the length of the shortest, so beware of inadvertently removing data rows at\nthe 'bottom' of a table.\n\nA list of field formatting instructions can be provided as the first parameter\nor an empty list to use the default formatting. Simple numbers and strings do not\nnormally need formatting, but it is good practice to explicitly declare date-time\nformats as default date-time formats can vary between browsers.\n\nThe columns are most easily generated with [dataColumn](#dataColumn):\n\n    data =\n        dataFromColumns [ parse [ ( \"Year\", foDate \"%Y\" ) ] ]\n            << dataColumn \"Animal\" (strs [ \"Fish\", \"Dog\", \"Cat\" ])\n            << dataColumn \"Age\" (nums [ 28, 12, 6 ])\n            << dataColumn \"Year\" (strs [ \"2010\", \"2014\", \"2015\" ])\n\nFor more complex inline data tables, such as mixtures of arrays and objects, consider\nusing [dataFromJson](#dataFromJson).\n\n",
                "type": "List.List VegaLite.Format -> List.List VegaLite.DataColumn -> VegaLite.Data"
            },
            {
                "name": "dataFromJson",
                "comment": " Declare a data source from a json specification. The most likely use-case is\ncreating [geojson](http://geojson.org) objects with [`geometry`](#geometry),\n[`geometryCollection`](#geometryCollection) and [`geoFeatureCollection`](#geoFeatureCollection).\n\n    let\n        geojson =\n            geometry (geoPolygon [ [ ( -3, 59 ), ( 4, 59 ), ( 4, 52 ), ( -3, 59 ) ] ]) []\n    in\n    toVegaLite\n        [ width 200\n        , height 200\n        , dataFromJson geojson []\n        , projection [ prType orthographic ]\n        , geoshape []\n        ]\n\nFor more general cases of json creation such as data tables that mix arrays and\nobjects, consider combining with [jsonToSpec](#jsonToSpec), for example,\n\n    data =\n        jsonToSpec\n            \"\"\"\n            {\n                \"Revenue\" : [ 150, 225, 300 ],\n                \"Profit\" : [ 20, 25, 30 ],\n                \"Order size\" : [ 350, 500, 600 ],\n                \"New customers\" : [ 1400, 2000, 2500 ],\n                \"Satisfaction\" : [ 3.5, 4.25, 5 ]\n            }\n            \"\"\"\n            |> dataFromJson\n\n",
                "type": "VegaLite.Spec -> List.List VegaLite.Format -> VegaLite.Data"
            },
            {
                "name": "dataFromRows",
                "comment": " Declare a data source from a list of row values. Each row should contain a\nlist of tuples in the form (_column name_, _value_). Each column can have a value\nof a different type but you must ensure that values are of the same type as others\nin the same column. A list of field formatting instructions can be provided as\nthe first parameter or an empty list to use the default formatting. Rows are most\neasily generated with [dataRow](#dataRow).\n\n    data =\n        dataFromRows [ parse [ ( \"Year\", foDate \"%Y\" ) ] ]\n            << dataRow [ ( \"Animal\", str \"Fish\" ), ( \"Age\", num 28 ), ( \"Year\", str \"2010\" ) ]\n            << dataRow [ ( \"Animal\", str \"Dog\" ), ( \"Age\", num 12 ), ( \"Year\", str \"2014\" ) ]\n            << dataRow [ ( \"Animal\", str \"Cat\" ), ( \"Age\", num 6 ), ( \"Year\", str \"2015\" ) ]\n\nGenerally, adding data by column is more efficient and less error-prone. For more\ncomplex inline data tables, such as mixtures of arrays and objects, consider using\n[dataFromJson](#dataFromJson).\n\n",
                "type": "List.List VegaLite.Format -> List.List VegaLite.DataRow -> VegaLite.Data"
            },
            {
                "name": "dataFromSource",
                "comment": " Declare data from a named source. The source may be from named [datasets](#datasets)\nwithin a specification or one created via the\n[Vega View API](https://vega.github.io/vega/docs/api/view/#data). A list of field\nformatting instructions can be provided as the second parameter or an empty list\nto use the default formatting.\n\n    data = ...\n    json = ...\n    enc = ...\n    toVegaLite\n        [ datasets [ ( \"myData\", data [] ),  ( \"myJson\", dataFromJson json [] ) ]\n        , dataFromSource \"myData\" []\n        , enc []\n        , bar []\n        ]\n\n",
                "type": "String.String -> List.List VegaLite.Format -> VegaLite.Data"
            },
            {
                "name": "dataFromUrl",
                "comment": " Declare a data source from a url. The URL can be a local path on a web server\nor an external (CORS) URL. A list of field formatting instructions can be provided\nas the second parameter or an empty list to use the default formatting.\n\n    bikeData =\n        dataFromUrl \"./data/bicycleHires.csv\"\n            [ parse [ ( \"numHires\", foNum ), ( \"avHireTime\", foNum ) ] ]\n\n    popData =\n        dataFromUrl \"https://vega.github.io/vega-lite/data/population.json\" []\n\n",
                "type": "String.String -> List.List VegaLite.Format -> VegaLite.Data"
            },
            {
                "name": "dataName",
                "comment": " Name to give a data source. Useful when a specification needs to reference a\ndata source, such as one generated via an API call.\n\n    data =\n        dataFromUrl \"myData.json\" [] |> dataName \"myName\"\n\n",
                "type": "String.String -> VegaLite.Data -> VegaLite.Data"
            },
            {
                "name": "dataObject",
                "comment": " Key-value pairs representing a named data value. For example,\n\n    dataObject [ ( \"x\", num 3500 ), ( \"firstName\", str \"Ada\" ) ]\n\n",
                "type": "List.List ( String.String, VegaLite.DataValue ) -> VegaLite.DataValue"
            },
            {
                "name": "dataObjects",
                "comment": " Generate a collection of lists of Key-value pairs representing named data\nvalues.\n",
                "type": "List.List (List.List ( String.String, VegaLite.DataValue )) -> VegaLite.DataValues"
            },
            {
                "name": "dataRow",
                "comment": " Create a row of data. A row comprises a list of (_columnName_, _value_) pairs.\n",
                "type": "List.List ( String.String, VegaLite.DataValue ) -> List.List VegaLite.DataRow -> List.List VegaLite.DataRow"
            },
            {
                "name": "dataSequence",
                "comment": " Generate a sequence of numbers as a data source between the value of the first\nparameter (inclusive) and the second (exclusive) in steps of the value of the third.\nThe resulting sequence will have the name `data`.\n\n    myData =\n        dataSequence 0 6.28 0.1\n\nTo give the sequence an alternative name use [dataSequenceAs](#dataSequenceAs)\n\n",
                "type": "Basics.Float -> Basics.Float -> Basics.Float -> VegaLite.Data"
            },
            {
                "name": "dataSequenceAs",
                "comment": " Generate a sequence of numbers as a data source between the value of the first\nparameter (inclusive) and the second (exclusive) in steps of the value of the third.\nThe resulting sequence will have the name provided as the fourth parameter.\n\n    myData =\n        dataSequenceAs 0 6.28 0.1 \"x\"\n\n",
                "type": "Basics.Float -> Basics.Float -> Basics.Float -> String.String -> VegaLite.Data"
            },
            {
                "name": "datasets",
                "comment": " Create a dataset comprising a collection of named `Data` items. Each data item\ncan be created with normal data generating functions such as [dataFromRows](#dataFromRows)\nor [dataFromJson](#dataFromJson). These can be later referred to using\n[dataFromSource](#dataFromSource).\n\n    import Json.Encode as JE\n\n    let\n        data =\n            dataFromRows []\n                << dataRow [ ( \"cat\", str \"a\" ), ( \"val\", num 10 ) ]\n                << dataRow [ ( \"cat\", str \"b\" ), ( \"val\", num 18 ) ]\n        json =\n            JE.list JE.object\n                [ [ ( \"cat\", JE.string \"a\" ), ( \"val\", JE.float 120 ) ]\n                , [ ( \"cat\", JE.string \"b\" ), ( \"val\", JE.float 180 ) ]\n                ]\n\n        enc = ...\n\n    in\n    toVegaLite\n        [ datasets [ ( \"myData\", data [] ),  ( \"myJson\", dataFromJson json [] ) ]\n        , dataFromSource \"myData\" []\n        , bar []\n        , enc []\n        ]\n\n",
                "type": "List.List ( String.String, VegaLite.Data ) -> VegaLite.Data"
            },
            {
                "name": "date",
                "comment": " Day of the month (1-31) time unit used for discretizing temporal data.\n",
                "type": "VegaLite.TimeUnit"
            },
            {
                "name": "datumArray",
                "comment": " List of data values. Unlike [nums](#nums), [strs](#strs) etc., this allows a\nsingle array to store mixed types and nested values. For example,\n\n    datumArray [ num 10, str \"a\", datumArray [ num 99, boo False ] ]\n\n",
                "type": "List.List VegaLite.DataValue -> VegaLite.DataValue"
            },
            {
                "name": "datumExpr",
                "comment": " A data value created by the given expression.\n",
                "type": "String.String -> VegaLite.DataValue"
            },
            {
                "name": "day",
                "comment": " Day of the week used for discretizing temporal data. This will therefore discretize\nany temporal sequence into a maximum of 7 bins.\n",
                "type": "VegaLite.TimeUnit"
            },
            {
                "name": "dayHours",
                "comment": " Hour of the day through the week used for discretizing temporal data. This will\ntherefore discretize any temporal sequence into a maximum of 7\\*24 bins.\n",
                "type": "VegaLite.TimeUnit"
            },
            {
                "name": "dayHoursMinutes",
                "comment": " Minute through the week used for discretizing temporal data. This will\ntherefore discretize any temporal sequence into a maximum of 7\\*24\\*60 bins.\n",
                "type": "VegaLite.TimeUnit"
            },
            {
                "name": "dayHoursMinutesSeconds",
                "comment": " Second through the week used for discretizing temporal data. This will\ntherefore discretize any temporal sequence into a maximum of 7\\*24\\*60\\*60 bins.\n",
                "type": "VegaLite.TimeUnit"
            },
            {
                "name": "dayOfYear",
                "comment": " Indicate temporal binning by day of the year, so a 10 year sequence would\nhave up to 366 bins.\n",
                "type": "VegaLite.TimeUnit"
            },
            {
                "name": "density",
                "comment": " Apply _Kernel Density Estimation_ to a data stream to generate a new stream\nof samples of the estimated density. Useful for representing probability\ndistributions and generating continuous distributions from discrete samples.\n",
                "type": "String.String -> List.List VegaLite.DensityProperty -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"
            },
            {
                "name": "description",
                "comment": " Description to be associated with a visualization.\n",
                "type": "String.String -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "detail",
                "comment": " Encode a 'level of detail' channel. This provides a way of grouping by a field\nbut unlike, say `color`, all groups have the same visual properties. The first\nparameter is a list of the field characteristics to be grouped.\n\n    enc =\n        encoding\n            << detail [ dName \"avHireTime\", dQuant ]\n\n",
                "type": "List.List VegaLite.DetailChannel -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"
            },
            {
                "name": "dnAs",
                "comment": " Name the outputs of a density transform. The first parameter is the name to\ngive the field containing samples, the second the name to give the field containing\ndensity estimates. If not specified, the default names `value` and `density` will\nbe used.\n",
                "type": "String.String -> String.String -> VegaLite.DensityProperty"
            },
            {
                "name": "dnBandwidth",
                "comment": " The bandwidth (standard deviation) of the Gaussian kernel used in KDE estimation.\nIf 0 or unspecified, the bandwidth will be calculated using\n[Scott's method](https://stats.stackexchange.com/questions/90656/kernel-bandwidth-scotts-vs-silvermans-rules).\n",
                "type": "Basics.Float -> VegaLite.DensityProperty"
            },
            {
                "name": "dnCounts",
                "comment": " Whether density estimates should generate counts (true) or probabilities (false).\nIf unspecified, probabilities will be generated.\n",
                "type": "Basics.Bool -> VegaLite.DensityProperty"
            },
            {
                "name": "dnCumulative",
                "comment": " Whether or not density estimates will be cumulative. If unspecified, non-cumulative\nestimates will be generated.\n",
                "type": "Basics.Bool -> VegaLite.DensityProperty"
            },
            {
                "name": "dnExtent",
                "comment": " The min (first parameter) - max (second parameter) domain from which to sample\na distribution for density estimation. If unspecified, the full extent of input\nvalues will be sampled.\n",
                "type": "Basics.Float -> Basics.Float -> VegaLite.DensityProperty"
            },
            {
                "name": "dnGroupBy",
                "comment": " The data fields to group by when estimating density. If not specified, a single\ngroup containing all data objects will be used.\n",
                "type": "List.List String.String -> VegaLite.DensityProperty"
            },
            {
                "name": "dnMaxSteps",
                "comment": " The maximum number of samples to take when estimating density. Default is 200.\n",
                "type": "Basics.Int -> VegaLite.DensityProperty"
            },
            {
                "name": "dnMinSteps",
                "comment": " The minimum number of samples to take from the extent domain when estimating\ndensity. Default is 25.\n",
                "type": "Basics.Int -> VegaLite.DensityProperty"
            },
            {
                "name": "dnSteps",
                "comment": " The exact number of samples to take from the extent domain when estimating\ndensity. Will override [dnMinSteps](#dnMinSteps) and [dnMaxSteps](#dnMaxSteps)\nand is useful in conjunction with a fixed extent to ensure consistent sample points\nfor stacked densities.\n",
                "type": "Basics.Int -> VegaLite.DensityProperty"
            },
            {
                "name": "doDts",
                "comment": " Date-time values that define a scale domain.\n",
                "type": "List.List (List.List VegaLite.DateTime) -> VegaLite.ScaleDomain"
            },
            {
                "name": "doDtsExpr",
                "comment": " Expression that should evaluate to a list of date-times that define a scale domain.\n",
                "type": "String.String -> VegaLite.ScaleDomain"
            },
            {
                "name": "doMax",
                "comment": " Set the maximum value of a continuous numeric domain. The minimum will be\ndetermined by the data. To set both the min and max values use [doNums](#doNums).\n",
                "type": "Basics.Float -> VegaLite.ScaleDomain"
            },
            {
                "name": "doMaxDt",
                "comment": " Set the maximum value of a date-time domain. The minimum will be determined\nby the data. To set both the min and max values use [doDts](#doDts).\n",
                "type": "List.List VegaLite.DateTime -> VegaLite.ScaleDomain"
            },
            {
                "name": "doMaxDtExpr",
                "comment": " Set the maximum value of a date-time domain with an expression that evaluates\nto a date-time.\n",
                "type": "String.String -> VegaLite.ScaleDomain"
            },
            {
                "name": "doMid",
                "comment": " Set the midpoint of continuous two-point diverging domain. Useful when the\ndomain is not symmetric about the given midpoint but you wish to use a color\nscheme that diverges equally from that point.\n",
                "type": "Basics.Float -> VegaLite.ScaleDomain"
            },
            {
                "name": "doMin",
                "comment": " Set the minimum value of a continuous numeric domain. The maximum will be\ndetermined by the data. To set both the min and max values use [doNums](#doNums).\n",
                "type": "Basics.Float -> VegaLite.ScaleDomain"
            },
            {
                "name": "doMinDt",
                "comment": " Set the minimum value of a date-time domain. The maximum will be determined\nby the data. To set both the min and max values use [doDts](#doDts).\n",
                "type": "List.List VegaLite.DateTime -> VegaLite.ScaleDomain"
            },
            {
                "name": "doMinDtExpr",
                "comment": " Set the minimum value of a date-time domain with an expression that evaluates\nto a date-time.\n",
                "type": "String.String -> VegaLite.ScaleDomain"
            },
            {
                "name": "doNumExpr",
                "comment": " Provide an [expression](https://vega.github.io/vega/docs/expressions/) to\na domain scale property function requiring a numeric value. This can be used for\ninteractive parameterisation when an expression is bound to an input element.\nFor example,\n\n    ps =\n        params\n            << param \"upper\"\n                [ paValue (num 50)\n                , paBind (ipRange [ inMax 100 ])\n                ]\n\n    enc =\n        encoding\n            << position X\n                [ pName \"x\"\n                , pScale [ scDomain (doNumExpr \"upper\" doMax) ]\n                ]\n\n",
                "type": "String.String -> (number -> VegaLite.ScaleDomain) -> VegaLite.ScaleDomain"
            },
            {
                "name": "doNums",
                "comment": " Numeric values that define a scale domain.\n",
                "type": "List.List Basics.Float -> VegaLite.ScaleDomain"
            },
            {
                "name": "doSelection",
                "comment": " Scale domain based on a named interactive selection. This can be used when\nprojecting a selection across a single domain or equally across several domains.\n",
                "type": "String.String -> VegaLite.ScaleDomain"
            },
            {
                "name": "doSelectionChannel",
                "comment": " Scale domain based on a named interactive selection (first parameter) and project\nit across the given channel (second parameter). Useful when, for example, you wish\nto project a 2d interval selection across the X and Y channels each with independent\ndomains.\n",
                "type": "String.String -> VegaLite.Channel -> VegaLite.ScaleDomain"
            },
            {
                "name": "doSelectionField",
                "comment": " Scale domain based on a named interactive selection (first parameter) and project\nit across the given field (second parameter). Useful when, for example, you wish\nto project a 2d interval selection across the X and Y channels each with independent\ndomains.\n",
                "type": "String.String -> String.String -> VegaLite.ScaleDomain"
            },
            {
                "name": "doStrs",
                "comment": " String values that define a scale domain.\n",
                "type": "List.List String.String -> VegaLite.ScaleDomain"
            },
            {
                "name": "doUnaggregated",
                "comment": " Indicate that a domain of aggregated data should be scaled to the domain of\nthe data prior to aggregation.\n",
                "type": "VegaLite.ScaleDomain"
            },
            {
                "name": "doUnionWith",
                "comment": " Combine the given domain with that determined by the data. This allows a minimal\ndomain to be set that may be exceeded if the data determine so. For example, the\nfollowing sets a domain of at least 0 to 100, but can be exceeded if the data\nextend beyond the domain:\n\n    pScale [ scDomain (doUnionWith (doNums [ 0, 100 ])) ]\n\n",
                "type": "VegaLite.ScaleDomain -> VegaLite.ScaleDomain"
            },
            {
                "name": "domainRangeMap",
                "comment": " Create a pair of continuous domain to color mappings suitable for customising\nordered scales. The first parameter is a tuple representing the mapping of the lowest\nnumeric value in the domain to its equivalent color; the second tuple the mapping\nof the highest numeric value to color. If the domain contains any values between\nthese lower and upper bounds they are interpolated according to the scale's interpolation\nfunction. Convenience function equivalent to specifying separate `scDomain` and\n`scRange` lists and is safer as it guarantees a one-to-one correspondence between\ndomain and range values.\n\n    color\n        [ mName \"year\"\n        , mOrdinal\n        , mScale (domainRangeMap ( 1955, \"#e6959c\" ) ( 2000, \"#911a24\" ))\n        ]\n\n",
                "type": "( Basics.Float, String.String ) -> ( Basics.Float, String.String ) -> List.List VegaLite.ScaleProperty"
            },
            {
                "name": "dsv",
                "comment": " Delimited file format (DSV) with a given separator.\n",
                "type": "Char.Char -> VegaLite.Format"
            },
            {
                "name": "dt",
                "comment": " Date-time data value.\n",
                "type": "List.List VegaLite.DateTime -> VegaLite.DataValue"
            },
            {
                "name": "dtDate",
                "comment": " Day of the month (1 to 31).\n",
                "type": "Basics.Int -> VegaLite.DateTime"
            },
            {
                "name": "dtDay",
                "comment": " Day of the week.\n",
                "type": "VegaLite.DayName -> VegaLite.DateTime"
            },
            {
                "name": "dtHour",
                "comment": " Hour of the day (0=midnight, 1=1am, 23=11pm etc.).\n",
                "type": "Basics.Int -> VegaLite.DateTime"
            },
            {
                "name": "dtMillisecond",
                "comment": " Millisecond of a second (0-999).\n",
                "type": "Basics.Int -> VegaLite.DateTime"
            },
            {
                "name": "dtMinute",
                "comment": " Minute of an hour (0-59).\n",
                "type": "Basics.Int -> VegaLite.DateTime"
            },
            {
                "name": "dtMonth",
                "comment": " Month of a year.\n",
                "type": "VegaLite.MonthName -> VegaLite.DateTime"
            },
            {
                "name": "dtMonthNum",
                "comment": " Month of a year as a number (1 - 12).\n",
                "type": "VegaLite.MonthName -> VegaLite.DateTime"
            },
            {
                "name": "dtQuarter",
                "comment": " Year quarter (1 to 4).\n",
                "type": "Basics.Int -> VegaLite.DateTime"
            },
            {
                "name": "dtRange",
                "comment": " Min max date-time range to be used in data filtering. If either\nparameter is an empty list, it is assumed to be unbounded.\n",
                "type": "List.List VegaLite.DateTime -> List.List VegaLite.DateTime -> VegaLite.FilterRange"
            },
            {
                "name": "dtSecond",
                "comment": " Second of a minute (0-59).\n",
                "type": "Basics.Int -> VegaLite.DateTime"
            },
            {
                "name": "dtYear",
                "comment": " A year.\n",
                "type": "Basics.Int -> VegaLite.DateTime"
            },
            {
                "name": "dts",
                "comment": " List of date-time data values. Used when declaring inline data with\n[dataColumn](#dataColumn), filtering ([fiOneOf](#fiOneOf)), imputation\n([imKeyVals](#imKeyVals)) and customised sorting ([soCustom](#soCustom)).\n",
                "type": "List.List (List.List VegaLite.DateTime) -> VegaLite.DataValues"
            },
            {
                "name": "encoding",
                "comment": " Create an encoding specification from a list of channel encodings. These are\ncommonly built by chaining series of channel encoding functions together such as\n[position](#position), [color](#color), [size](#size) etc.\n\n    enc =\n        encoding\n            << position X [ pName \"month\", pTemporal ]\n            << position Y [ pName \"score\", pQuant ]\n            << color [ mName \"team\" ]\n\n",
                "type": "List.List VegaLite.LabelledSpec -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "equalEarth",
                "comment": " An [Equal Earth map projection](https://en.wikipedia.org/wiki/Equal_Earth_projection)\nthat provides a reasonable shape approximation while retaining relative areas.\n",
                "type": "VegaLite.Projection"
            },
            {
                "name": "equirectangular",
                "comment": " An equirectangular map projection that maps longitude to x and latitude to y.\nWhile showing less area distortion towards the poles than the default [mercator](#mercator)\nprojection, it is neither equal-area nor conformal.\n",
                "type": "VegaLite.Projection"
            },
            {
                "name": "errorband",
                "comment": " [Errorband composite mark](https://vega.github.io/vega-lite/docs/errorband.html)\nfor showing summaries of variation along a signal. By default no border is drawn.\nTo add a border use [maBorders](#maBorders) with an empty list for default border,\nor mark properties to customise.\n\n    errorband [ maBorders [ maColor \"black\", maStrokeWidth 0.5 ] ]\n\n",
                "type": "List.List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "errorbar",
                "comment": " [Errorbar composite mark](https://vega.github.io/vega-lite/docs/errorbar.html)\nfor showing summaries of variation along a signal. By default no ticks are drawn.\nTo add ticks with use [maTicks](#maTicks) with an empty list for default appearance,\nor with a list of mark properties to customise.\n\n    errorbar [ maTicks [ maColor \"black\", maSize 8 ] ]\n\n",
                "type": "List.List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "exCi",
                "comment": " Band extent between the 95% confidence intervals of a distribution.\n",
                "type": "VegaLite.SummaryExtent"
            },
            {
                "name": "exIqr",
                "comment": " Band extent between the lower and upper quartiles of a distribution.\n",
                "type": "VegaLite.SummaryExtent"
            },
            {
                "name": "exIqrScale",
                "comment": " A scaling of the interquartile range to be used as whiskers in a boxplot.\nFor example, a value of 1.5 would extend whiskers to ±1.5x the IQR from the mean.\n",
                "type": "Basics.Float -> VegaLite.SummaryExtent"
            },
            {
                "name": "exRange",
                "comment": " Band extent between the minimum and maximum values in a distribution.\n",
                "type": "VegaLite.SummaryExtent"
            },
            {
                "name": "exStderr",
                "comment": " Band extent as the standard error about the mean of a distribution.\n",
                "type": "VegaLite.SummaryExtent"
            },
            {
                "name": "exStdev",
                "comment": " Band extent as the standard deviation of a distribution.\n",
                "type": "VegaLite.SummaryExtent"
            },
            {
                "name": "expr",
                "comment": " Expression that should evaluate to either true or false. Can use any valid\n[Vega expression](https://vega.github.io/vega/docs/expressions/).\n",
                "type": "String.String -> VegaLite.BooleanOp"
            },
            {
                "name": "fAggregate",
                "comment": " Compute some aggregate summary statistics for a field to be encoded with a\nfacet channel. The type of aggregation is determined by the given operation\nparameter.\n",
                "type": "VegaLite.Operation -> VegaLite.FacetChannel"
            },
            {
                "name": "fAlign",
                "comment": " Alignment to apply to a rows or columns in a facet's sub-plot.\n",
                "type": "VegaLite.CompositionAlignment -> VegaLite.FacetChannel"
            },
            {
                "name": "fBin",
                "comment": " Discretize numeric values into bins when encoding with a facet channel.\n",
                "type": "List.List VegaLite.BinProperty -> VegaLite.FacetChannel"
            },
            {
                "name": "fCenter",
                "comment": " Whether or not a facet's sub-plots should be centred relative to their respective\nrows or columns.\n",
                "type": "Basics.Bool -> VegaLite.FacetChannel"
            },
            {
                "name": "fGeo",
                "comment": " Indicate a data field encoded as a facet property is a geo feature.\n",
                "type": "VegaLite.FacetChannel"
            },
            {
                "name": "fHeader",
                "comment": " Guide that spans a collection of faceted plots, each of which may have their own axes.\n",
                "type": "List.List VegaLite.HeaderProperty -> VegaLite.FacetChannel"
            },
            {
                "name": "fName",
                "comment": " Name of field used for encoding with a facet channel.\n",
                "type": "String.String -> VegaLite.FacetChannel"
            },
            {
                "name": "fNominal",
                "comment": " Indicate a data field encoded as a facet property is nominal. This is the\ndefault data type.\n",
                "type": "VegaLite.FacetChannel"
            },
            {
                "name": "fOrdinal",
                "comment": " Indicate a data field encoded as a facet property is ordinal.\n",
                "type": "VegaLite.FacetChannel"
            },
            {
                "name": "fQuant",
                "comment": " Indicate a data field encoded as a facet property is quantitative.\n",
                "type": "VegaLite.FacetChannel"
            },
            {
                "name": "fSort",
                "comment": " Sort order for a field when encoding with a faceted channel.\n\n    row\n        [ fName \"site\"\n        , fOrdinal\n        , fSort [ soByField \"x\" opMedian, soDescending ]\n        ]\n\n",
                "type": "List.List VegaLite.SortProperty -> VegaLite.FacetChannel"
            },
            {
                "name": "fSpacing",
                "comment": " Spacing in pixels between sub-views in a faceted view.\n",
                "type": "Basics.Float -> VegaLite.FacetChannel"
            },
            {
                "name": "fTemporal",
                "comment": " Indicate a data field encoded as a facet property is temporal.\n",
                "type": "VegaLite.FacetChannel"
            },
            {
                "name": "fTimeUnit",
                "comment": " Form of time unit aggregation of field values when encoding with a facet channel.\n",
                "type": "VegaLite.TimeUnit -> VegaLite.FacetChannel"
            },
            {
                "name": "facet",
                "comment": " Facet a view to create a grid of small multiples. Similar to [facetFlow](#facetFlow)\nexcept that the fields for faceting by rows and by columns are set explicitly.\n\n    spec = ...\n    toVegaLite\n        [ facet [ rowBy [ fName \"month\", fOrdinal ]\n                , columnBy [ fName \"week\", fOrdinal ]\n                ]\n        , specification spec\n        ]\n\n",
                "type": "List.List VegaLite.FacetMapping -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "facetFlow",
                "comment": " Facet a view to create small multiples in a flow layout. Used when the encoding\nof the visualization in small multiples is identical, but data for each is grouped\nby the given fields. When creating a faceted view in this way you also need to\ndefine a full specification to apply to each of those facets using `asSpec`.\n\nSmall multiples will be laid out from left to right, moving on to new rows only\nif the number of plots exceeds an optional column limit (specified via\n[columns](#columns)).\n\n    spec = ...\n    toVegaLite\n        [ facetFlow [ fName \"Origin\", fNominal ]\n        , specification spec\n        ]\n\n",
                "type": "List.List VegaLite.FacetChannel -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "facoColumns",
                "comment": " Configuration option for the maximum number of columns to use in a faceted\nflow layout.\n",
                "type": "Basics.Int -> VegaLite.FacetConfig"
            },
            {
                "name": "facoSpacing",
                "comment": " Configuration option for the spacing in pixels between sub-views in a faceted\nview.\n",
                "type": "Basics.Float -> VegaLite.FacetConfig"
            },
            {
                "name": "false",
                "comment": " A false value used for functions that can accept a Boolean literal or a\nreference to something that generates a Boolean value. Convenience function\nequivalent to `boo False`\n",
                "type": "VegaLite.DataValue"
            },
            {
                "name": "fiCompose",
                "comment": " Build up a filtering predicate through logical composition (`and`, `or` etc.).\nFor example, to filter only items selected interactively and that represent ages\nover 65:\n\n    trans =\n        transform\n            << filter\n                (fiCompose\n                    (and (selected \"brush\") (expr \"datum.age > 65\"))\n                )\n\n",
                "type": "VegaLite.BooleanOp -> VegaLite.Filter"
            },
            {
                "name": "fiEqual",
                "comment": " Filter a data stream so that only data in a given field equal to the given\nvalue are used.\n",
                "type": "String.String -> VegaLite.DataValue -> VegaLite.Filter"
            },
            {
                "name": "fiExpr",
                "comment": " Filter a data stream so that only data that satisfy the given predicate\nexpression are used.\n",
                "type": "String.String -> VegaLite.Filter"
            },
            {
                "name": "fiGreaterThan",
                "comment": " Filter a data stream so that only data in a given field greater than the given\nvalue are used.\n",
                "type": "String.String -> VegaLite.DataValue -> VegaLite.Filter"
            },
            {
                "name": "fiGreaterThanEq",
                "comment": " Filter a data stream so that only data in a given field greater than or equal\nto the given value are used.\n",
                "type": "String.String -> VegaLite.DataValue -> VegaLite.Filter"
            },
            {
                "name": "fiLessThan",
                "comment": " Filter a data stream so that only data in a given field less than the given\nvalue are used.\n",
                "type": "String.String -> VegaLite.DataValue -> VegaLite.Filter"
            },
            {
                "name": "fiLessThanEq",
                "comment": " Filter a data stream so that only data in a given field less than or equal to\nthe given value are used.\n",
                "type": "String.String -> VegaLite.DataValue -> VegaLite.Filter"
            },
            {
                "name": "fiOneOf",
                "comment": " Filter a data stream so that only data in a given field contained in the given\nlist of values are used.\n",
                "type": "String.String -> VegaLite.DataValues -> VegaLite.Filter"
            },
            {
                "name": "fiOp",
                "comment": " Convert a filter into a BooleanOp so that it may be used as part of a more\ncomplex Boolean composition.\n\n    trans =\n        transform\n            << filter\n                (fiCompose\n                    (and\n                        (fiValid \"IMDB_Rating\" |> fiOp)\n                        (fiValid \"Rotten_Tomatoes_Rating\" |> fiOp)\n                    )\n                )\n\n",
                "type": "VegaLite.Filter -> VegaLite.BooleanOp"
            },
            {
                "name": "fiOpTrans",
                "comment": " Combine a data transformation operation with a filter before converting into\na Boolean operation. This can be useful when working with dates. For example, the\nfollowing will aggregate a set of dates into years and filter only those years\nbetween 2010 and 2017 inclusive:\n\n    filter\n        (fiRange \"date\" (dtRange [ dtYear 2010 ] [ dtYear 2017 ])\n            |> fiOpTrans (mTimeUnit year)\n            |> fiCompose\n        )\n\nNote the use of [fiCompose](#fiCompose) to convert the Boolean operation back\ninto a [Filter](#Filter).\n\n",
                "type": "VegaLite.MarkChannel -> VegaLite.Filter -> VegaLite.BooleanOp"
            },
            {
                "name": "fiRange",
                "comment": " Filter a data stream so that only data in a given field that are within the\ngiven range are used.\n\n    filter (fiRange \"date\" (dtRange [ dtYear 2006 ] [ dtYear 2016 ]))\n\n",
                "type": "String.String -> VegaLite.FilterRange -> VegaLite.Filter"
            },
            {
                "name": "fiSelection",
                "comment": " Filter a data stream in response to the value of a selection parameter. Useful\nfor creating interactive filtering from a selection.\n",
                "type": "String.String -> VegaLite.Filter"
            },
            {
                "name": "fiSelectionEmpty",
                "comment": " Similar to [fiSelection](#fiSelection) except that an empty selection filters\nout all values.\n",
                "type": "String.String -> VegaLite.Filter"
            },
            {
                "name": "fiValid",
                "comment": " Filter a data stream so that only valid data (i.e. not null or NaN) in a given\nfield are used.\n",
                "type": "String.String -> VegaLite.Filter"
            },
            {
                "name": "fill",
                "comment": " Encode a fill channel. This acts in a similar way to encoding by `color` but\nonly affects the interior of closed shapes. If both `fill` and `color` encodings\nare specified, `fill` takes precedence.\n",
                "type": "List.List VegaLite.MarkChannel -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"
            },
            {
                "name": "fillOpacity",
                "comment": " Encode a fill opacity channel. This acts in a similar way to encoding by `opacity`\nbut only affects the interior of closed shapes. If both `fillOpacity` and `opacity`\nencodings are specified, `fillOpacity` takes precedence.\n",
                "type": "List.List VegaLite.MarkChannel -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"
            },
            {
                "name": "filter",
                "comment": " Apply a filter to a channel or field that specifies which values will 'pass\nthrough' for encoding. A filter can an [expression](https://vega.github.io/vega/docs/expressions/)\nsuch as,\n\n    trans =\n        transform << filter (fiExpr \"datum.y < 50\")\n\nnoting that to refer to a particular data value, prefix the field name with `datum.`.\nAlternatively a boolean filtering function such as [fiOneOf](#fiOneOf) or\n[fiLessThan](#fiLessThan) can be supplied,\n\n    trans =\n        transform << filter (fiLessThan \"y\" (num 50))\n\n",
                "type": "VegaLite.Filter -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"
            },
            {
                "name": "flatten",
                "comment": " Map array-valued fields to a set of individual data objects, one per array entry.\n",
                "type": "List.List String.String -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"
            },
            {
                "name": "flattenAs",
                "comment": " Similar to [flatten](#flatten) but allows the new output fields to be named\n(second parameter).\n",
                "type": "List.List String.String -> List.List String.String -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"
            },
            {
                "name": "foBoo",
                "comment": " Indicate Boolean data type to be parsed when reading input data.\n",
                "type": "VegaLite.DataType"
            },
            {
                "name": "foDate",
                "comment": " Date format for parsing input data using\n[D3's formatting specifiers](https://github.com/d3/d3-time-format#locale_format)\nor left as an empty string for default formatting.\n",
                "type": "String.String -> VegaLite.DataType"
            },
            {
                "name": "foNum",
                "comment": " Indicate numeric data type to be parsed when reading input data.\n",
                "type": "VegaLite.DataType"
            },
            {
                "name": "foUtc",
                "comment": " Similar to [foDate](#foDate) but for UTC format dates.\n",
                "type": "String.String -> VegaLite.DataType"
            },
            {
                "name": "fold",
                "comment": " Perform a _gather_ operation to _tidy_ a table. Collapse multiple data fields\ninto two new data fields: `key` containing the original data field names and `value`\ncontaining the corresponding data values. This performs the same function as\n['gather' in the Tidy Elm package](https://package.elm-lang.org/packages/gicentre/tidy/latest/Tidy#gather)\nand the [pivot\\_longer](https://tidyr.tidyverse.org/dev/articles/pivot.html) /\n[gather](https://tidyr.tidyverse.org/reference/gather.html) operation in the R\ntidyverse . It is the inverse of [pivot](#pivot).\n\n    data =\n        dataFromColumns []\n            << dataColumn \"city\" (strs [ \"Bristol\", \"Sheffield\", \"Glasgow\" ])\n            << dataColumn \"temp2017\" (nums [ 12, 11, 7 ])\n            << dataColumn \"temp2018\" (nums [ 14, 13, 10 ])\n\n    trans =\n        transform\n            << fold [ \"temp2017\", \"temp2018\" ]\n\n    enc =\n        encoding\n            << position X [ pName \"key\", pNominal ]\n            << position Y [ pName \"city\", pNominal ]\n            << size [ mName \"value\", mQuant ]\n\n",
                "type": "List.List String.String -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"
            },
            {
                "name": "foldAs",
                "comment": " Similar to [fold](#fold) but allows the new output `key` and `value` fields\nto be given alternative names.\n",
                "type": "List.List String.String -> String.String -> String.String -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"
            },
            {
                "name": "ftFunction",
                "comment": " Field titles to be displayed as 'SUM(field)', 'YEAR(date)' etc.\n",
                "type": "VegaLite.FieldTitleProperty"
            },
            {
                "name": "ftPlain",
                "comment": " Field titles to be displayed simply by their name without additional text.\n",
                "type": "VegaLite.FieldTitleProperty"
            },
            {
                "name": "ftVerbal",
                "comment": " Field titles to be displayed fully as 'Sum of field', 'Year of date' etc.\n",
                "type": "VegaLite.FieldTitleProperty"
            },
            {
                "name": "fwBold",
                "comment": " Specify a bold font weight.\n",
                "type": "VegaLite.FontWeight"
            },
            {
                "name": "fwBolder",
                "comment": " Specify a bolder font weight.\n",
                "type": "VegaLite.FontWeight"
            },
            {
                "name": "fwExpr",
                "comment": " Expression that evaluates to some font weight such as \"bold\", \"lighter\" or \"600\".\n",
                "type": "String.String -> VegaLite.FontWeight"
            },
            {
                "name": "fwLighter",
                "comment": " Specify a lighter font weight.\n",
                "type": "VegaLite.FontWeight"
            },
            {
                "name": "fwNormal",
                "comment": " Specify a normal font weight.\n",
                "type": "VegaLite.FontWeight"
            },
            {
                "name": "fwValue",
                "comment": " Specify a numeric font weight that should be between 100 (lightest) and 900 (boldest).\n",
                "type": "Basics.Int -> VegaLite.FontWeight"
            },
            {
                "name": "geoFeatureCollection",
                "comment": " Geo features to be used in a `geoshape` specification. Each feature object in\nthis collection can be created with [geometry](#geometry).\n\n    geojson =\n        geoFeatureCollection\n            [ geometry (geoPolygon [ [ ( -3, 59 ), ( -3, 52 ), ( 4, 52 ), ( -3, 59 ) ] ])\n                [ ( \"myRegionName\", str \"Northern region\" ) ]\n            , geometry (geoPolygon [ [ ( -3, 52 ), ( 4, 52 ), ( 4, 45 ), ( -3, 52 ) ] ])\n                [ ( \"myRegionName\", str \"Southern region\" ) ]\n            ]\n\n",
                "type": "List.List VegaLite.Spec -> VegaLite.Spec"
            },
            {
                "name": "geoLine",
                "comment": " Line geometry for programmatically creating GeoShapes. Equivalent to the\n[GeoJson geometry `line` type](https://tools.ietf.org/html/rfc7946#section-3.1).\n",
                "type": "List.List ( Basics.Float, Basics.Float ) -> VegaLite.Geometry"
            },
            {
                "name": "geoLines",
                "comment": " Multi-line geometry for programmatically creating GeoShapes. Equivalent\nto the [GeoJson geometry `multi-line` type](https://tools.ietf.org/html/rfc7946#section-3.1).\n",
                "type": "List.List (List.List ( Basics.Float, Basics.Float )) -> VegaLite.Geometry"
            },
            {
                "name": "geoPoint",
                "comment": " Point geometry for programmatically creating GeoShapes. Equivalent to\nthe [GeoJson geometry `point` type](https://tools.ietf.org/html/rfc7946#section-3.1).\n",
                "type": "Basics.Float -> Basics.Float -> VegaLite.Geometry"
            },
            {
                "name": "geoPoints",
                "comment": " Multi-point geometry for programmatically creating GeoShapes. Equivalent\nto the [GeoJson geometry `multi-point` type](https://tools.ietf.org/html/rfc7946#section-3.1).\n",
                "type": "List.List ( Basics.Float, Basics.Float ) -> VegaLite.Geometry"
            },
            {
                "name": "geoPolygon",
                "comment": " Polygon geometry for programmatically creating GeoShapes. Equivalent\nto the [GeoJson geometry `polygon` type](https://tools.ietf.org/html/rfc7946#section-3.1).\n",
                "type": "List.List (List.List ( Basics.Float, Basics.Float )) -> VegaLite.Geometry"
            },
            {
                "name": "geoPolygons",
                "comment": " Multi-polygon geometry for programmatically creating GeoShapes. Equivalent\nto the [GeoJson geometry `multi-polygon` type](https://tools.ietf.org/html/rfc7946#section-3.1).\n",
                "type": "List.List (List.List (List.List ( Basics.Float, Basics.Float ))) -> VegaLite.Geometry"
            },
            {
                "name": "geometry",
                "comment": " Geometric object to be used in a `geoshape`. The first parameter is\nthe geometric type, the second an optional list of properties to be associated\nwith the object.\n\n      geojson =\n          geometry (geoPolygon [ [ ( -3, 59 ), ( 4, 59 ), ( 4, 52 ), ( -3, 59 ) ] ]) []\n\n",
                "type": "VegaLite.Geometry -> List.List ( String.String, VegaLite.DataValue ) -> VegaLite.Spec"
            },
            {
                "name": "geometryCollection",
                "comment": " Geometry objects to be used in a `geoshape` specification. Each geometry\nobject can be created with [geometry](#geometry).\n\n    geojson =\n        geometryCollection\n            [ geometry (geoPolygon [ [ ( -3, 59 ), ( 4, 59 ), ( 4, 52 ), ( -3, 59 ) ] ]) []\n            , geometry (geoPoint -3.5 55.5) []\n            ]\n\n",
                "type": "List.List VegaLite.Spec -> VegaLite.Spec"
            },
            {
                "name": "geoshape",
                "comment": " [Geoshape](https://vega.github.io/vega-lite/docs/geoshape.html)\ndetermined by geographically referenced coordinates.\n\n    let\n        data =\n            dataFromUrl \"city.json\" [ topojsonFeature \"boroughs\" ]\n    in\n    toVegaLite\n        [ data\n        , geoshape [ maFill \"lightgrey\", maStroke \"white\" ]\n        ]\n\n",
                "type": "List.List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "gnomonic",
                "comment": " A gnomonic map projection.\n",
                "type": "VegaLite.Projection"
            },
            {
                "name": "grExtent",
                "comment": " Set the extent of both major and minor graticule lines. The first parameter\nis a (longitude,latitude) pair defining the minimum extent, the second parameter\nthe maximum extent.\n",
                "type": "( Basics.Float, Basics.Float ) -> ( Basics.Float, Basics.Float ) -> VegaLite.GraticuleProperty"
            },
            {
                "name": "grExtentMajor",
                "comment": " Set the extent of major graticule lines. The first parameter is a\n(longitude,latitude) pair defining the minimum extent, the second parameter\nthe maximum extent.\n",
                "type": "( Basics.Float, Basics.Float ) -> ( Basics.Float, Basics.Float ) -> VegaLite.GraticuleProperty"
            },
            {
                "name": "grExtentMinor",
                "comment": " Set the extent of minor graticule lines. The first parameter is a\n(longitude,latitude) pair defining the minimum extent, the second parameter\nthe maximum extent.\n",
                "type": "( Basics.Float, Basics.Float ) -> ( Basics.Float, Basics.Float ) -> VegaLite.GraticuleProperty"
            },
            {
                "name": "grLinear",
                "comment": " Indicate a linear color gradient. See the\n[Vega-Lite color gradient documentation](https://vega.github.io/vega-lite/docs/types.html#linear-gradient).\n",
                "type": "VegaLite.ColorGradient"
            },
            {
                "name": "grPrecision",
                "comment": " The precision of the graticule in degrees. If unspecified, the default of 2.5\ndegrees is used. Smaller values provide a less stepped appearance of curved lines\nbut take longer to render.\n",
                "type": "Basics.Float -> VegaLite.GraticuleProperty"
            },
            {
                "name": "grR1",
                "comment": " The radius, normalised to [0, 1], of the inner circle for a radial color gradient.\nDefault is 0.\n",
                "type": "Basics.Float -> VegaLite.GradientProperty"
            },
            {
                "name": "grR2",
                "comment": " The radius, normalised to [0, 1], of the outer circle for a radial color gradient.\nDefault is 0.5.\n",
                "type": "Basics.Float -> VegaLite.GradientProperty"
            },
            {
                "name": "grRadial",
                "comment": " Indicate a radial color gradient. See the\n[Vega-Lite color gradient documentation](https://vega.github.io/vega-lite/docs/types.html#radial-gradient).\n",
                "type": "VegaLite.ColorGradient"
            },
            {
                "name": "grStep",
                "comment": " Set the step sizes between all graticule lines. The parameter is a\n(longitude,latitude) pair defining the EW and NS graticule intervals respectively.\n",
                "type": "( Basics.Float, Basics.Float ) -> VegaLite.GraticuleProperty"
            },
            {
                "name": "grStepMajor",
                "comment": " Set the step sizes between major graticule lines. By default, major graticule\nlines extend to both poles, but minor lines stop at ±80 degrees latitude. The parameter\nis a (longitude,latitude) pair defining the EW and NS graticule intervals respectively.\n",
                "type": "( Basics.Float, Basics.Float ) -> VegaLite.GraticuleProperty"
            },
            {
                "name": "grStepMinor",
                "comment": " Set the step sizes between minor graticule lines. By default, major graticule\nlines extend to both poles, but minor lines stop at ±80 degrees latitude. The parameter\nis a (longitude,latitude) pair defining the EW and NS graticule intervals respectively.\n",
                "type": "( Basics.Float, Basics.Float ) -> VegaLite.GraticuleProperty"
            },
            {
                "name": "grStops",
                "comment": " Color interpolation points. Each tuple in the list is a position normalised\n[0, 1] and its associated color.\n",
                "type": "List.List ( Basics.Float, String.String ) -> VegaLite.GradientProperty"
            },
            {
                "name": "grX1",
                "comment": " The x-coordinate, normalised to [0, 1], for the start of a color gradient. If\nthe gradient is linear the default is 0; if radial, it is the x-position of the\ncentre of the inner circle with a default of 0.5.\n",
                "type": "Basics.Float -> VegaLite.GradientProperty"
            },
            {
                "name": "grX2",
                "comment": " The x-coordinate, normalised to [0, 1], for the end of a color gradient. If\nthe gradient is linear the default is 1; if radial, it is the x-position of the\ncentre of the outer circle with a default of 0.5.\n",
                "type": "Basics.Float -> VegaLite.GradientProperty"
            },
            {
                "name": "grY1",
                "comment": " The y-coordinate, normalised to [0, 1], for the start of a color gradient. If\nthe gradient is linear the default is 0; if radial, it is the y-position of the\ncentre of the inner circle with a default of 0.5.\n",
                "type": "Basics.Float -> VegaLite.GradientProperty"
            },
            {
                "name": "grY2",
                "comment": " The y-coordinate, normalised to [0, 1], for the end of a color gradient. If\nthe gradient is linear the default is 1; if radial, it is the y-position of the\ncentre of the outer circle with a default of 0.5.\n",
                "type": "Basics.Float -> VegaLite.GradientProperty"
            },
            {
                "name": "graticule",
                "comment": " Generate a grid of lines of longitude (meridians) and latitude (parallels).\nThe parameter can be used to specify the number and extent of lines, or to use\ndefault values, provide an empty list.\n\n    let\n        proj =\n            projection [ prType orthographic ]\n\n        sphereSpec =\n            asSpec [ sphere, geoshape [ maFill \"aliceblue\" ] ]\n\n        gratSpec =\n            asSpec\n                [ graticule [ grStep ( 5, 5 ) ]\n                , geoshape [ maFilled False, maStrokeWidth 0.3 ]\n                ]\n    in\n    toVegaLite [ proj, layer [ sphereSpec, gratSpec ] ]\n\n",
                "type": "List.List VegaLite.GraticuleProperty -> VegaLite.Data"
            },
            {
                "name": "hAggregate",
                "comment": " Compute some aggregate summary statistics for a field to be encoded with a\nhyperlink channel. The type of aggregation is determined by the given operation\nparameter.\n",
                "type": "VegaLite.Operation -> VegaLite.HyperlinkChannel"
            },
            {
                "name": "hBin",
                "comment": " Discretize numeric values into bins when encoding with a hyperlink channel.\n",
                "type": "List.List VegaLite.BinProperty -> VegaLite.HyperlinkChannel"
            },
            {
                "name": "hBinned",
                "comment": " Indicate that data encoded with a hyperlink channel are already binned.\n",
                "type": "VegaLite.HyperlinkChannel"
            },
            {
                "name": "hConcat",
                "comment": " Specifications to be juxtaposed horizontally in a column layout of views.\n",
                "type": "List.List VegaLite.Spec -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "hCondition",
                "comment": " Make a hyperlink channel encoding conditional on a predicate expression. A predicate\nmight be the result of evaluating a parameter ([prParam](#prParam)) or an expression\n([prTest](#prTest)). The first parameter is the predicate that evaluates to true\nor false; the second the encoding if true, the third the encoding if false.\n",
                "type": "VegaLite.Predicate -> List.List VegaLite.HyperlinkChannel -> List.List VegaLite.HyperlinkChannel -> VegaLite.HyperlinkChannel"
            },
            {
                "name": "hGeo",
                "comment": " Indicate a data field encoded as a hyperlink property is a geo feature.\n",
                "type": "VegaLite.HyperlinkChannel"
            },
            {
                "name": "hName",
                "comment": " Name of field used for encoding with a hyperlink channel.\n",
                "type": "String.String -> VegaLite.HyperlinkChannel"
            },
            {
                "name": "hNominal",
                "comment": " Indicate a data field encoded as a hyperlink or url property is nominal.\nThis is the default data type.\n",
                "type": "VegaLite.HyperlinkChannel"
            },
            {
                "name": "hOrdinal",
                "comment": " Indicate a data field encoded as a hyperlink property is ordinal.\n",
                "type": "VegaLite.HyperlinkChannel"
            },
            {
                "name": "hQuant",
                "comment": " Indicate a data field encoded as a hyperlink or url property is quantitative.\n",
                "type": "VegaLite.HyperlinkChannel"
            },
            {
                "name": "hRepeat",
                "comment": " Reference in a hyperlink channel to a field name generated by [repeatFlow](#repeatFlow)\nor [repeat](#repeat). The parameter identifies whether reference is being made to\nfields that are to be arranged in columns, in rows or a with a flow layout.\n",
                "type": "VegaLite.Arrangement -> VegaLite.HyperlinkChannel"
            },
            {
                "name": "hStr",
                "comment": " Literal string value when encoding with a hyperlink channel.\n",
                "type": "String.String -> VegaLite.HyperlinkChannel"
            },
            {
                "name": "hTemporal",
                "comment": " Indicate a data field encoded as a hyperlink or url property is temporal.\n",
                "type": "VegaLite.HyperlinkChannel"
            },
            {
                "name": "hTimeUnit",
                "comment": " Time unit aggregation of field values when encoding with a hyperlink channel.\n",
                "type": "VegaLite.TimeUnit -> VegaLite.HyperlinkChannel"
            },
            {
                "name": "haCenter",
                "comment": " Center horizontal text alignment.\n",
                "type": "VegaLite.HAlign"
            },
            {
                "name": "haExpr",
                "comment": " Expression that evaluates to some text alignment such as \"left\", \"right\" or\n\"center\". Can be used, for example, to align text to the left or right depending\non whether data values are positive or negative:\n\n    maAlign (haExpr \"datum.x < 0 ? 'right' : 'left'\")\n\n",
                "type": "String.String -> VegaLite.HAlign"
            },
            {
                "name": "haLeft",
                "comment": " Left horizontal text alignment.\n",
                "type": "VegaLite.HAlign"
            },
            {
                "name": "haRight",
                "comment": " Right horizontal text alignment.\n",
                "type": "VegaLite.HAlign"
            },
            {
                "name": "hcl",
                "comment": " HCL color interpolation for continuous color scales.\n",
                "type": "VegaLite.CInterpolate"
            },
            {
                "name": "hclLong",
                "comment": " HCL color interpolation in polar coordinate space for continuous color scales.\n",
                "type": "VegaLite.CInterpolate"
            },
            {
                "name": "hdFormat",
                "comment": " [Formatting pattern](https://vega.github.io/vega-lite/docs/format.html) for\nfacet header (title) values. To distinguish between formatting as numeric values\nand data/time values, additionally use [hdFormatAsNum](#hdFormatAsNum),\n[hdFormatAsTemporal](#hdFormatAsTemporal) or [hdFormatAsCustom](#hdFormatAsCustom).\n",
                "type": "String.String -> VegaLite.HeaderProperty"
            },
            {
                "name": "hdFormatAsCustom",
                "comment": " Indicate that facet headers should be formatted with a registered custom formatter\nwith the given name. See [how to register a Vega-Lite custom formatter](https://vega.github.io/vega-lite/usage/compile.html#format-type).\n",
                "type": "String.String -> VegaLite.HeaderProperty"
            },
            {
                "name": "hdFormatAsNum",
                "comment": " Indicate that facet headers should be formatted as numbers. To control the\nprecise numeric format, additionally use [hdFormat](#hdFormat) providing a\n[d3 numeric format string](https://github.com/d3/d3-format#locale_format).\n",
                "type": "VegaLite.HeaderProperty"
            },
            {
                "name": "hdFormatAsTemporal",
                "comment": " Indicate that facet headers should be formatted as dates/times. To control the\nprecise temporal format, additionally use [hdFormat](#hdFormat) providing a\n[d3 date/time format string](https://github.com/d3/d3-time-format#locale_format).\n",
                "type": "VegaLite.HeaderProperty"
            },
            {
                "name": "hdLabelAlign",
                "comment": " Horizontal alignment of header labels. A 'label' is the\ntitle for each sub-plot in a faceted view.\n",
                "type": "VegaLite.HAlign -> VegaLite.HeaderProperty"
            },
            {
                "name": "hdLabelAnchor",
                "comment": " Anchor position of header labels. A 'label' is the title for each sub-plot\nin a faceted view.\n",
                "type": "VegaLite.Anchor -> VegaLite.HeaderProperty"
            },
            {
                "name": "hdLabelAngle",
                "comment": " Header label rotation angle (in degrees from horizontal) for a faceted view.\nA 'label' is the title for each sub-plot in a faceted view.\n",
                "type": "Basics.Float -> VegaLite.HeaderProperty"
            },
            {
                "name": "hdLabelBaseline",
                "comment": " Vertical alignment of header labels.\n",
                "type": "VegaLite.VAlign -> VegaLite.HeaderProperty"
            },
            {
                "name": "hdLabelColor",
                "comment": " Header label text color for a faceted view.\n",
                "type": "String.String -> VegaLite.HeaderProperty"
            },
            {
                "name": "hdLabelExpr",
                "comment": " [Expression](https://vega.github.io/vega/docs/expressions/) for customising\nheader labels. Can reference `datum.value` and `datum.label` for access to the\nunderlying data values and label text respectively.\n",
                "type": "String.String -> VegaLite.HeaderProperty"
            },
            {
                "name": "hdLabelFont",
                "comment": " Header label font in a faceted view.\n",
                "type": "String.String -> VegaLite.HeaderProperty"
            },
            {
                "name": "hdLabelFontSize",
                "comment": " Header label font size in a faceted view.\n",
                "type": "Basics.Float -> VegaLite.HeaderProperty"
            },
            {
                "name": "hdLabelFontStyle",
                "comment": " Header label font style (e.g. `italic`) in a faceted view.\n",
                "type": "String.String -> VegaLite.HeaderProperty"
            },
            {
                "name": "hdLabelFontWeight",
                "comment": " Header label font weight in a faceted view.\n",
                "type": "VegaLite.FontWeight -> VegaLite.HeaderProperty"
            },
            {
                "name": "hdLabelLimit",
                "comment": " Maximum length of a header label in a faceted view.\n",
                "type": "Basics.Float -> VegaLite.HeaderProperty"
            },
            {
                "name": "hdLabelLineHeight",
                "comment": " Header label line height in a faceted view (useful for multi-line labels).\n",
                "type": "Basics.Float -> VegaLite.HeaderProperty"
            },
            {
                "name": "hdLabelOrient",
                "comment": " The position of a header label relative to a sub-plot. A 'label' is the title\nfor each sub-plot in a faceted view.\n",
                "type": "VegaLite.Side -> VegaLite.HeaderProperty"
            },
            {
                "name": "hdLabelPadding",
                "comment": " Spacing in pixels between facet labels and the main plot area.\n",
                "type": "Basics.Float -> VegaLite.HeaderProperty"
            },
            {
                "name": "hdLabels",
                "comment": " Whether or not labels in a faceted view are displayed.\n",
                "type": "Basics.Bool -> VegaLite.HeaderProperty"
            },
            {
                "name": "hdNumExpr",
                "comment": " Provide an [expression](https://vega.github.io/vega/docs/expressions/) to a\nfacet header property function requiring a numeric value. This can be used for interactive\nparameterisation when an expression is bound to an input element. For example,\n\n    ps =\n        params\n            << param \"size\"\n                [ paValue (num 12)\n                , paBind (ipRange [ inMax 32 ])\n                ]\n\n    enc =\n        encoding\n            << column\n                [ fName \"country\"\n                , fHeader [ hdNumExpr \"size\" hdLabelFontSize ]\n                ]\n\n",
                "type": "String.String -> (number -> VegaLite.HeaderProperty) -> VegaLite.HeaderProperty"
            },
            {
                "name": "hdOrient",
                "comment": " The relative position of both a header label and title relative to a sub-plot\n(shortcut instead of specifying [hdLabelOrient](#hdLabelOrient) and [hdTitleOrient](#hdTitleOrient)\nseparately).\n",
                "type": "VegaLite.Side -> VegaLite.HeaderProperty"
            },
            {
                "name": "hdStrExpr",
                "comment": " Provide an [expression](https://vega.github.io/vega/docs/expressions/) to\na facet header property function requiring a string value. This can be used to provide an\ninteractive parameterisation of a header property when an expression is bound to an\ninput element. For example,\n\n    ps =\n        params\n            << param \"color\"\n                [ paValue (str \"black\")\n                , paBind (ipColor [])\n                ]\n\n    enc =\n        encoding\n            << column\n                [ fName \"country\"\n                , fHeader [ hdStrExpr \"color\" hdLabelColor ]\n                ]\n\n",
                "type": "String.String -> (String.String -> VegaLite.HeaderProperty) -> VegaLite.HeaderProperty"
            },
            {
                "name": "hdTitle",
                "comment": " Header title in a faceted view. A 'title' is the overall title describing the\ncollection of faceted plots. For multi-line titles, insert `\\n` at each line break\nor use a `\"\"\"` multi-line string.\n",
                "type": "String.String -> VegaLite.HeaderProperty"
            },
            {
                "name": "hdTitleAlign",
                "comment": " Horizontal alignment of header title in a faceted view.\n",
                "type": "VegaLite.HAlign -> VegaLite.HeaderProperty"
            },
            {
                "name": "hdTitleAnchor",
                "comment": " Anchor position of a header title in a faceted view.\n",
                "type": "VegaLite.Anchor -> VegaLite.HeaderProperty"
            },
            {
                "name": "hdTitleAngle",
                "comment": " Text angle of a header title in a faceted view (degrees from horizontal).\n",
                "type": "Basics.Float -> VegaLite.HeaderProperty"
            },
            {
                "name": "hdTitleBaseline",
                "comment": " Vertical alignment of a header title in a faceted view.\n",
                "type": "VegaLite.VAlign -> VegaLite.HeaderProperty"
            },
            {
                "name": "hdTitleColor",
                "comment": " Text color of a header title in a faceted view.\n",
                "type": "String.String -> VegaLite.HeaderProperty"
            },
            {
                "name": "hdTitleFont",
                "comment": " Title font in a faceted view.\n",
                "type": "String.String -> VegaLite.HeaderProperty"
            },
            {
                "name": "hdTitleFontSize",
                "comment": " Title font size in a faceted view.\n",
                "type": "Basics.Float -> VegaLite.HeaderProperty"
            },
            {
                "name": "hdTitleFontStyle",
                "comment": " Header title font style (e.g. `italic`) in a faceted view.\n",
                "type": "String.String -> VegaLite.HeaderProperty"
            },
            {
                "name": "hdTitleFontWeight",
                "comment": " Title font weight in a faceted view.\n",
                "type": "VegaLite.FontWeight -> VegaLite.HeaderProperty"
            },
            {
                "name": "hdTitleLimit",
                "comment": " Maximum length of a header title in a faceted view.\n",
                "type": "Basics.Float -> VegaLite.HeaderProperty"
            },
            {
                "name": "hdTitleLineHeight",
                "comment": " Header title line height in a faceted view (useful for multi-line titles).\n",
                "type": "Basics.Float -> VegaLite.HeaderProperty"
            },
            {
                "name": "hdTitleOrient",
                "comment": " The position of a header title relative to a group of sub-plots in a faceted\nview.\n",
                "type": "VegaLite.Side -> VegaLite.HeaderProperty"
            },
            {
                "name": "hdTitlePadding",
                "comment": " Spacing in pixels between the main facet title and labels.\n",
                "type": "Basics.Float -> VegaLite.HeaderProperty"
            },
            {
                "name": "height",
                "comment": " Override the default height of the visualization. If not specified the height\nwill be calculated based on the content of the visualization. How the content is\nsized relative to this height specification can be customised with [autosize](#autosize).\n",
                "type": "Basics.Float -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "heightOfContainer",
                "comment": " Set the height of the view to be that of the surrounding container. Allows\nresponsive sizing to be specified.\n",
                "type": "( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "heightStep",
                "comment": " Set the height of the discrete y-field (e.g. individual bars in a horizontal\nbar chart). The total height is then calculated based on the number of discrete\nfields (e.g. bars).\n\n    toVegaLite [ heightStep 17, data [], enc [], bar [] ]\n\n",
                "type": "Basics.Float -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "heightStepOffset",
                "comment": " Set the height of the offset-grouped discrete y-fields. The total height is then\ncalculated based on the number of offset discrete fields (e.g. groups of bars with\n`position YOffset` applied).\n",
                "type": "Basics.Float -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "hours",
                "comment": " Hour of the day time unit used for discretizing temporal data.\n",
                "type": "VegaLite.TimeUnit"
            },
            {
                "name": "hoursMinutes",
                "comment": " Hours and minutes time unit used for discretizing temporal data.\n",
                "type": "VegaLite.TimeUnit"
            },
            {
                "name": "hoursMinutesSeconds",
                "comment": " Hours, minutes and seconds time unit used for discretizing temporal data.\n",
                "type": "VegaLite.TimeUnit"
            },
            {
                "name": "hsl",
                "comment": " HSL color interpolation for continuous color scales.\n",
                "type": "VegaLite.CInterpolate"
            },
            {
                "name": "hslLong",
                "comment": " HSL color interpolation in polar coordinate space for continuous color scales.\n",
                "type": "VegaLite.CInterpolate"
            },
            {
                "name": "hyperlink",
                "comment": " Encode a hyperlink channel. The first parameter is a list of hyperlink channel\nproperties that characterise the hyperlinking such as the destination URL and cursor\ntype.\n\n    encData =\n        encoding\n            << hyperlink [ hName \"url\", hNominal ]\n\n    encLiteral =\n        encoding\n            << hyperlink [ hStr \"http://www.imdb.com\" ]\n\n",
                "type": "List.List VegaLite.HyperlinkChannel -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"
            },
            {
                "name": "identityProjection",
                "comment": " An 'identity' projection where longitude is projected directly to the x position\nand latitude to the y position. Can also reflect either of the coordinates by\nspecifying [prReflectX](#prReflectX) / [prReflectY](#prReflectY) in the list of\nprojection properties.\n",
                "type": "VegaLite.Projection"
            },
            {
                "name": "imFrame",
                "comment": " 1d window over which data imputation values are generated. The two\nparameters should either be `Just` a number indicating the offset from the current\ndata object, or `Nothing` to indicate unbounded rows preceding or following the\ncurrent data object.\n",
                "type": "Maybe.Maybe Basics.Int -> Maybe.Maybe Basics.Int -> VegaLite.ImputeProperty"
            },
            {
                "name": "imGroupBy",
                "comment": " Allow imputing of missing values on a per-group basis. For use with the impute\ntransform only and not a channel encoding.\n",
                "type": "List.List String.String -> VegaLite.ImputeProperty"
            },
            {
                "name": "imKeyValSequence",
                "comment": " Key values to be considered for imputation as a sequence of numbers between\na start (first parameter), to less than an end (second parameter) in steps of\nthe third parameter.\n",
                "type": "Basics.Float -> Basics.Float -> Basics.Float -> VegaLite.ImputeProperty"
            },
            {
                "name": "imKeyVals",
                "comment": " Key values to be considered for imputation.\n",
                "type": "VegaLite.DataValues -> VegaLite.ImputeProperty"
            },
            {
                "name": "imMax",
                "comment": " Use maximum of values when imputing missing data.\n",
                "type": "VegaLite.ImMethod"
            },
            {
                "name": "imMean",
                "comment": " Use mean of values when imputing missing data.\n",
                "type": "VegaLite.ImMethod"
            },
            {
                "name": "imMedian",
                "comment": " Use median of values when imputing missing data.\n",
                "type": "VegaLite.ImMethod"
            },
            {
                "name": "imMethod",
                "comment": " Imputation method to use when replacing values.\n",
                "type": "VegaLite.ImMethod -> VegaLite.ImputeProperty"
            },
            {
                "name": "imMin",
                "comment": " Use maximum of values when imputing missing data.\n",
                "type": "VegaLite.ImMethod"
            },
            {
                "name": "imNewValue",
                "comment": " New value to use when imputing with [imValue](#imValue).\n",
                "type": "VegaLite.DataValue -> VegaLite.ImputeProperty"
            },
            {
                "name": "imValue",
                "comment": " Use field value when imputing missing data.\n",
                "type": "VegaLite.ImMethod"
            },
            {
                "name": "image",
                "comment": " [Image mark](https://vega.github.io/vega-lite/docs/image.html) for displaying\nan image. The parameter is a list of standard mark properties for customising the\nimage. The image files to be displayed should be specified via the [url](#url)\nchannel. Normally, the width and height of the image should be specified with\n[maWidth](#maWidth) and [maHeight](#maHeight).\n\n    let\n        data =\n            dataFromColumns []\n                << dataColumn \"x\" (nums [ 0.5, 1.5, 2.5 ])\n                << dataColumn \"y\" (nums [ 0.5, 1.5, 2.5 ])\n\n        enc =\n            encoding\n                << position X [ pName \"x\", pQuant ]\n                << position Y [ pName \"y\", pQuant ]\n                << url [ hStr \"myImage.png\" ]\n    in\n    toVegaLite [ data [], enc [], image [ maWidth 50, maHeight 25 ] ]\n\nAlternatively, data-driven images can be used by referencing a data field containing\nimage URLs.\n\n    let\n        data =\n            dataFromColumns []\n                << dataColumn \"x\" (nums [ 0.5, 1.5, 2.5 ])\n                << dataColumn \"y\" (nums [ 0.5, 1.5, 2.5 ])\n                << dataColumn \"img\" (strs [ \"img1.png\", \"img2.png\", \"img3.png\" ])\n\n        enc =\n            encoding\n                << position X [ pName \"x\", pQuant ]\n                << position Y [ pName \"y\", pQuant ]\n                << url [ hName \"img\", hNominal ]\n    in\n    toVegaLite [ data [], enc [], image [ maWidth 30, maHeight 30 ] ]\n\n",
                "type": "List.List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "impute",
                "comment": " Impute missing data values as a data transform. The first parameter is the\ndata field to process; the second the key field to uniquely identify data objects\nwithin a group; the third customisable options.\n\nFor example, to impute the missing value of `b` with the mean of existing `b` values,\nwhen `a` is 30 and its color group (`c`) is 1:\n\n    let\n        data =\n            dataFromColumns []\n                << dataColumn \"a\" (nums [ 0, 0, 10, 10, 20, 20, 30 ])\n                << dataColumn \"b\" (nums [ 28, 91, 43, 55, 81, 53, 19 ])\n                << dataColumn \"c\" (nums [ 0, 1, 0, 1, 0, 1, 0 ])\n\n        trans =\n            transform\n                << impute \"b\" \"a\" [ imMethod imMean, imGroupBy [ \"c\" ] ]\n\n        enc =\n            encoding\n                << position X [ pName \"a\", pQuant ]\n                << position Y [ pName \"b\", pQuant ]\n                << color [ mName \"c\", mNominal ]\n    in\n    toVegaLite [ data [], trans [], enc [], line [] ]\n\n",
                "type": "String.String -> String.String -> List.List VegaLite.ImputeProperty -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"
            },
            {
                "name": "inDataOptions",
                "comment": " Options for a radio or select input element. Similar to [inDatumOptions](#inDatumOptions)\nexcept that each option can be a list of data values. For example,\n\n    inDataOptions [ nums [ 2, 3, 5, 7, 11, 13 ], boos [ True, False ] ]\n\n",
                "type": "List.List VegaLite.DataValues -> VegaLite.InputProperty"
            },
            {
                "name": "inDatumOptions",
                "comment": " Options for a radio or select input element. Unlike [inOptions](#inOptions),\nthis allows for mixed data types to be listed. For example, to create a list of\nnumbers and boolean values:\n\n    inDatumOptions [ num 2, num 3, boo False, boo True ]\n\n",
                "type": "List.List VegaLite.DataValue -> VegaLite.InputProperty"
            },
            {
                "name": "inDebounce",
                "comment": " Delay to introduce when processing input events in order to avoid unnecessary\nevent broadcasting.\n",
                "type": "Basics.Float -> VegaLite.InputProperty"
            },
            {
                "name": "inElement",
                "comment": " CSS selector indicating the parent element to which an input element should\nbe added. Allows the option of the input element to be outside the visualization\ncontainer.\n",
                "type": "String.String -> VegaLite.InputProperty"
            },
            {
                "name": "inMax",
                "comment": " Maximum slider value for a range input element.\n",
                "type": "Basics.Float -> VegaLite.InputProperty"
            },
            {
                "name": "inMin",
                "comment": " Minimum slider value for a range input element.\n",
                "type": "Basics.Float -> VegaLite.InputProperty"
            },
            {
                "name": "inName",
                "comment": " Custom label for a radio or select input element.\n",
                "type": "String.String -> VegaLite.InputProperty"
            },
            {
                "name": "inOptions",
                "comment": " Options for a radio or select input element. Assumes all options are strings.\nFor other types, consider [inDatumOptions](#inDatumOptions) or [inDataOptions](#inDataOptions).\n",
                "type": "List.List String.String -> VegaLite.InputProperty"
            },
            {
                "name": "inPlaceholder",
                "comment": " Initial place-holding text for input elements such as text fields.\n",
                "type": "String.String -> VegaLite.InputProperty"
            },
            {
                "name": "inStep",
                "comment": " Minimum input element range slider increment.\n",
                "type": "Basics.Float -> VegaLite.InputProperty"
            },
            {
                "name": "ipCheckbox",
                "comment": " Checkbox input element that can bound to a named parameter.\n",
                "type": "List.List VegaLite.InputProperty -> VegaLite.PBinding"
            },
            {
                "name": "ipColor",
                "comment": " Color input element that can bound to a named parameter.\n",
                "type": "List.List VegaLite.InputProperty -> VegaLite.PBinding"
            },
            {
                "name": "ipDate",
                "comment": " Date input element that can bound to a named parameter.\n",
                "type": "List.List VegaLite.InputProperty -> VegaLite.PBinding"
            },
            {
                "name": "ipDateTimeLocal",
                "comment": " Local time input element that can bound to a named parameter.\n",
                "type": "List.List VegaLite.InputProperty -> VegaLite.PBinding"
            },
            {
                "name": "ipMonth",
                "comment": " Month input element that can bound to a named parameter.\n",
                "type": "List.List VegaLite.InputProperty -> VegaLite.PBinding"
            },
            {
                "name": "ipNumber",
                "comment": " Number input element that can bound to a named parameter.\n",
                "type": "List.List VegaLite.InputProperty -> VegaLite.PBinding"
            },
            {
                "name": "ipRadio",
                "comment": " Radio box input element that can bound to a named parameter.\n",
                "type": "List.List VegaLite.InputProperty -> VegaLite.PBinding"
            },
            {
                "name": "ipRange",
                "comment": " Range slider input element that can bound to a named parameter.\n",
                "type": "List.List VegaLite.InputProperty -> VegaLite.PBinding"
            },
            {
                "name": "ipSelect",
                "comment": " Select input element that can bound to a named parameter.\n",
                "type": "List.List VegaLite.InputProperty -> VegaLite.PBinding"
            },
            {
                "name": "ipTel",
                "comment": " Telephone number input element that can bound to a named parameter.\n",
                "type": "List.List VegaLite.InputProperty -> VegaLite.PBinding"
            },
            {
                "name": "ipText",
                "comment": " Text input element that can bound to a named parameter.\n",
                "type": "List.List VegaLite.InputProperty -> VegaLite.PBinding"
            },
            {
                "name": "ipTime",
                "comment": " Time input element that can bound to a named parameter.\n",
                "type": "List.List VegaLite.InputProperty -> VegaLite.PBinding"
            },
            {
                "name": "ipWeek",
                "comment": " Week input element that can bound to a named parameter.\n",
                "type": "List.List VegaLite.InputProperty -> VegaLite.PBinding"
            },
            {
                "name": "joBevel",
                "comment": " Bevelled stroke join.\n",
                "type": "VegaLite.StrokeJoin"
            },
            {
                "name": "joExpr",
                "comment": " Expression that evaluates to some stroke join style such as \"bevel\", \"miter\"\nor \"round\".\n",
                "type": "String.String -> VegaLite.StrokeJoin"
            },
            {
                "name": "joMiter",
                "comment": " Mitred stroke join.\n",
                "type": "VegaLite.StrokeJoin"
            },
            {
                "name": "joRound",
                "comment": " Rounded stroke join.\n",
                "type": "VegaLite.StrokeJoin"
            },
            {
                "name": "joinAggregate",
                "comment": " Aggregation transformations to be used when encoding channels. Unlike\n[aggregate](#aggregate), this transformation joins the results to the input data.\nCan be helpful for creating derived values that combine raw data with some aggregate\nmeasure, such as percentages of group totals. The first parameter is a list\nof the named aggregation operations to apply. The second is a list of possible\nwindow aggregate field properties, such as a field to group by when aggregating.\nThe third parameter is a list of transformations to which this is added.\n\n    transform\n        << joinAggregate [ opAs opMean \"rating\" \"avYearRating\" ]\n            [ wiGroupBy [ \"year\" ] ]\n        << filter (fiExpr \"(datum.rating - datum.avYearRating) > 3\")\n\nFor details, see the\n[Vega-Lite join aggregate documentation](https://vega.github.io/vega-lite/docs/joinaggregate.html)\n\n",
                "type": "List.List VegaLite.Spec -> List.List VegaLite.WindowProperty -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"
            },
            {
                "name": "jsonProperty",
                "comment": " Property to be extracted from some JSON when it has some surrounding structure.\ne.g., specifying the property `values.features` is equivalent to retrieving\n`json.values.features` from a JSON object with a custom delimiter.\n",
                "type": "String.String -> VegaLite.Format"
            },
            {
                "name": "jsonToSpec",
                "comment": " Convert a string representing some JSON into a Spec. Useful when combined\nwith [dataFromJson](#dataFromJson) to compactly import inline JSON as data. For\nexample,\n\n    data =\n        jsonToSpec\n            \"\"\"\n            {\n                \"Revenue\" : [ 150, 225, 300 ],\n                \"Profit\" : [ 20, 25, 30 ],\n                \"Order size\" : [ 350, 500, 600 ],\n                \"New customers\" : [ 1400, 2000, 2500 ],\n                \"Satisfaction\" : [ 3.5, 4.25, 5 ]\n            }\n            \"\"\"\n            |> dataFromJson\n\nThis can also be used to store a full visualization specification from a JSON object.\nBut note this is not type-safe – if the JSON is not well-formed, a null value is returned.\n\n",
                "type": "String.String -> VegaLite.Spec"
            },
            {
                "name": "kGeo",
                "comment": " Indicate a data field encoded as a key channel property stores geo-features.\n",
                "type": "VegaLite.KeyChannel"
            },
            {
                "name": "kName",
                "comment": " Name of field used for encoding with a key channel.\n",
                "type": "String.String -> VegaLite.KeyChannel"
            },
            {
                "name": "kNominal",
                "comment": " Indicate a data field encoded as a key channel property is nominal. This is\nthe default data type.\n",
                "type": "VegaLite.KeyChannel"
            },
            {
                "name": "kOrdinal",
                "comment": " Indicate a data field encoded as a key channel property is ordinal.\n",
                "type": "VegaLite.KeyChannel"
            },
            {
                "name": "kQuant",
                "comment": " Indicate a data field encoded as a key channel property is quantitative.\n",
                "type": "VegaLite.KeyChannel"
            },
            {
                "name": "kTemporal",
                "comment": " Indicate a data field encoded as a key channel property is temporal.\n",
                "type": "VegaLite.KeyChannel"
            },
            {
                "name": "key",
                "comment": " Encode a key channel for use with the [Vega View API](https://vega.github.io/vega/docs/api/view/#data).\nThe first parameter identifies a list of key encoding options (just the name of\nthe data field to use as a unique key for data binding and its type).\n",
                "type": "List.List VegaLite.KeyChannel -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"
            },
            {
                "name": "lab",
                "comment": " Lab color interpolation for continuous color scales.\n",
                "type": "VegaLite.CInterpolate"
            },
            {
                "name": "layer",
                "comment": " Assign a list of specifications to superposed layers in a visualization.\nFor example, adding text annotations to a bar chart:\n\n    let\n        data =\n            dataFromColumns []\n                << dataColumn \"x\" (nums [ 1, 2, 3, 4, 5 ])\n                << dataColumn \"a\" (nums [ 28, 91, 43, 55, 81 ])\n\n        enc =\n            encoding\n                << position X [ pName \"x\", pOrdinal ]\n                << position Y [ pName \"a\", pQuant ]\n                << text [ tName \"a\", tNominal ]\n    in\n    toVegaLite\n        [ data []\n        , enc []\n        , layer\n            [ asSpec [ bar [] ]\n            , asSpec [ textMark [ maDy -8 ], enc [] ]\n            ]\n        ]\n\n",
                "type": "List.List VegaLite.Spec -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "layerFields",
                "comment": " Create a list of fields to use in set of repeated layers. The list of fields\nnamed here can be referenced in an encoding with `pRepeat layer`, `mRepeat layer` etc.\n",
                "type": "List.List String.String -> VegaLite.RepeatFields"
            },
            {
                "name": "leAria",
                "comment": " [ARIA](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA) properties\nfor providing accessible SVG output associated with a legend. If an empty list is\nprovided, ARIA tagging will be switched off.\n",
                "type": "List.List VegaLite.Aria -> VegaLite.LegendProperty"
            },
            {
                "name": "leClipHeight",
                "comment": " Limit height of legend entries.\n",
                "type": "Basics.Float -> VegaLite.LegendProperty"
            },
            {
                "name": "leColumnPadding",
                "comment": " Horizontal padding between symbol legend entries.\n",
                "type": "Basics.Float -> VegaLite.LegendProperty"
            },
            {
                "name": "leColumns",
                "comment": " Number of columns in which to arrange symbol legend entries.\n",
                "type": "Basics.Float -> VegaLite.LegendProperty"
            },
            {
                "name": "leCornerRadius",
                "comment": " Legend corner radius.\n",
                "type": "Basics.Float -> VegaLite.LegendProperty"
            },
            {
                "name": "leDirection",
                "comment": " Direction of a legend.\n",
                "type": "VegaLite.MarkOrientation -> VegaLite.LegendProperty"
            },
            {
                "name": "leFillColor",
                "comment": " Legend background color.\n",
                "type": "String.String -> VegaLite.LegendProperty"
            },
            {
                "name": "leFormat",
                "comment": " [Formatting pattern](https://vega.github.io/vega-lite/docs/format.html) for\nlegend values. To distinguish between formatting as numeric values and data/time values,\nadditionally use [leFormatAsNum](#leFormatAsNum), [leFormatAsTemporal](#leFormatAsTemporal)\nor [leFormatAsCustom](#leFormatAsCustom).\n",
                "type": "String.String -> VegaLite.LegendProperty"
            },
            {
                "name": "leFormatAsCustom",
                "comment": " Indicate that legend labels should be formatted with a registered custom formatter\nwith the given name. See [how to register a Vega-Lite custom formatter](https://vega.github.io/vega-lite/usage/compile.html#format-type).\n",
                "type": "String.String -> VegaLite.LegendProperty"
            },
            {
                "name": "leFormatAsNum",
                "comment": " Indicate that legend labels should be formatted as numbers. To control the precise\nnumeric format, additionally use [leFormat](#leFormat) providing a\n[d3 numeric format string](https://github.com/d3/d3-format#locale_format).\n",
                "type": "VegaLite.LegendProperty"
            },
            {
                "name": "leFormatAsTemporal",
                "comment": " Indicate that legend labels should be formatted as dates/times. To control the\nprecise temporal format, additionally use [leFormat](#leFormat) providing a\n[d3 date/time format string](https://github.com/d3/d3-time-format#locale_format).\n",
                "type": "VegaLite.LegendProperty"
            },
            {
                "name": "leGradient",
                "comment": " A gradient legend for continuous quantitative data.\n",
                "type": "VegaLite.Legend"
            },
            {
                "name": "leGradientLength",
                "comment": " Length in pixels of the primary axis of a color ramp legend.\n",
                "type": "Basics.Float -> VegaLite.LegendProperty"
            },
            {
                "name": "leGradientOpacity",
                "comment": " Opacity of a color ramp legend.\n",
                "type": "Basics.Float -> VegaLite.LegendProperty"
            },
            {
                "name": "leGradientStrokeColor",
                "comment": " Color for strokes in a color ramp legend.\n",
                "type": "String.String -> VegaLite.LegendProperty"
            },
            {
                "name": "leGradientStrokeWidth",
                "comment": " Width for strokes in a color ramp legend.\n",
                "type": "Basics.Float -> VegaLite.LegendProperty"
            },
            {
                "name": "leGradientThickness",
                "comment": " Thickness in pixels of a color ramp legend.\n",
                "type": "Basics.Float -> VegaLite.LegendProperty"
            },
            {
                "name": "leGridAlign",
                "comment": " Alignment to apply to symbol legends rows and columns.\n",
                "type": "VegaLite.CompositionAlignment -> VegaLite.LegendProperty"
            },
            {
                "name": "leLabelAlign",
                "comment": " Horizontal alignment of legend labels.\n",
                "type": "VegaLite.HAlign -> VegaLite.LegendProperty"
            },
            {
                "name": "leLabelBaseline",
                "comment": " Vertical alignment of legend labels.\n",
                "type": "VegaLite.VAlign -> VegaLite.LegendProperty"
            },
            {
                "name": "leLabelColor",
                "comment": " Color for legend labels.\n",
                "type": "String.String -> VegaLite.LegendProperty"
            },
            {
                "name": "leLabelExpr",
                "comment": " An expression to generate legend labels. The parameter is a valid\n[Vega expression](https://vega.github.io/vega/docs/expressions/). Can reference\n`datum.value` and `datum.label` for access to the underlying data values and\ndefault label text respectively. For example, to show just the first word of\neach legend category:\n\n    mLegend [ leLabelExpr \"split(datum.value,' ')[0]\" ]\n\n",
                "type": "String.String -> VegaLite.LegendProperty"
            },
            {
                "name": "leLabelFont",
                "comment": " Font for legend labels.\n",
                "type": "String.String -> VegaLite.LegendProperty"
            },
            {
                "name": "leLabelFontSize",
                "comment": " Font size legend labels.\n",
                "type": "Basics.Float -> VegaLite.LegendProperty"
            },
            {
                "name": "leLabelFontStyle",
                "comment": " Font style (e.g italic) for legend labels.\n",
                "type": "String.String -> VegaLite.LegendProperty"
            },
            {
                "name": "leLabelFontWeight",
                "comment": " Font weight for legend labels.\n",
                "type": "VegaLite.FontWeight -> VegaLite.LegendProperty"
            },
            {
                "name": "leLabelLimit",
                "comment": " Maximum width for legend labels in pixel units.\n",
                "type": "Basics.Float -> VegaLite.LegendProperty"
            },
            {
                "name": "leLabelOffset",
                "comment": " Offset for legend labels.\n",
                "type": "Basics.Float -> VegaLite.LegendProperty"
            },
            {
                "name": "leLabelOverlap",
                "comment": " Strategy for resolving overlapping legend labels.\n",
                "type": "VegaLite.OverlapStrategy -> VegaLite.LegendProperty"
            },
            {
                "name": "leNumExpr",
                "comment": " Provide an [expression](https://vega.github.io/vega/docs/expressions/) to a\nlegend property function requiring a numeric value. This can be used for interactive\nparameterisation when an expression is bound to an input element. For example,\n\n    ps =\n        params\n            << param \"xPos\"\n                [ paValue (num 0)\n                , paBind (ipRange [ inMax 100 ])\n                ]\n\n    enc =\n        encoding\n            << color\n                [ mName \"animal\"\n                , mLegend [ leNumExpr \"xPos\" leX ]\n                ]\n\n",
                "type": "String.String -> (number -> VegaLite.LegendProperty) -> VegaLite.LegendProperty"
            },
            {
                "name": "leNumsExpr",
                "comment": " Provide an [expression](https://vega.github.io/vega/docs/expressions/) to\na legend property function requiring a list of numbers (for dash styles). This can\nbe used to provide an interactive parameterisation of an axis dash property when\nan expression is bound to an input element. For example,\n\n    ps =\n        params\n            << param \"dashStyle\"\n                [ paValue nums []\n                , paBind (ipSelect [ inDataOptions [ nums [ 2, 2 ], nums [ 8, 8 ] ] ])\n                ]\n\n    enc =\n        encoding\n            << color\n                [ mName \"country\"\n                , mLegend [ leNumsExpr \"dashStyle\" leSymbolDash ]\n                ]\n\n",
                "type": "String.String -> (List.List number -> VegaLite.LegendProperty) -> VegaLite.LegendProperty"
            },
            {
                "name": "leOffset",
                "comment": " Offset in pixels of a legend from the encoded marks it describes. If the legend\norientation is one of `loTop`, `loBottom`, `loLeft` or `loRight`, a positive offset\nmoves the legend outwards away from the encoded marks. If it is one of `loTopLeft`,\n`loTopRight`, `loBottomLeft` or `loBottomRight` a positive offset will move it\ninwards away from the corner. If `loNone`, the offset has no effect.\n",
                "type": "Basics.Float -> VegaLite.LegendProperty"
            },
            {
                "name": "leOrient",
                "comment": " Position of a legend in a scene.\n",
                "type": "VegaLite.LegendOrientation -> VegaLite.LegendProperty"
            },
            {
                "name": "lePadding",
                "comment": " Padding in pixels between a legend and axis.\n",
                "type": "Basics.Float -> VegaLite.LegendProperty"
            },
            {
                "name": "leRowPadding",
                "comment": " Vertical spacing in pixel units between a symbol legend entries.\n",
                "type": "Basics.Float -> VegaLite.LegendProperty"
            },
            {
                "name": "leStrExpr",
                "comment": " Provide an [expression](https://vega.github.io/vega/docs/expressions/) to\nan legend property function requiring a string value. This can be used to provide an\ninteractive parameterisation of a legend property when an expression is bound to an\ninput element. For example,\n\n    ps =\n        params\n            << param \"color\"\n                [ paValue (str \"black\")\n                , paBind (ipColor [])\n                ]\n\n    enc =\n        encoding\n            << color\n                [ mName \"animal\"\n                , mLegend [ leStrExpr \"color\" leTitleColor ]\n                ]\n\n",
                "type": "String.String -> (String.String -> VegaLite.LegendProperty) -> VegaLite.LegendProperty"
            },
            {
                "name": "leStrokeColor",
                "comment": " Legend border color.\n",
                "type": "String.String -> VegaLite.LegendProperty"
            },
            {
                "name": "leStrokeWidth",
                "comment": " Legend border stroke width.\n",
                "type": "Basics.Float -> VegaLite.LegendProperty"
            },
            {
                "name": "leSymbol",
                "comment": " A symbol legend for categorical data.\n",
                "type": "VegaLite.Legend"
            },
            {
                "name": "leSymbolDash",
                "comment": " Legend symbol dash style in legend encoding.\n",
                "type": "List.List Basics.Float -> VegaLite.LegendProperty"
            },
            {
                "name": "leSymbolDashOffset",
                "comment": " Legend symbol dash offset in legend encoding.\n",
                "type": "Basics.Float -> VegaLite.LegendProperty"
            },
            {
                "name": "leSymbolFillColor",
                "comment": " Legend symbol fill color.\n",
                "type": "String.String -> VegaLite.LegendProperty"
            },
            {
                "name": "leSymbolLimit",
                "comment": " Maximum number of symbols in a legend.\n",
                "type": "Basics.Int -> VegaLite.LegendProperty"
            },
            {
                "name": "leSymbolOffset",
                "comment": " Symbol offset between legend symbols and legend area.\n",
                "type": "Basics.Float -> VegaLite.LegendProperty"
            },
            {
                "name": "leSymbolOpacity",
                "comment": " Legend symbol opacity.\n",
                "type": "Basics.Float -> VegaLite.LegendProperty"
            },
            {
                "name": "leSymbolSize",
                "comment": " Legend symbol size.\n",
                "type": "Basics.Float -> VegaLite.LegendProperty"
            },
            {
                "name": "leSymbolStrokeColor",
                "comment": " Legend symbol outline color.\n",
                "type": "String.String -> VegaLite.LegendProperty"
            },
            {
                "name": "leSymbolStrokeWidth",
                "comment": " Legend symbol stroke width.\n",
                "type": "Basics.Float -> VegaLite.LegendProperty"
            },
            {
                "name": "leSymbolType",
                "comment": " Legend symbol type.\n",
                "type": "VegaLite.Symbol -> VegaLite.LegendProperty"
            },
            {
                "name": "leTickCount",
                "comment": " Number of tick marks in a quantitative legend.\n",
                "type": "Basics.Float -> VegaLite.LegendProperty"
            },
            {
                "name": "leTitle",
                "comment": " Title of a legend. For multi-line titles, insert `\\n` at each line break or\nuse a `\"\"\"` multi-line string.\n",
                "type": "String.String -> VegaLite.LegendProperty"
            },
            {
                "name": "leTitleAlign",
                "comment": " Horizontal alignment for legend titles.\n",
                "type": "VegaLite.HAlign -> VegaLite.LegendProperty"
            },
            {
                "name": "leTitleAnchor",
                "comment": " Horizontal alignment for legend titles.\n",
                "type": "VegaLite.Anchor -> VegaLite.LegendProperty"
            },
            {
                "name": "leTitleBaseline",
                "comment": " Vertical alignment for legend titles.\n",
                "type": "VegaLite.VAlign -> VegaLite.LegendProperty"
            },
            {
                "name": "leTitleColor",
                "comment": " Color for legend title.\n",
                "type": "String.String -> VegaLite.LegendProperty"
            },
            {
                "name": "leTitleFont",
                "comment": " Font for legend titles.\n",
                "type": "String.String -> VegaLite.LegendProperty"
            },
            {
                "name": "leTitleFontSize",
                "comment": " Font size for legend titles.\n",
                "type": "Basics.Float -> VegaLite.LegendProperty"
            },
            {
                "name": "leTitleFontStyle",
                "comment": " Font style (italic etc.) for legend titles.\n",
                "type": "String.String -> VegaLite.LegendProperty"
            },
            {
                "name": "leTitleFontWeight",
                "comment": " Font weight for legend titles.\n",
                "type": "VegaLite.FontWeight -> VegaLite.LegendProperty"
            },
            {
                "name": "leTitleLimit",
                "comment": " Maximum size in pixel units for legend titles.\n",
                "type": "Basics.Float -> VegaLite.LegendProperty"
            },
            {
                "name": "leTitleLineHeight",
                "comment": " Height in pixels for each line of a multi-line legend title.\n",
                "type": "Basics.Float -> VegaLite.LegendProperty"
            },
            {
                "name": "leTitleOpacity",
                "comment": " Opacity of a legend's title.\n",
                "type": "Basics.Float -> VegaLite.LegendProperty"
            },
            {
                "name": "leTitleOrient",
                "comment": " Position of a legend's title relative to the main legend content.\n",
                "type": "VegaLite.LegendOrientation -> VegaLite.LegendProperty"
            },
            {
                "name": "leTitlePadding",
                "comment": " Spacing in pixel units between title and legend.\n",
                "type": "Basics.Float -> VegaLite.LegendProperty"
            },
            {
                "name": "leType",
                "comment": " Type of legend.\n",
                "type": "VegaLite.Legend -> VegaLite.LegendProperty"
            },
            {
                "name": "leValues",
                "comment": " An explicit set of legend values.\n",
                "type": "VegaLite.DataValues -> VegaLite.LegendProperty"
            },
            {
                "name": "leX",
                "comment": " x-position of legend group in pixel units for absolute positioning when\n[leOrient](#leOrient) is set to `loNone`.\n",
                "type": "Basics.Float -> VegaLite.LegendProperty"
            },
            {
                "name": "leY",
                "comment": " y-position of legend group in pixel units for absolute positioning when\n[leOrient](#leOrient) is set to `loNone`.\n",
                "type": "Basics.Float -> VegaLite.LegendProperty"
            },
            {
                "name": "leZIndex",
                "comment": " Drawing order of a legend relative to other chart elements. To\nplace a legend in front of others use a positive integer, or 0 to draw behind.\n",
                "type": "Basics.Int -> VegaLite.LegendProperty"
            },
            {
                "name": "lecoAria",
                "comment": " Default [ARIA](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA)\nproperties for providing accessible SVG output associated with a legend. If an empty\nlist is provided, ARIA tagging will be switched off.\n",
                "type": "List.List VegaLite.Aria -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoClipHeight",
                "comment": " Default maximum height of legend entries.\n",
                "type": "Basics.Float -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoColumnPadding",
                "comment": " Default horizontal padding between symbol legend entries.\n",
                "type": "Basics.Float -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoColumns",
                "comment": " Default number of columns in which to arrange symbol legend entries.\n",
                "type": "Basics.Float -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoCornerRadius",
                "comment": " Default legend corner radius.\n",
                "type": "Basics.Float -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoDirection",
                "comment": " Default direction of a legend.\n",
                "type": "VegaLite.MarkOrientation -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoDisable",
                "comment": " Whether or not legends should be disabled by default.\n",
                "type": "Basics.Bool -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoFillColor",
                "comment": " Default background legend color.\n",
                "type": "String.String -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoGradientDirection",
                "comment": " Default direction of a color ramp legend.\n",
                "type": "VegaLite.MarkOrientation -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoGradientHorizontalMaxLength",
                "comment": " Default maximum length in pixels of a horizontal color ramp legend.\n",
                "type": "Basics.Float -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoGradientHorizontalMinLength",
                "comment": " Default minimum length in pixels of a horizontal color ramp legend.\n",
                "type": "Basics.Float -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoGradientLabelLimit",
                "comment": " Default maximum allowable length for labels in a color ramp legend.\n",
                "type": "Basics.Float -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoGradientLabelOffset",
                "comment": " Default vertical offset in pixel units for labels in a color ramp legend.\n",
                "type": "Basics.Float -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoGradientLength",
                "comment": " Default length in pixels of the primary axis of a color ramp legend.\n",
                "type": "Basics.Float -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoGradientOpacity",
                "comment": " Default opacity of a color ramp legend.\n",
                "type": "Basics.Float -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoGradientStrokeColor",
                "comment": " Default color for strokes in a color ramp legend.\n",
                "type": "String.String -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoGradientStrokeWidth",
                "comment": " Default width for strokes in a color ramp legend.\n",
                "type": "Basics.Float -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoGradientThickness",
                "comment": " Default thickness in pixels of a color ramp legend.\n",
                "type": "Basics.Float -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoGradientVerticalMaxLength",
                "comment": " Default maximum length in pixels of a vertical color ramp legend.\n",
                "type": "Basics.Float -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoGradientVerticalMinLength",
                "comment": " Default minimum length in pixels of a vertical color ramp legend.\n",
                "type": "Basics.Float -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoGridAlign",
                "comment": " Default alignment to apply to symbol legends rows and columns.\n",
                "type": "VegaLite.CompositionAlignment -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoLabelAlign",
                "comment": " Default horizontal alignment of legend labels.\n",
                "type": "VegaLite.HAlign -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoLabelBaseline",
                "comment": " Default vertical alignment of legend labels.\n",
                "type": "VegaLite.VAlign -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoLabelColor",
                "comment": " Default color for legend labels.\n",
                "type": "String.String -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoLabelFont",
                "comment": " Default font for legend labels.\n",
                "type": "String.String -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoLabelFontSize",
                "comment": " Default font size of legend labels.\n",
                "type": "Basics.Float -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoLabelFontStyle",
                "comment": " Default font style (italic etc.) of legend labels.\n",
                "type": "String.String -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoLabelFontWeight",
                "comment": " Default font weight of legend labels.\n",
                "type": "VegaLite.FontWeight -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoLabelLimit",
                "comment": " Default maximum width for legend labels in pixel units.\n",
                "type": "Basics.Float -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoLabelOffset",
                "comment": " Default offset for legend labels.\n",
                "type": "Basics.Float -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoLabelOverlap",
                "comment": " Strategy for resolving overlapping legend labels.\n",
                "type": "VegaLite.OverlapStrategy -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoNoTitle",
                "comment": " Default to not displaying any legend titles.\n",
                "type": "VegaLite.LegendConfig"
            },
            {
                "name": "lecoNumExpr",
                "comment": " Provide an [expression](https://vega.github.io/vega/docs/expressions/) to a\nlegend configuration function requiring a numeric value.\n",
                "type": "String.String -> (number -> VegaLite.LegendConfig) -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoNumsExpr",
                "comment": " Provide an [expression](https://vega.github.io/vega/docs/expressions/) to\na legend property configuration requiring a list of numbers (for dash styles).\n",
                "type": "String.String -> (List.List number -> VegaLite.LegendConfig) -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoOffset",
                "comment": " Default offset in pixel units between the legend and the enclosing\ngroup or data rectangle.\n",
                "type": "Basics.Float -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoOrient",
                "comment": " Default legend position relative to the main plot content.\n",
                "type": "VegaLite.LegendOrientation -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoPadding",
                "comment": " Default spacing in pixel units between a legend and axis.\n",
                "type": "Basics.Float -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoRowPadding",
                "comment": " Default vertical spacing in pixel units between legend symbol entries.\n",
                "type": "Basics.Float -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoStrExpr",
                "comment": " Provide an [expression](https://vega.github.io/vega/docs/expressions/) to\nan legend configuration function requiring a string value.\n",
                "type": "String.String -> (String.String -> VegaLite.LegendConfig) -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoStrokeColor",
                "comment": " Default legend border color.\n",
                "type": "String.String -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoStrokeDash",
                "comment": " Default legend border stroke dash style.\n",
                "type": "List.List Basics.Float -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoStrokeWidth",
                "comment": " Default legend border stroke width.\n",
                "type": "Basics.Float -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoSymbolBaseFillColor",
                "comment": " Default legend symbol fill color for when no fill scale color in legend encoding.\n",
                "type": "String.String -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoSymbolBaseStrokeColor",
                "comment": " Default legend symbol stroke color for when no stroke scale color in legend encoding.\n",
                "type": "String.String -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoSymbolDash",
                "comment": " Default legend symbol dash style in legend encoding.\n",
                "type": "List.List Basics.Float -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoSymbolDashOffset",
                "comment": " Default legend symbol dash offset in legend encoding.\n",
                "type": "Basics.Float -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoSymbolDirection",
                "comment": " Default direction of a symbol legend.\n",
                "type": "VegaLite.MarkOrientation -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoSymbolFillColor",
                "comment": " Default legend symbol fill color.\n",
                "type": "String.String -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoSymbolLimit",
                "comment": " Default legend symbol fill color.\n",
                "type": "Basics.Int -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoSymbolOffset",
                "comment": " Default horizontal pixel offset for legend symbols.\n",
                "type": "Basics.Float -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoSymbolOpacity",
                "comment": " Default legend symbol opacity.\n",
                "type": "Basics.Float -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoSymbolSize",
                "comment": " Default legend symbol size.\n",
                "type": "Basics.Float -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoSymbolStrokeColor",
                "comment": " Default legend symbol outline color.\n",
                "type": "String.String -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoSymbolStrokeWidth",
                "comment": " Default legend symbol stroke width.\n",
                "type": "Basics.Float -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoSymbolType",
                "comment": " Default legend symbol type.\n",
                "type": "VegaLite.Symbol -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoTitleAlign",
                "comment": " Default horizontal alignment for legend titles.\n",
                "type": "VegaLite.HAlign -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoTitleAnchor",
                "comment": " Default anchoring for legend titles.\n",
                "type": "VegaLite.Anchor -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoTitleBaseline",
                "comment": " Default vertical alignment for legend titles.\n",
                "type": "VegaLite.VAlign -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoTitleColor",
                "comment": " Default color legend titles.\n",
                "type": "String.String -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoTitleFont",
                "comment": " Default font for legend titles.\n",
                "type": "String.String -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoTitleFontSize",
                "comment": " Default font size for legend titles.\n",
                "type": "Basics.Float -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoTitleFontStyle",
                "comment": " Default font style (italic etc) for legend titles.\n",
                "type": "String.String -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoTitleFontWeight",
                "comment": " Default font weight for legend titles.\n",
                "type": "VegaLite.FontWeight -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoTitleLimit",
                "comment": " Default maximum size in pixel units for legend titles.\n",
                "type": "Basics.Float -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoTitleLineHeight",
                "comment": " Default line height for multi-line legend titles.\n",
                "type": "Basics.Float -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoTitleOpacity",
                "comment": " Default opacity of a legend's title.\n",
                "type": "Basics.Float -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoTitlePadding",
                "comment": " Default spacing in pixel units between title and legend.\n",
                "type": "Basics.Float -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoUnselectedOpacity",
                "comment": " Default opacity of unselected legend items when made interactive via\n[seBindLegend](#seBindLegend).\n",
                "type": "Basics.Float -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoX",
                "comment": " Default x-position of legend group in pixel units for absolute positioning when\n[leOrient](#leOrient) is set to `loNone`.\n",
                "type": "Basics.Float -> VegaLite.LegendConfig"
            },
            {
                "name": "lecoY",
                "comment": " Default y-position of legend group in pixel units for absolute positioning when\n[leOrient](#leOrient) is set to `loNone`.\n",
                "type": "Basics.Float -> VegaLite.LegendConfig"
            },
            {
                "name": "line",
                "comment": " [Line mark](https://vega.github.io/vega-lite/docs/line.html) for symbolising\na sequence of values.\n",
                "type": "List.List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "lmMarker",
                "comment": " Properties of a line marker that is overlaid on an area mark. Used\nwhen specifying an [maLine](#maLine).\n",
                "type": "List.List VegaLite.MarkProperty -> VegaLite.LineMarker"
            },
            {
                "name": "lmNone",
                "comment": " Indicate no line marker on an area mark.\n",
                "type": "VegaLite.LineMarker"
            },
            {
                "name": "loBottom",
                "comment": " Position legend outside and below the visualization it describes.\n",
                "type": "VegaLite.LegendOrientation"
            },
            {
                "name": "loBottomLeft",
                "comment": " Position legend within the visualization it describes in the bottom-left corner.\n",
                "type": "VegaLite.LegendOrientation"
            },
            {
                "name": "loBottomRight",
                "comment": " Position legend within the visualization it describes in the bottom-right corner.\n",
                "type": "VegaLite.LegendOrientation"
            },
            {
                "name": "loCurrency",
                "comment": " Indicate prefix (first parameter) and suffix (second parameter) currency symbols\nas part of a locale specification. For example\n\n    loCurrency \"£\" \"\"\n\n",
                "type": "String.String -> String.String -> VegaLite.LocaleProperty"
            },
            {
                "name": "loDate",
                "comment": " Default format of date representation as part of a locale specification. Uses\n[d3-time-format symbols](https://github.com/d3/d3-time-format). For example,\n\n    loDate \"%_d %B %Y\"\n\n",
                "type": "String.String -> VegaLite.LocaleProperty"
            },
            {
                "name": "loDateTime",
                "comment": " Default format of date-time representation as part of a locale specification..\nUses [d3-time-format symbols](https://github.com/d3/d3-time-format). For example,\n\n    loDatetime \"%a %b %e %X %Y\"\n\n",
                "type": "String.String -> VegaLite.LocaleProperty"
            },
            {
                "name": "loDays",
                "comment": " List of the text representing the 7 days of the week (starting Sunday) as\npart of a locale specification.\n",
                "type": "List.List String.String -> VegaLite.LocaleProperty"
            },
            {
                "name": "loDecimal",
                "comment": " Symbol used to indicate decimal point as part of a locale specification.\n",
                "type": "String.String -> VegaLite.LocaleProperty"
            },
            {
                "name": "loGrouping",
                "comment": " Number of digits to represent what is by default a 'thousands' group, as part\nof a locale specification.\n",
                "type": "Basics.Int -> VegaLite.LocaleProperty"
            },
            {
                "name": "loLeft",
                "comment": " Position legend to the left of the visualization it describes.\n",
                "type": "VegaLite.LegendOrientation"
            },
            {
                "name": "loMinus",
                "comment": " Symbol used to indicate minus/negative as part of a locale specification.\n",
                "type": "String.String -> VegaLite.LocaleProperty"
            },
            {
                "name": "loMonths",
                "comment": " List of the text representing the 12 months of the year (starting January) as\npart of a locale specification.\n",
                "type": "List.List String.String -> VegaLite.LocaleProperty"
            },
            {
                "name": "loNan",
                "comment": " Symbol used to indicate a 'not-a-number' value, as part of a locale specification.\n",
                "type": "String.String -> VegaLite.LocaleProperty"
            },
            {
                "name": "loNone",
                "comment": " Do not perform automatic legend positioning (allows legend to be located explicitly\nvia `x` `y` coordinates).\n",
                "type": "VegaLite.LegendOrientation"
            },
            {
                "name": "loNumerals",
                "comment": " List of 10 symbols to replace the numerals 0–9 as part of a locale specification.\n",
                "type": "List.List String.String -> VegaLite.LocaleProperty"
            },
            {
                "name": "loPercent",
                "comment": " Symbol used to indicate percentages as part of a locale specification.\n",
                "type": "String.String -> VegaLite.LocaleProperty"
            },
            {
                "name": "loPeriods",
                "comment": " Symbols used to indicate a time of day 'AM' (first parameter) and 'PM' (second\nparameter) equivalent, as part of a locale specification. For example,\n\n    loPeriods \"a.m.\" \"p.m.\"\n\n",
                "type": "String.String -> String.String -> VegaLite.LocaleProperty"
            },
            {
                "name": "loRight",
                "comment": " Position legend outside and to the right of the visualization it describes.\n",
                "type": "VegaLite.LegendOrientation"
            },
            {
                "name": "loShortDays",
                "comment": " List of the text representing the 7 abbreviated days of the week (starting Sunday)\nas part of a locale specification.\n",
                "type": "List.List String.String -> VegaLite.LocaleProperty"
            },
            {
                "name": "loShortMonths",
                "comment": " List of the text representing the 12 abbreviated months of the year (starting\nJanuary) as part of a locale specification.\n",
                "type": "List.List String.String -> VegaLite.LocaleProperty"
            },
            {
                "name": "loThousands",
                "comment": " Symbol used to indicate 'thousands' separator as part of a locale specification.\nNote that digits may be grouped in units other than thousands if [loGrouping](#loGrouping)\nis set to a value other than 3.\n",
                "type": "String.String -> VegaLite.LocaleProperty"
            },
            {
                "name": "loTime",
                "comment": " Default format of time representation as part of a locale specification. Uses\n[d3-time-format symbols](https://github.com/d3/d3-time-format). For example,\n\n    loTime \"%I:%M %p\"\n\n",
                "type": "String.String -> VegaLite.LocaleProperty"
            },
            {
                "name": "loTop",
                "comment": " Position legend outside and above the visualization it describes.\n",
                "type": "VegaLite.LegendOrientation"
            },
            {
                "name": "loTopLeft",
                "comment": " Position legend within the visualization it describes in the top-left corner.\n",
                "type": "VegaLite.LegendOrientation"
            },
            {
                "name": "loTopRight",
                "comment": " Position legend within the visualization it describes in the top-right corner.\n",
                "type": "VegaLite.LegendOrientation"
            },
            {
                "name": "loess",
                "comment": " Generate a _loess_ (locally-estimated scatterplot smoothing) trendline through\na pair of data fields. The first parameter is the name of the field representing\nthe dependent variable (commonly mapped to the y-axis), the second is the name of\nthe field representing the independent variable (commonly mapped to the x-axis).\nThe third parameter is a list of optional loess parameters to customise the trend\nfitting.\n",
                "type": "String.String -> String.String -> List.List VegaLite.LoessProperty -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"
            },
            {
                "name": "lookup",
                "comment": " Perform a lookup of named fields between two data sources. This allows you to\nfind values in one data source based on the values in another. The first parameter\nis the field in the primary data source to act as key, the second is the secondary\ndata source which can be specified with a call to `dataFromUrl` or other data\ngenerating function. The third is the name of the field in the secondary\ndata source to match values with the primary key. The fourth parameter is the list\nof fields to be stored when the keys match.\n\nFor linking data with interactive selections, see [lookupSelection](#lookupSelection).\n\nA common use for lookup is to join geographic and attribute data sources. Below\n`geodata` is the primary data source containing borough boundaries and `censusData`\nthe secondary data source containing attribute data. Both have common data field\nvalues identifying a borough (`id` and `borough`) that is used to join the data sources:\n\n    geoData =\n        dataFromUrl \"city.json\" [ topojsonFeature \"boroughs\" ]\n\n    censusData =\n        dataFromUrl \"census.csv\" []\n\n    trans =\n        transform\n            << lookup \"id\"\n                (censusData [])\n                \"borough\"\n                (luFields [ \"carOwnership\", \"numBedrooms\" ])\n\n",
                "type": "String.String -> VegaLite.Data -> String.String -> VegaLite.LookupFields -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"
            },
            {
                "name": "lookupSelection",
                "comment": " Attach the results of an interactive selection to a primary data source.\nThe first three parameters are the field in the primary data source to look up;\nthe name of the interactive selection parameter; and the name of the field in the\nselection to link with the primary data field. This is similar to [lookup](#lookup)\nexcept that the data in a selection are used in place of the secondary data source.\n\n      ps =\n          params\n              << param \"mySel\"\n                  [ paSelect sePoint [ seOn \"mouseover\", seEncodings [ chX ] ] ]\n\n      trans =\n          transform\n              << lookupSelection \"country\" \"mySel\" \"country\"\n\n",
                "type": "String.String -> String.String -> String.String -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"
            },
            {
                "name": "lsAs",
                "comment": " Name the outputs of a loess transform. The first parameter is the name to\ngive the field containing the smoothed independent variable, the second the name to\ngive the field containing smoothed dependent variable. If not specified, the\noriginal input independent and dependent field names are used.\n",
                "type": "String.String -> String.String -> VegaLite.LoessProperty"
            },
            {
                "name": "lsBandwidth",
                "comment": " The bandwidth scaled between [0,1] to determine the amount of loess smoothing.\nDefault value is 0.3\n",
                "type": "Basics.Float -> VegaLite.LoessProperty"
            },
            {
                "name": "lsGroupBy",
                "comment": " The data fields to group by when generating a loess trendline. If not specified,\na single group containing all data objects will be used.\n",
                "type": "List.List String.String -> VegaLite.LoessProperty"
            },
            {
                "name": "luAs",
                "comment": " Name to give the entire set of fields in a secondary data source when performing\na [lookup](#lookup). To refer to individual fields via this name, use Javascript\ndot notation (or if the field contains spaces, use equivalent array index notation\nin single quotes such as `o['my field']`).\n\n    data =\n        dataFromUrl \"data/flights-airport.csv\" []\n\n    trans =\n        transform\n            << lookup \"origin\"\n                (dataFromUrl \"data/airports.csv\" [])\n                \"iata\"\n                (luAs \"o\")\n\n    enc =\n        encoding\n            << position Longitude [ pName \"o.longitude\", pQuant ]\n            << position Latitude [ pName \"o.latitude\", pQuant ]\n\n",
                "type": "String.String -> VegaLite.LookupFields"
            },
            {
                "name": "luAsWithDefault",
                "comment": " The same as [luAs](#luAs) except with a second parameter providing the default\nvalue if the lookup fails.\n",
                "type": "String.String -> String.String -> VegaLite.LookupFields"
            },
            {
                "name": "luFields",
                "comment": " Names of the fields to be returned from a secondary data source when performing\na [lookup](#lookup) transformation.\n",
                "type": "List.List String.String -> VegaLite.LookupFields"
            },
            {
                "name": "luFieldsAs",
                "comment": " Names of the fields and their aliases to be returned from a secondary data\nsource when performing a [lookup](#lookup) transformation. Each tuple should be\na name of a field to return followed by the new name to give it. Unlike [luAs](#luAs)\nthis allows separate aliases to be given to each matched field.\n",
                "type": "List.List ( String.String, String.String ) -> VegaLite.LookupFields"
            },
            {
                "name": "luFieldsAsWithDefault",
                "comment": " The same as [luFieldsAs](#luFieldsAs) except with a second parameter providing\nthe default value if the lookup fails.\n",
                "type": "List.List ( String.String, String.String ) -> String.String -> VegaLite.LookupFields"
            },
            {
                "name": "luFieldsWithDefault",
                "comment": " The same as [luFields](#luFields) except with a second parameter providing\nthe default value if the lookup fails.\n",
                "type": "List.List String.String -> String.String -> VegaLite.LookupFields"
            },
            {
                "name": "mAggregate",
                "comment": " Compute some aggregate summary statistics for a field to be encoded with a\nmark property channel. The type of aggregation is determined by the given operation\nparameter.\n",
                "type": "VegaLite.Operation -> VegaLite.MarkChannel"
            },
            {
                "name": "mBand",
                "comment": " Apply offset relative to band width for a mark property. Value should be in\nthe range [0, 1] as a proportion of the band width.\n",
                "type": "Basics.Float -> VegaLite.MarkChannel"
            },
            {
                "name": "mBin",
                "comment": " Discretize numeric values into bins when encoding with a mark property channel.\n",
                "type": "List.List VegaLite.BinProperty -> VegaLite.MarkChannel"
            },
            {
                "name": "mBinned",
                "comment": " Indicate that data encoding with a mark are already binned.\n",
                "type": "VegaLite.MarkChannel"
            },
            {
                "name": "mBoo",
                "comment": " Boolean value when encoding with a mark property channel.\n",
                "type": "Basics.Bool -> VegaLite.MarkChannel"
            },
            {
                "name": "mCondition",
                "comment": " Make a mark channel encoding conditional on a predicate expression. A predicate\nmight be the result of evaluating a parameter ([prParam](#prParam)) or an expression\n([prTest](#prTest)). The first parameter is the predicate that evaluates to true\nor false; the second the encoding if true, the third the encoding if false.\nFor example, to encode in one of two colours depending on a selection:\n\n    encoding\n        << color\n            [ mCondition (prParam \"mySelection\")\n                [ mStr \"red\" ]\n                [ mStr \"black\" ]\n            ]\n\n",
                "type": "VegaLite.Predicate -> List.List VegaLite.MarkChannel -> List.List VegaLite.MarkChannel -> VegaLite.MarkChannel"
            },
            {
                "name": "mConditions",
                "comment": " Make a mark channel conditional on a sequence of predicate values. This can\nbe used when several predicates need to be tested in sequence each with their own\nencoding outcome ('if-else'). For example a four-way conditional color encoding\ncan be specified as:\n\n    encoding\n        << color\n            [ mConditions\n                [ ( prTest (expr \"datum.value < 40\"), [ mStr \"blue\" ] )\n                , ( prTest (expr \"datum.value < 50\"), [ mStr \"red\" ] )\n                , ( prTest (expr \"datum.value < 60\"), [ mStr \"yellow\" ] )\n                ]\n                [ mStr \"black\" ]\n            ]\n\n",
                "type": "List.List ( VegaLite.Predicate, List.List VegaLite.MarkChannel ) -> List.List VegaLite.MarkChannel -> VegaLite.MarkChannel"
            },
            {
                "name": "mDatum",
                "comment": " Name of a literal data item used for encoding with a mark property channel.\nUnlike [mNum](#mNum), [mStr](#mStr) and [mBoo](#mBoo), datum literals represent\nvalues in data space.\n",
                "type": "VegaLite.DataValue -> VegaLite.MarkChannel"
            },
            {
                "name": "mGeo",
                "comment": " Indicate a data field encoded as a mark property is a geo feature.\n",
                "type": "VegaLite.MarkChannel"
            },
            {
                "name": "mLegend",
                "comment": " Properties of a legend that describes a mark's encoding. For no legend, provide\nan empty list as the parameter.\n",
                "type": "List.List VegaLite.LegendProperty -> VegaLite.MarkChannel"
            },
            {
                "name": "mName",
                "comment": " Name of field used for encoding with a mark property channel.\n",
                "type": "String.String -> VegaLite.MarkChannel"
            },
            {
                "name": "mNominal",
                "comment": " Indicate a data field encoded as a mark property is nominal. This is the\ndefault data type.\n",
                "type": "VegaLite.MarkChannel"
            },
            {
                "name": "mNum",
                "comment": " Literal numeric value when encoding with a mark property channel.\n",
                "type": "Basics.Float -> VegaLite.MarkChannel"
            },
            {
                "name": "mOrdinal",
                "comment": " Indicate a data field encoded as a mark property is ordinal.\n",
                "type": "VegaLite.MarkChannel"
            },
            {
                "name": "mPath",
                "comment": " SVG path string used when encoding with a mark property channel. Useful\nfor providing custom shapes.\n",
                "type": "String.String -> VegaLite.MarkChannel"
            },
            {
                "name": "mQuant",
                "comment": " Indicate a data field encoded as a mark property is quantitative.\n",
                "type": "VegaLite.MarkChannel"
            },
            {
                "name": "mRepeat",
                "comment": " Reference in a mark channel to a field name generated by [repeatFlow](#repeatFlow)\nor [repeat](#repeat). The parameter identifies whether reference is being made to\nfields that are to be encoded in layers, or in columns / rows with a flow layout.\n",
                "type": "VegaLite.Arrangement -> VegaLite.MarkChannel"
            },
            {
                "name": "mRepeatDatum",
                "comment": " Reference in a mark channel to a datum value generated by [repeatFlow](#repeatFlow)\nor [repeat](#repeat). The parameter identifies whether reference is being made to\na datum that is to be encoded in layers, or in columns / rows with a flow layout.\n",
                "type": "VegaLite.Arrangement -> VegaLite.MarkChannel"
            },
            {
                "name": "mScale",
                "comment": " Scaling applied to a field when encoding with a mark property channel.\nThe scale will transform a field's value into a color, shape, size etc.\n",
                "type": "List.List VegaLite.ScaleProperty -> VegaLite.MarkChannel"
            },
            {
                "name": "mSort",
                "comment": " Sort order when encoding sortable mark properties such as colour.\n",
                "type": "List.List VegaLite.SortProperty -> VegaLite.MarkChannel"
            },
            {
                "name": "mStr",
                "comment": " Literal string value when encoding with a mark property channel.\n",
                "type": "String.String -> VegaLite.MarkChannel"
            },
            {
                "name": "mSymbol",
                "comment": " A symbol literal when encoding with a mark property channel. Can be useful when\nmaking a symbol dependent on some data or selection condition.\n",
                "type": "VegaLite.Symbol -> VegaLite.MarkChannel"
            },
            {
                "name": "mTemporal",
                "comment": " Indicate a data field encoded as a mark property is temporal.\n",
                "type": "VegaLite.MarkChannel"
            },
            {
                "name": "mTimeUnit",
                "comment": " Time unit aggregation of field values when encoding with a mark property channel.\n",
                "type": "VegaLite.TimeUnit -> VegaLite.MarkChannel"
            },
            {
                "name": "mTitle",
                "comment": " Title of a field when encoding with a mark property channel. For multi-line titles,\ninsert `\\n` at each line break or use a `\"\"\"` multi-line string.\n",
                "type": "String.String -> VegaLite.MarkChannel"
            },
            {
                "name": "maAlign",
                "comment": " Horizontal alignment of a text mark.\n",
                "type": "VegaLite.HAlign -> VegaLite.MarkProperty"
            },
            {
                "name": "maAngle",
                "comment": " Rotation angle of a text mark (degrees from horizontal).\n",
                "type": "Basics.Float -> VegaLite.MarkProperty"
            },
            {
                "name": "maAria",
                "comment": " [ARIA](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA) properties\nfor providing accessible SVG output associated with a mark. If an empty list is\nprovided, ARIA tagging will be switched off.\n",
                "type": "List.List VegaLite.Aria -> VegaLite.MarkProperty"
            },
            {
                "name": "maAspect",
                "comment": " Whether or not the aspect ratio of an image mark should be preserved.\n",
                "type": "Basics.Bool -> VegaLite.MarkProperty"
            },
            {
                "name": "maBandSize",
                "comment": " Band size of a bar mark.\n",
                "type": "Basics.Float -> VegaLite.MarkProperty"
            },
            {
                "name": "maBaseline",
                "comment": " Vertical alignment of a text mark.\n",
                "type": "VegaLite.VAlign -> VegaLite.MarkProperty"
            },
            {
                "name": "maBinSpacing",
                "comment": " Offset between bars for a binned field using a bar mark.\n",
                "type": "Basics.Float -> VegaLite.MarkProperty"
            },
            {
                "name": "maBlend",
                "comment": " Color blend mode for drawing an item over its current background. Standard\n[CSS blend modes](https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode)\ncan be specified such as [bmHue](#bmHue), [bmDarken](#bmDarken) etc.\n",
                "type": "VegaLite.BlendMode -> VegaLite.MarkProperty"
            },
            {
                "name": "maBooExpr",
                "comment": " Provide an [expression](https://vega.github.io/vega/docs/expressions/) to\na mark property function requiring a boolean value. This can be used to provide an\ninteractive parameterisation of a mark property by providing an expression bound\nto an input element. For example,\n\n    ps =\n        params\n            << param \"asp\"\n                [ paValue (boo True)\n                , paBind (ipCheckbox [ inName \"maintain aspect ratio\" ])\n                ]\n\n    mk =\n        image [ maBooExpr \"asp\" maAspect ]\n\n",
                "type": "String.String -> (Basics.Bool -> VegaLite.MarkProperty) -> VegaLite.MarkProperty"
            },
            {
                "name": "maBorders",
                "comment": " Border properties for an errorband mark.\n",
                "type": "List.List VegaLite.MarkProperty -> VegaLite.MarkProperty"
            },
            {
                "name": "maBox",
                "comment": " Box symbol properties for the boxplot mark. If an empty list is provided, no\nbox will be shown.\n",
                "type": "List.List VegaLite.MarkProperty -> VegaLite.MarkProperty"
            },
            {
                "name": "maClip",
                "comment": " Whether or not a mark should be clipped to the enclosing group's dimensions.\n",
                "type": "Basics.Bool -> VegaLite.MarkProperty"
            },
            {
                "name": "maColor",
                "comment": " Default color of a mark. Note that `maFill` and `maStroke` have higher\nprecedence and will override this if specified. Color strings can use any valid\nHTML color specification.\n\n    maColor \"#eee\"\n\n    maColor \"#734FD8\"\n\n    maColor \"crimson\"\n\n    maColor \"rgb(255,204,210)\"\n\n    maColor \"hsl(180, 50%, 50%)\"\n\n",
                "type": "String.String -> VegaLite.MarkProperty"
            },
            {
                "name": "maColorGradient",
                "comment": " A color gradient to apply to a mark. The first parameter indicates whether the\ngradient should be linear or radial. The second is a set of customisation options\nfor the colors, positioning and rate of change of the gradient. For example,\nto set a radial red-blue color gradient for a mark:\n\n    maColorGradient grRadial [ grStops [ ( 0, \"red\" ), ( 1, \"blue\" ) ] ]\n\n",
                "type": "VegaLite.ColorGradient -> List.List VegaLite.GradientProperty -> VegaLite.MarkProperty"
            },
            {
                "name": "maContinuousBandSize",
                "comment": " Continuous band size of a bar mark.\n",
                "type": "Basics.Float -> VegaLite.MarkProperty"
            },
            {
                "name": "maCornerRadius",
                "comment": " The radius in pixels of selected marks' corners. For rectangular marks, it\nshapes all four corners; for [arc](#arc) marks it shapes the vertices of segment.\nDefault is 0 indicating no rounding.\n",
                "type": "Basics.Float -> VegaLite.MarkProperty"
            },
            {
                "name": "maCornerRadiusBottomLeft",
                "comment": " The radius in pixels of the bottom-left corner of a rectangle mark. Will override\nany value specified in [maCornerRadius](#maCornerRadius).\n",
                "type": "Basics.Float -> VegaLite.MarkProperty"
            },
            {
                "name": "maCornerRadiusBottomRight",
                "comment": " The radius in pixels of the bottom-right corner of a rectangle mark. Will override\nany value specified in [maCornerRadius](#maCornerRadius).\n",
                "type": "Basics.Float -> VegaLite.MarkProperty"
            },
            {
                "name": "maCornerRadiusEnd",
                "comment": " The radius in pixels of the 'end' corners of a bar mark. For vertical bars\nthis would be the top corners and for horizontal bars, the right corners.\n",
                "type": "Basics.Float -> VegaLite.MarkProperty"
            },
            {
                "name": "maCornerRadiusTopLeft",
                "comment": " The radius in pixels of the top-left corner of a rectangle mark. Will override\nany value specified in [maCornerRadius](#maCornerRadius).\n",
                "type": "Basics.Float -> VegaLite.MarkProperty"
            },
            {
                "name": "maCornerRadiusTopRight",
                "comment": " The radius in pixels of the top-right corner of a rectangle mark. Will override\nany value specified in [maCornerRadius](#maCornerRadius).\n",
                "type": "Basics.Float -> VegaLite.MarkProperty"
            },
            {
                "name": "maCursor",
                "comment": " Cursor to be associated with a hyperlink mark.\n",
                "type": "VegaLite.Cursor -> VegaLite.MarkProperty"
            },
            {
                "name": "maDir",
                "comment": " Direction of text, which determines which end is truncated in cases where text\nis larger than available space.\n",
                "type": "VegaLite.TextDirection -> VegaLite.MarkProperty"
            },
            {
                "name": "maDiscreteBandSize",
                "comment": " Discrete band size of a bar mark.\n",
                "type": "Basics.Float -> VegaLite.MarkProperty"
            },
            {
                "name": "maDx",
                "comment": " Horizontal offset between a text mark and its anchor.\n",
                "type": "Basics.Float -> VegaLite.MarkProperty"
            },
            {
                "name": "maDy",
                "comment": " Vertical offset between a text mark and its anchor.\n",
                "type": "Basics.Float -> VegaLite.MarkProperty"
            },
            {
                "name": "maEllipsis",
                "comment": " Text to indicate a truncated piece of text (default is the ellipsis ...)\n",
                "type": "String.String -> VegaLite.MarkProperty"
            },
            {
                "name": "maExtent",
                "comment": " Extent of whiskers used in a boxplot, error bars or error bands.\n",
                "type": "VegaLite.SummaryExtent -> VegaLite.MarkProperty"
            },
            {
                "name": "maFill",
                "comment": " Default fill color of a mark. Color strings can use any valid HTML color\nspecification.\n\n    maFill \"#eee\"\n\n    maFill \"#734FD8\"\n\n    maFill \"crimson\"\n\n    maFill \"rgb(255,204,210)\"\n\n    maFill \"rgba(255,50,80,0.3)\"\n\n    maFill \"hsl(180, 50%, 50%)\"\n\nUsually, to avoid filling the interior of a mark, use [maFilled False](#maFilled),\nbut `maFill \"\"` can instead be used for cases where an interactive tooltip needs\nto 'see through' a stroked mark to one underneath it in a layered specification.\n\n",
                "type": "String.String -> VegaLite.MarkProperty"
            },
            {
                "name": "maFillGradient",
                "comment": " A color gradient to apply to a mark's interior. The first parameter indicates\nwhether the gradient should be linear or radial. The second is a set of customisation\noptions for the colors, positioning and rate of change of the gradient. For example,\nto set a radial red-blue color gradient as a fill for a mark:\n\n    maStrokeGradient grRadial [ grStops [ ( 0, \"red\" ), ( 1, \"blue\" ) ] ]\n\nFill gradients have a higher priority than [maColorGradient](#maColorGradient).\n\n",
                "type": "VegaLite.ColorGradient -> List.List VegaLite.GradientProperty -> VegaLite.MarkProperty"
            },
            {
                "name": "maFillOpacity",
                "comment": " Fill opacity of a mark.\n",
                "type": "Basics.Float -> VegaLite.MarkProperty"
            },
            {
                "name": "maFilled",
                "comment": " Whether or not a mark's color should be used as the fill color instead of\nstroke color.\n",
                "type": "Basics.Bool -> VegaLite.MarkProperty"
            },
            {
                "name": "maFont",
                "comment": " Font of a text mark. Can be any font name made accessible via a css file (or\na generic font like `serif`, `monospace` etc.).\n",
                "type": "String.String -> VegaLite.MarkProperty"
            },
            {
                "name": "maFontSize",
                "comment": " Font size in pixels used by a text mark.\n",
                "type": "Basics.Float -> VegaLite.MarkProperty"
            },
            {
                "name": "maFontStyle",
                "comment": " Font style (e.g. `italic`) used by a text mark.\n",
                "type": "String.String -> VegaLite.MarkProperty"
            },
            {
                "name": "maFontWeight",
                "comment": " Font weight used by a text mark.\n",
                "type": "VegaLite.FontWeight -> VegaLite.MarkProperty"
            },
            {
                "name": "maHRef",
                "comment": " Hyperlink to be associated with a mark making it a clickable hyperlink.\n",
                "type": "String.String -> VegaLite.MarkProperty"
            },
            {
                "name": "maHeight",
                "comment": " Explicitly set the height of a mark.\n",
                "type": "Basics.Float -> VegaLite.MarkProperty"
            },
            {
                "name": "maHeightBand",
                "comment": " Set the height of a mark as a proportion of its band size.\n",
                "type": "Basics.Float -> VegaLite.MarkProperty"
            },
            {
                "name": "maInnerRadius",
                "comment": " Fix the inner radius (R2) of a radial plot. Can be used for creating 'holes'\nin pie chart.\n",
                "type": "Basics.Float -> VegaLite.MarkProperty"
            },
            {
                "name": "maInterpolate",
                "comment": " Interpolation method used by line and area marks. For example, to create a\ncurved line joining data points:\n\n    line [ maInterpolate miMonotone ]\n\n",
                "type": "VegaLite.MarkInterpolation -> VegaLite.MarkProperty"
            },
            {
                "name": "maLimit",
                "comment": " Width in pixels indicating maximum permitted space for a text mark. Any mark\nthat exceeds this limit will be truncated with an ellipsis.\n",
                "type": "Basics.Float -> VegaLite.MarkProperty"
            },
            {
                "name": "maLine",
                "comment": " Appearance of a line marker joining the vertices of an area mark.\n\n    area\n        [ maLine (lmMarker [ maStroke \"black\" ])\n        , maInterpolate miMonotone\n        ]\n\n",
                "type": "VegaLite.LineMarker -> VegaLite.MarkProperty"
            },
            {
                "name": "maLineHeight",
                "comment": " Line height for multi-line text marks.\n",
                "type": "Basics.Float -> VegaLite.MarkProperty"
            },
            {
                "name": "maMedian",
                "comment": " Median line properties for the boxplot mark. If an empty list is provided,\nno median line will be shown.\n",
                "type": "List.List VegaLite.MarkProperty -> VegaLite.MarkProperty"
            },
            {
                "name": "maNumExpr",
                "comment": " Provide an [expression](https://vega.github.io/vega/docs/expressions/) to a\nmark property function requiring a numeric value. This can be used for interactive\nparameterisation when an expression is bound to an input element. For example,\n\n    ps =\n        params\n            << param \"r\"\n                [ paValue (num 0)\n                , paBind (ipRange [ inMax 100 ])\n                ]\n\n    mk =\n        arc [ maNumExpr \"r\" maInnerRadius ]\n\n",
                "type": "String.String -> (number -> VegaLite.MarkProperty) -> VegaLite.MarkProperty"
            },
            {
                "name": "maNumsExpr",
                "comment": " Provide an [expression](https://vega.github.io/vega/docs/expressions/) to\na mark property function requiring a list of numbers (for dash styles). This can\nbe used to provide an interactive parameterisation of a mark's dash property when\nan expression is bound to an input element. For example,\n\n    ps =\n        params\n            << param \"dashStyle\"\n                [ paValue (nums [ 2, 2 ])\n                , paBind (ipSelect [ inDataOptions [ nums [ 2, 2 ], nums [ 8, 8 ] ] ])\n                ]\n\n    mk =\n        bar\n            [ maNumsExpr \"dashStyle\" maStrokeDash, maStroke \"black\" ]\n\n",
                "type": "String.String -> (List.List number -> VegaLite.MarkProperty) -> VegaLite.MarkProperty"
            },
            {
                "name": "maOpacity",
                "comment": " Overall opacity of a mark in the range 0 (completely transparent) to 1\n(completely opaque).\n",
                "type": "Basics.Float -> VegaLite.MarkProperty"
            },
            {
                "name": "maOrder",
                "comment": " Ordering of vertices in a line or area mark. If true (default), order is\ndetermined by measurement type or order channel. If false, the original data order\nis used.\n",
                "type": "Basics.Bool -> VegaLite.MarkProperty"
            },
            {
                "name": "maOrient",
                "comment": " Orientation of a non-stacked bar, tick, area or line mark.\n",
                "type": "VegaLite.MarkOrientation -> VegaLite.MarkProperty"
            },
            {
                "name": "maOuterRadius",
                "comment": " Fix the outer radius (R) of a radial plot.\n",
                "type": "Basics.Float -> VegaLite.MarkProperty"
            },
            {
                "name": "maOutliers",
                "comment": " Outlier symbol properties for the boxplot mark. If an empty list is provided,\nno outliers will be shown.\n",
                "type": "List.List VegaLite.MarkProperty -> VegaLite.MarkProperty"
            },
            {
                "name": "maPadAngle",
                "comment": " Angular padding applied to sides of an arc (radians)s.\n",
                "type": "Basics.Float -> VegaLite.MarkProperty"
            },
            {
                "name": "maPoint",
                "comment": " Appearance of a point marker joining the vertices of a line or area mark.\n\n    line [ maPoint (pmMarker [ maFill \"black\" ]) ]\n\n",
                "type": "VegaLite.PointMarker -> VegaLite.MarkProperty"
            },
            {
                "name": "maRadius",
                "comment": " Radial offset of a text mark from an origin specified in Cartesian `X` and `Y`\ncoordinates.\n",
                "type": "Basics.Float -> VegaLite.MarkProperty"
            },
            {
                "name": "maRadius2Offset",
                "comment": " Polar coordinate inner radial offset of an arc mark from a polar origin\nspecified with `Theta`, `R` and `R2`.\n",
                "type": "Basics.Float -> VegaLite.MarkProperty"
            },
            {
                "name": "maRadiusOffset",
                "comment": " Polar coordinate radial offset of a text or arc mark from a polar origin\nspecified with `Theta` and `R`.\n",
                "type": "Basics.Float -> VegaLite.MarkProperty"
            },
            {
                "name": "maRemoveInvalid",
                "comment": " Determine whether or not invalid (`null` and `NaN`) values are considered for\nencoding as marks. If `true` (default), invalid values are ignored, otherwise\nthey are treated as if 0.\n",
                "type": "Basics.Bool -> VegaLite.MarkProperty"
            },
            {
                "name": "maRule",
                "comment": " Rule (main line) properties for the errorbar and boxplot marks. If an empty\nlist is provided, no rule will be shown.\n",
                "type": "List.List VegaLite.MarkProperty -> VegaLite.MarkProperty"
            },
            {
                "name": "maShape",
                "comment": " Shape of a point mark.\n",
                "type": "VegaLite.Symbol -> VegaLite.MarkProperty"
            },
            {
                "name": "maShortTimeLabels",
                "comment": " Whether or not month and weekday names are abbreviated in a text mark.\n",
                "type": "Basics.Bool -> VegaLite.MarkProperty"
            },
            {
                "name": "maSize",
                "comment": " Size of a mark in square units. For example, to create a circle of diameter\n50 pixels:\n\n    circle [ maSize 2500 ]\n\n",
                "type": "Basics.Float -> VegaLite.MarkProperty"
            },
            {
                "name": "maStrExpr",
                "comment": " Provide an [expression](https://vega.github.io/vega/docs/expressions/) to\na mark property function requiring a string value. This can be used to provide an\ninteractive parameterisation of a mark property by providing an expression bound\nto an input element. For example,\n\n    ps =\n        params\n            << param \"clr\"\n                [ paValue (str \"red\")\n                , paBind (ipColor [])\n                ]\n\n    mk =\n        circle [ maStrExpr \"clr\" maFill ]\n\n",
                "type": "String.String -> (String.String -> VegaLite.MarkProperty) -> VegaLite.MarkProperty"
            },
            {
                "name": "maStroke",
                "comment": " Default stroke color of a mark. Color strings can use any valid HTML color\nspecification.\n\n    maStroke \"#eee\"\n\n    maStroke \"#734FD8\"\n\n    maStroke \"crimson\"\n\n    maStroke \"rgb(255,204,210)\"\n\n    maStroke \"hsl(180, 50%, 50%)\"\n\nAn empty string (`\"\"`) indicates that no stroke around a mark be drawn.\n\n",
                "type": "String.String -> VegaLite.MarkProperty"
            },
            {
                "name": "maStrokeCap",
                "comment": " Cap style of a mark's stroke.\n",
                "type": "VegaLite.StrokeCap -> VegaLite.MarkProperty"
            },
            {
                "name": "maStrokeDash",
                "comment": " Stroke dash style used by a mark. Determined by an alternating 'on-off'\nsequence of line lengths.\n",
                "type": "List.List Basics.Float -> VegaLite.MarkProperty"
            },
            {
                "name": "maStrokeDashOffset",
                "comment": " Number of pixels before the first line dash is drawn.\n",
                "type": "Basics.Float -> VegaLite.MarkProperty"
            },
            {
                "name": "maStrokeGradient",
                "comment": " A color gradient to apply to a mark's boundary stroke. The first parameter indicates\nwhether the gradient should be linear or radial. The second is a set of customisation\noptions for the colors, positioning and rate of change of the gradient. For example,\nto set a radial red-blue color gradient for a mark's stroke:\n\n    maStrokeGradient grRadial [ grStops [ ( 0, \"red\" ), ( 1, \"blue\" ) ] ]\n\nStroke gradients have a higher priority than [maColorGradient](#maColorGradient).\n\n",
                "type": "VegaLite.ColorGradient -> List.List VegaLite.GradientProperty -> VegaLite.MarkProperty"
            },
            {
                "name": "maStrokeJoin",
                "comment": " Line segment join style of a mark's stroke.\n",
                "type": "VegaLite.StrokeJoin -> VegaLite.MarkProperty"
            },
            {
                "name": "maStrokeMiterLimit",
                "comment": " Mitre limit at which to bevel a join between line segments of a mark's stroke.\n",
                "type": "Basics.Float -> VegaLite.MarkProperty"
            },
            {
                "name": "maStrokeOpacity",
                "comment": " Stroke opacity of a mark in the range 0 to 1.\n",
                "type": "Basics.Float -> VegaLite.MarkProperty"
            },
            {
                "name": "maStrokeWidth",
                "comment": " Stroke width of a mark in pixel units.\n",
                "type": "Basics.Float -> VegaLite.MarkProperty"
            },
            {
                "name": "maStyle",
                "comment": " Names of custom styles to apply to a mark. Each should refer to a named style\ndefined in a separate style configuration with [coMarkStyles](#coMarkStyles).\nWhile this is provided for compatibility with Vega-Lite style specification, for\ngreater type safety in elm-vegalite, instead create functions that generate\n[MarkProperties](#MarkProperty).\n",
                "type": "List.List String.String -> VegaLite.MarkProperty"
            },
            {
                "name": "maTension",
                "comment": " Interpolation tension used when interpolating line and area marks.\n",
                "type": "Basics.Float -> VegaLite.MarkProperty"
            },
            {
                "name": "maText",
                "comment": " Placeholder text for a text mark for when a text channel is not specified.\nMulti-line text can be specified by adding a `\\n` at each line break or by using\na `\"\"\"` multi-line string.\n",
                "type": "String.String -> VegaLite.MarkProperty"
            },
            {
                "name": "maTheta",
                "comment": " Polar coordinate angle (clockwise from north in radians) of an arc or text mark.\nIf a [text mark](#textMark) it represents polar coordinate angle relative to an\norigin determined by its x and y properties. For an [arc mark](#arc) it is its\nlength in radians or, when combined with [maTheta2](#maTheta2), the arc's start\nangle.\n",
                "type": "Basics.Float -> VegaLite.MarkProperty"
            },
            {
                "name": "maTheta2",
                "comment": " Polar coordinate angle (clockwise from north in radians) of the end of an\n[arc mark](#arc).\n",
                "type": "Basics.Float -> VegaLite.MarkProperty"
            },
            {
                "name": "maTheta2Offset",
                "comment": " Clockwise angular offset (in radians) of the second theta value of a radially\npositioned mark. Useful when the offsets to apply to the start and end angle of\nan arc need to be set independently.\n",
                "type": "Basics.Float -> VegaLite.MarkProperty"
            },
            {
                "name": "maThetaOffset",
                "comment": " Clockwise angular offset (in radians) of a radially positioned mark.\n",
                "type": "Basics.Float -> VegaLite.MarkProperty"
            },
            {
                "name": "maThickness",
                "comment": " Thickness of a tick mark.\n",
                "type": "Basics.Float -> VegaLite.MarkProperty"
            },
            {
                "name": "maTicks",
                "comment": " Tick properties for the errorbar or boxplot mark.\n",
                "type": "List.List VegaLite.MarkProperty -> VegaLite.MarkProperty"
            },
            {
                "name": "maTooltip",
                "comment": " Source of a mark's tooltip content.\n",
                "type": "VegaLite.TooltipContent -> VegaLite.MarkProperty"
            },
            {
                "name": "maUrl",
                "comment": " An image mark's URL.\n",
                "type": "String.String -> VegaLite.MarkProperty"
            },
            {
                "name": "maWidth",
                "comment": " Explicitly set the width of a mark (e.g. bar width)\n",
                "type": "Basics.Float -> VegaLite.MarkProperty"
            },
            {
                "name": "maWidthBand",
                "comment": " Set the width of a mark as a proportion of its band size. For example, to set\na bar width to be three quarters of its normal width,\n\n    bar [ maWidthBand 0.75 ]\n\n",
                "type": "Basics.Float -> VegaLite.MarkProperty"
            },
            {
                "name": "maX",
                "comment": " X position of a mark.\n",
                "type": "Basics.Float -> VegaLite.MarkProperty"
            },
            {
                "name": "maX2",
                "comment": " X2 position (secondary x value for lines and areal marks).\n",
                "type": "Basics.Float -> VegaLite.MarkProperty"
            },
            {
                "name": "maX2Offset",
                "comment": " X2 position offset for a mark.\n",
                "type": "Basics.Float -> VegaLite.MarkProperty"
            },
            {
                "name": "maXOffset",
                "comment": " X position offset for a mark.\n",
                "type": "Basics.Float -> VegaLite.MarkProperty"
            },
            {
                "name": "maY",
                "comment": " Y position of a mark.\n",
                "type": "Basics.Float -> VegaLite.MarkProperty"
            },
            {
                "name": "maY2",
                "comment": " Y2 position (secondary y value for lines and areal marks).\n",
                "type": "Basics.Float -> VegaLite.MarkProperty"
            },
            {
                "name": "maY2Offset",
                "comment": " Y2 position offset for a mark.\n",
                "type": "Basics.Float -> VegaLite.MarkProperty"
            },
            {
                "name": "maYOffset",
                "comment": " Y position offset for a mark.\n",
                "type": "Basics.Float -> VegaLite.MarkProperty"
            },
            {
                "name": "mercator",
                "comment": " A Mercator map projection. This is the default projection of longitude,latitude\nvalues if no projection is set explicitly. It preserves shape (local angle) and lines\nof equal angular bearing remain parallel straight lines. But area is significantly\nenlarged towards the poles.\n",
                "type": "VegaLite.Projection"
            },
            {
                "name": "miBasis",
                "comment": " Cubic basis spline interpolation between points anchored at first and last points.\n",
                "type": "VegaLite.MarkInterpolation"
            },
            {
                "name": "miBasisClosed",
                "comment": " Closed cubic basis spline interpolation between points forming a polygon.\n",
                "type": "VegaLite.MarkInterpolation"
            },
            {
                "name": "miBasisOpen",
                "comment": " Open cubic basis spline interpolation between points, which may not intersect\nfirst and last points.\n",
                "type": "VegaLite.MarkInterpolation"
            },
            {
                "name": "miBundle",
                "comment": " Bundle curve interpolation between points.\n",
                "type": "VegaLite.MarkInterpolation"
            },
            {
                "name": "miCardinal",
                "comment": " Cubic cardinal spline interpolation between points anchored at first and last\npoints.\n",
                "type": "VegaLite.MarkInterpolation"
            },
            {
                "name": "miCardinalClosed",
                "comment": " Closed cubic cardinal spline interpolation between points forming a polygon.\n",
                "type": "VegaLite.MarkInterpolation"
            },
            {
                "name": "miCardinalOpen",
                "comment": " Open cubic cardinal spline interpolation between points, which may not intersect\nfirst and last points\n",
                "type": "VegaLite.MarkInterpolation"
            },
            {
                "name": "miExpr",
                "comment": " Expression that evaluates to some interpolation method such as \"linear\", \"basis\"\nor \"monotone\".\n",
                "type": "String.String -> VegaLite.MarkInterpolation"
            },
            {
                "name": "miLinear",
                "comment": " Linear (straight) interpolation between points.\n",
                "type": "VegaLite.MarkInterpolation"
            },
            {
                "name": "miLinearClosed",
                "comment": " Linear (straight) interpolation between points that joins the first and last\npoints in a sequence to form a closed polygon.\n",
                "type": "VegaLite.MarkInterpolation"
            },
            {
                "name": "miMonotone",
                "comment": " Cubic spline interpolation that preserves monotonicity between points.\n",
                "type": "VegaLite.MarkInterpolation"
            },
            {
                "name": "miStepAfter",
                "comment": " Piecewise (stepped) constant interpolation function after each point in a sequence.\n",
                "type": "VegaLite.MarkInterpolation"
            },
            {
                "name": "miStepBefore",
                "comment": " Piecewise (stepped) constant interpolation function before each point in a sequence.\n",
                "type": "VegaLite.MarkInterpolation"
            },
            {
                "name": "miStepwise",
                "comment": " Piecewise (stepped) constant interpolation function centred on each point in\na sequence.\n",
                "type": "VegaLite.MarkInterpolation"
            },
            {
                "name": "milliseconds",
                "comment": " Milliseconds time unit used for discretizing temporal data.\n",
                "type": "VegaLite.TimeUnit"
            },
            {
                "name": "minutes",
                "comment": " Minute of the hour time unit used for discretizing temporal data.\n",
                "type": "VegaLite.TimeUnit"
            },
            {
                "name": "minutesSeconds",
                "comment": " Minutes and seconds time unit used for discretizing temporal data.\n",
                "type": "VegaLite.TimeUnit"
            },
            {
                "name": "moHorizontal",
                "comment": " Indicate horizontal mark orientation.\n",
                "type": "VegaLite.MarkOrientation"
            },
            {
                "name": "moVertical",
                "comment": " Indicate vertical mark orientation.\n",
                "type": "VegaLite.MarkOrientation"
            },
            {
                "name": "month",
                "comment": " Month of the year used for discretizing temporal data. This will ignore year so\nuseful for looking at monthly seasonal patterns through the year.\n",
                "type": "VegaLite.TimeUnit"
            },
            {
                "name": "monthDate",
                "comment": " Day of the year for discretizing temporal data. This will ignore year so useful\nfor looking at seasonal patterns through the year.\n",
                "type": "VegaLite.TimeUnit"
            },
            {
                "name": "monthDateHours",
                "comment": " Hour of the year used for discretizing temporal data. This will ignore year so\nuseful for looking at seasonal patterns with hourly resolution.\n",
                "type": "VegaLite.TimeUnit"
            },
            {
                "name": "monthDateHoursMinutes",
                "comment": " Minute of the year used for discretizing temporal data. This will ignore year\nso useful for looking at seasonal patterns with one-minute resolution.\n",
                "type": "VegaLite.TimeUnit"
            },
            {
                "name": "monthDateHoursMinutesSeconds",
                "comment": " Second of the year used for discretizing temporal data. This will ignore year\nso useful for looking at seasonal patterns with one-second resolution.\n",
                "type": "VegaLite.TimeUnit"
            },
            {
                "name": "name",
                "comment": " Name to be associated with a visualization.\n",
                "type": "String.String -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "naturalEarth1",
                "comment": " A natural earth map projection.\n",
                "type": "VegaLite.Projection"
            },
            {
                "name": "niDay",
                "comment": " Nice time intervals that try to align with whole or rounded days.\n",
                "type": "VegaLite.ScaleNice"
            },
            {
                "name": "niExpr",
                "comment": " Specify nice scaling with an expression that evaluates to a valid nice property\n(e.g. a number or time interval)\n",
                "type": "String.String -> VegaLite.ScaleNice"
            },
            {
                "name": "niFalse",
                "comment": " Disable nice scaling.\n",
                "type": "VegaLite.ScaleNice"
            },
            {
                "name": "niHour",
                "comment": " Nice time intervals that try to align with whole or rounded hours.\n",
                "type": "VegaLite.ScaleNice"
            },
            {
                "name": "niInterval",
                "comment": " 'Nice' temporal interval values when scaling.\n",
                "type": "VegaLite.TimeUnit -> Basics.Int -> VegaLite.ScaleNice"
            },
            {
                "name": "niMillisecond",
                "comment": " Nice time intervals that try to align with rounded milliseconds.\n",
                "type": "VegaLite.ScaleNice"
            },
            {
                "name": "niMinute",
                "comment": " Nice time intervals that try to align with whole or rounded minutes.\n",
                "type": "VegaLite.ScaleNice"
            },
            {
                "name": "niMonth",
                "comment": " Nice time intervals that try to align with whole or rounded months.\n",
                "type": "VegaLite.ScaleNice"
            },
            {
                "name": "niSecond",
                "comment": " Nice time intervals that try to align with whole or rounded seconds.\n",
                "type": "VegaLite.ScaleNice"
            },
            {
                "name": "niTickCount",
                "comment": " Desired number of tick marks in a 'nice' scaling.\n",
                "type": "Basics.Int -> VegaLite.ScaleNice"
            },
            {
                "name": "niTrue",
                "comment": " Enable nice scaling.\n",
                "type": "VegaLite.ScaleNice"
            },
            {
                "name": "niWeek",
                "comment": " Nice time intervals that try to align with whole or rounded weeks.\n",
                "type": "VegaLite.ScaleNice"
            },
            {
                "name": "niYear",
                "comment": " Nice time intervals that try to align with whole or rounded years.\n",
                "type": "VegaLite.ScaleNice"
            },
            {
                "name": "noClip",
                "comment": " Indicate no clipping to be applied.\n",
                "type": "VegaLite.ClipRect"
            },
            {
                "name": "noData",
                "comment": " Ignore the data of a specification's parent when used in a composed spec.\n",
                "type": "VegaLite.Data"
            },
            {
                "name": "not",
                "comment": " Apply a negation Boolean operation as part of a logical composition. Boolean\noperations can be nested to any level.\n\n    not (and (expr \"datum.IMDB_Rating === null\") (expr \"datum.Rotten_Tomatoes_Rating === null\"))\n\n",
                "type": "VegaLite.BooleanOp -> VegaLite.BooleanOp"
            },
            {
                "name": "nullValue",
                "comment": " An unspecified data value. Can be useful when explicitly recoding a value as\nundefined.\n\n    data =\n        dataFromRows []\n            << dataRow [ ( \"x\", num 1 ), ( \"y\", num 10 ) ]\n            << dataRow [ ( \"x\", num 2 ), ( \"y\", nullValue ) ]\n            << dataRow [ ( \"x\", num 3 ), ( \"y\", num 30 ) ]\n\nFor more complex data sources that contain lists of defined and unspecified values,\nconsider using [dataFromJson](#dataFromJson) instead.\n\n",
                "type": "VegaLite.DataValue"
            },
            {
                "name": "num",
                "comment": " A numeric data value.\n",
                "type": "Basics.Float -> VegaLite.DataValue"
            },
            {
                "name": "numRange",
                "comment": " Minimum-maximum number range to be used in data filtering.\n",
                "type": "Basics.Float -> Basics.Float -> VegaLite.FilterRange"
            },
            {
                "name": "nums",
                "comment": " List of numeric data values. Used when declaring inline data with\n[dataColumn](#dataColumn), filtering ([fiOneOf](#fiOneOf)), imputation\n([imKeyVals](#imKeyVals)) and customised sorting ([soCustom](#soCustom)).\n",
                "type": "List.List Basics.Float -> VegaLite.DataValues"
            },
            {
                "name": "oAggregate",
                "comment": " Compute some aggregate summary statistics for a field to be encoded with an\norder channel. The type of aggregation is determined by the given operation\nparameter.\n",
                "type": "VegaLite.Operation -> VegaLite.OrderChannel"
            },
            {
                "name": "oBin",
                "comment": " Discretize numeric values into bins when encoding with an order channel.\n",
                "type": "List.List VegaLite.BinProperty -> VegaLite.OrderChannel"
            },
            {
                "name": "oCondition",
                "comment": " Make an order channel encoding conditional on a predicate expression. A predicate\nmight be the result of evaluating a parameter ([prParam](#prParam)) or an expression\n([prTest](#prTest)). The first parameter is the predicate that evaluates to true\nor false; the second the encoding if true, the third the encoding if false.\n\nFor example, to bring marks of an interactively selected colour to the front:\n\n    ps =\n        params\n            << param \"sel\" [ paSelect sePoint [ seEncodings [ chColor ] ] ]\n\n    enc =\n        encoding\n            << order [ oCondition (prParam \"sel\") [ oNum 1 ] [ oNum 0 ] ]\n\n",
                "type": "VegaLite.Predicate -> List.List VegaLite.OrderChannel -> List.List VegaLite.OrderChannel -> VegaLite.OrderChannel"
            },
            {
                "name": "oConditions",
                "comment": " Make an order channel conditional on a sequence of predicate values. This can\nbe used when several predicates need to be tested in sequence each with their\nown encoding outcomes ('if-else'). For example to control mark z-order for three\ncategory values:\n\n    order\n        [ oConditions\n            [ ( prTest (expr \"datum.Origin == 'Europe'\"), [ oNum 3 ] )\n            , ( prTest (expr \"datum.Origin == 'Japan'\"), [ oNum 2 ] )\n            ]\n            [ oNum 1 ]\n        ]\n\n",
                "type": "List.List ( VegaLite.Predicate, List.List VegaLite.OrderChannel ) -> List.List VegaLite.OrderChannel -> VegaLite.OrderChannel"
            },
            {
                "name": "oGeo",
                "comment": " Indicate a data field encoded with an order channel is a geo feature.\n",
                "type": "VegaLite.OrderChannel"
            },
            {
                "name": "oName",
                "comment": " Name of field used for encoding with an order channel.\n",
                "type": "String.String -> VegaLite.OrderChannel"
            },
            {
                "name": "oNominal",
                "comment": " Indicate a data field encoded with an order channel is nominal.\n",
                "type": "VegaLite.OrderChannel"
            },
            {
                "name": "oNum",
                "comment": " Specify a literal numeric value for an order channel. Useful for setting a\nconditional z-order with interaction to bring selected feature to 'front'.\n",
                "type": "Basics.Float -> VegaLite.OrderChannel"
            },
            {
                "name": "oOrdinal",
                "comment": " Indicate a data field encoded with an order channel is ordinal.\n",
                "type": "VegaLite.OrderChannel"
            },
            {
                "name": "oQuant",
                "comment": " Indicate a data field encoded with an order channel is quantitative.\n",
                "type": "VegaLite.OrderChannel"
            },
            {
                "name": "oRepeat",
                "comment": " Reference in a order channel to a field name generated by [repeatFlow](#repeatFlow)\nor [repeat](#repeat). The parameter identifies whether reference is being made to\nfields that are to be arranged in columns, in rows or a with a flow layout.\n",
                "type": "VegaLite.Arrangement -> VegaLite.OrderChannel"
            },
            {
                "name": "oSort",
                "comment": " Sort order to be used by an order channel.\n",
                "type": "List.List VegaLite.SortProperty -> VegaLite.OrderChannel"
            },
            {
                "name": "oTemporal",
                "comment": " Indicate a data field encoded with an order channel is temporal.\n",
                "type": "VegaLite.OrderChannel"
            },
            {
                "name": "oTimeUnit",
                "comment": " Time unit aggregation of field values when encoding with an order channel.\n",
                "type": "VegaLite.TimeUnit -> VegaLite.OrderChannel"
            },
            {
                "name": "opArgMax",
                "comment": " An input data object containing the minimum field value to be used in an\naggregation operation. If supplied as part of an encoding aggregation, the parameter\nshould be `Just` the name of the field to maximise. For example, the following would\nfind the production budget for the maximum US grossing film in each genre:\n\n    encoding\n        << position X\n            [ pName \"Production_Budget\"\n            , pQuant\n            , pAggregate (opArgMax (Just \"US_Gross\"))\n            ]\n        << position Y [ pName \"Major_Genre\", pNominal ]\n\nIf supplied as part of a transform, the parameter should be `Nothing` as the field\nis specified in the [aggregate](#aggregate) parameter.\n\n    trans =\n        transform\n            << aggregate\n                [ opAs (opArgMax Nothing) \"US_Gross\" \"amUSGross\" ]\n                [ \"Major_Genre\" ]\n\n",
                "type": "Maybe.Maybe String.String -> VegaLite.Operation"
            },
            {
                "name": "opArgMin",
                "comment": " An input data object containing the minimum field value to be used in an\naggregation operation.\n",
                "type": "Maybe.Maybe String.String -> VegaLite.Operation"
            },
            {
                "name": "opAs",
                "comment": " Aggregation operation. The first parameter is the operation to use; the second\nthe name of the field in which to apply it and the third the name to be given to\nthis transformation.\n\n    trans =\n        transform\n            << aggregate\n                [ opAs opMin \"people\" \"lowerBound\"\n                , opAs opMax \"people\" \"upperBound\"\n                ]\n                [ \"age\" ]\n\nIf the operation is `Count`, it does not apply to any specific field, so the second\nparameter can be an empty string.\n\n",
                "type": "VegaLite.Operation -> String.String -> String.String -> VegaLite.Spec"
            },
            {
                "name": "opCI0",
                "comment": " Lower 95% confidence interval to be used in an aggregation operation.\n",
                "type": "VegaLite.Operation"
            },
            {
                "name": "opCI1",
                "comment": " Upper 95% confidence interval to be used in an aggregation operation.\n",
                "type": "VegaLite.Operation"
            },
            {
                "name": "opCount",
                "comment": " Total count of data objects to be used in an aggregation operation.\n",
                "type": "VegaLite.Operation"
            },
            {
                "name": "opDistinct",
                "comment": " Count of distinct data objects to be used in an aggregation operation.\n",
                "type": "VegaLite.Operation"
            },
            {
                "name": "opMax",
                "comment": " Maximum field value to be used in an aggregation operation.\n",
                "type": "VegaLite.Operation"
            },
            {
                "name": "opMean",
                "comment": " Mean value to be used in an aggregation operation.\n",
                "type": "VegaLite.Operation"
            },
            {
                "name": "opMedian",
                "comment": " Median field value to be used in an aggregation operation.\n",
                "type": "VegaLite.Operation"
            },
            {
                "name": "opMin",
                "comment": " Minimum field value to be used in an aggregation operation.\n",
                "type": "VegaLite.Operation"
            },
            {
                "name": "opMissing",
                "comment": " Count of null or undefined field value to be used in an aggregation operation.\n",
                "type": "VegaLite.Operation"
            },
            {
                "name": "opProduct",
                "comment": " Product of field values to be used in an aggregation operation.\n",
                "type": "VegaLite.Operation"
            },
            {
                "name": "opQ1",
                "comment": " Lower quartile boundary of field values to be used in an aggregation operation.\n",
                "type": "VegaLite.Operation"
            },
            {
                "name": "opQ3",
                "comment": " Upper quartile boundary of field values to be used in an aggregation operation.\n",
                "type": "VegaLite.Operation"
            },
            {
                "name": "opStderr",
                "comment": " Standard error of field values to be used in an aggregation operation.\n",
                "type": "VegaLite.Operation"
            },
            {
                "name": "opStdev",
                "comment": " Sample standard deviation of field values to be used in an aggregation operation.\n",
                "type": "VegaLite.Operation"
            },
            {
                "name": "opStdevP",
                "comment": " Population standard deviation of field values to be used in an aggregation operation.\n",
                "type": "VegaLite.Operation"
            },
            {
                "name": "opSum",
                "comment": " Sum of field values to be used in an aggregation operation.\n",
                "type": "VegaLite.Operation"
            },
            {
                "name": "opValid",
                "comment": " Count of values that are not `null`, `undefined` or `NaN` to be used in an\naggregation operation.\n",
                "type": "VegaLite.Operation"
            },
            {
                "name": "opVariance",
                "comment": " Sample variance of field value to be used in an aggregation operation.\n",
                "type": "VegaLite.Operation"
            },
            {
                "name": "opVarianceP",
                "comment": " Population variance of field value to be used in an aggregation operation.\n",
                "type": "VegaLite.Operation"
            },
            {
                "name": "opacity",
                "comment": " Encode an opacity channel.\n",
                "type": "List.List VegaLite.MarkChannel -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"
            },
            {
                "name": "or",
                "comment": " Apply an 'or' Boolean operation as part of a logical composition.\n",
                "type": "VegaLite.BooleanOp -> VegaLite.BooleanOp -> VegaLite.BooleanOp"
            },
            {
                "name": "order",
                "comment": " Encode an order channel. The first parameter is a list of order encoding\noptions such as the data to encode, sort direction etc.\n\n    enc =\n        encoding\n            << order [ oName \"yield\", oOrdinal, oSort [ soDescending ] ]\n\n",
                "type": "List.List VegaLite.OrderChannel -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"
            },
            {
                "name": "orthographic",
                "comment": " An orthographic map projection.\n",
                "type": "VegaLite.Projection"
            },
            {
                "name": "osExpr",
                "comment": " Specify an overlap strategy with an expression that should evaluate to one\nof True, False, \"parity\" or \"greedy\". If using an input element such as [ipSelect](#ipSelect)\nto allow all options, the mixed option types should be defined with [inDatumOptions](#inDatumOptions),\nfor example:\n\n    ipSelect\n        [ inName \"Label overlap\"\n        , inDatumOptions [ boo False, str \"parity\", str \"greedy\" ]\n        ]\n\n",
                "type": "String.String -> VegaLite.OverlapStrategy"
            },
            {
                "name": "osGreedy",
                "comment": " Greedy overlap strategy to be applied when there is not space to show all items on an axis.\n",
                "type": "VegaLite.OverlapStrategy"
            },
            {
                "name": "osNone",
                "comment": " No overlap strategy to be applied when there is not space to show all items on an axis.\n",
                "type": "VegaLite.OverlapStrategy"
            },
            {
                "name": "osParity",
                "comment": " Give all items equal weight in overlap strategy to be applied when there is\nnot space to show them all on an axis.\n",
                "type": "VegaLite.OverlapStrategy"
            },
            {
                "name": "pAggregate",
                "comment": " Compute some aggregate summary statistics for a field to be encoded with a\nposition channel. The type of aggregation is determined by the given operation\nparameter.\n\n    enc =\n        encoding\n            << position X [ pName \"role\", pOrdinal ]\n            << position Y [ pName \"salary\", pQuant, pAggregate opMean ]\n\n",
                "type": "VegaLite.Operation -> VegaLite.PositionChannel"
            },
            {
                "name": "pAxis",
                "comment": " Axis properties used when encoding with a position channel. For no axis,\nprovide an empty list.\n",
                "type": "List.List VegaLite.AxisProperty -> VegaLite.PositionChannel"
            },
            {
                "name": "pBandPosition",
                "comment": " Specify mark position or size relative to band size. For non-rect marks,\nthe relative position on a band of a stacked, binned, time unit or band scale is\nused. A value of 0, positions the mark at the beginning of the band; 0.5, in the\nmiddle etc.\n\nFor rect-based marks (rect, bar, and image), if set to 1, the mark size is set\nto the band width or the time unit interval. If set to 0.5, the mark size is half\nof the bandwidth or the time unit interval. etc.\n\n",
                "type": "Basics.Float -> VegaLite.PositionChannel"
            },
            {
                "name": "pBin",
                "comment": " Discretize numeric values into bins when encoding with a position channel.\nFor non-default binning, bin-widths, extent etc. can be specified in the first\nparameter. For example, to encode a frequency histogram with bins every 5 units:\n\n    enc =\n        encoding\n            << position X [ pName \"x\", pOrdinal, pBin [ biStep 5 ] ]\n            << position Y [ pQuant, pAggregate opCount ]\n\n",
                "type": "List.List VegaLite.BinProperty -> VegaLite.PositionChannel"
            },
            {
                "name": "pBinned",
                "comment": " Indicate that data encoded with position are already binned.\n",
                "type": "VegaLite.PositionChannel"
            },
            {
                "name": "pDatum",
                "comment": " Set a position to an arbitrary data value. Useful for placing items at the\nspecific points in the data space. To place in data screen space, use [pNum](#pNum).\n",
                "type": "VegaLite.DataValue -> VegaLite.PositionChannel"
            },
            {
                "name": "pGeo",
                "comment": " Indicate a data field encoded as a position is a geo feature.\n",
                "type": "VegaLite.PositionChannel"
            },
            {
                "name": "pHeight",
                "comment": " Set the position to the height of the enclosing data space. Useful for placing\na mark relative to the bottom edge of a view.\n",
                "type": "VegaLite.PositionChannel"
            },
            {
                "name": "pImpute",
                "comment": " Imputation rules for a position channel. See the\n[Vega-Lite impute documentation](https://vega.github.io/vega-lite/docs/impute.html)\nFor example, to impute the missing value of `b` with the mean of existing `b` values,\nwhen `a` is 30 and its color group (`c`) is 1:\n\n    let\n        data =\n            dataFromColumns []\n                << dataColumn \"a\" (nums [ 0, 0, 10, 10, 20, 20, 30 ])\n                << dataColumn \"b\" (nums [ 28, 91, 43, 55, 81, 53, 19 ])\n                << dataColumn \"c\" (nums [ 0, 1, 0, 1, 0, 1, 0 ])\n\n        enc =\n            encoding\n                << position X [ pName \"a\", pQuant ]\n                << position Y [ pName \"b\", pQuant, pImpute [ imMethod imMean ] ]\n                << color [ mName \"c\", mNominal ]\n    in\n    toVegaLite [ data [], enc [], line [] ]\n\n",
                "type": "List.List VegaLite.ImputeProperty -> VegaLite.PositionChannel"
            },
            {
                "name": "pName",
                "comment": " Name of field used for encoding with a position channel.\n",
                "type": "String.String -> VegaLite.PositionChannel"
            },
            {
                "name": "pNominal",
                "comment": " Indicate a data field encoded as a position is nominal. This is the\ndefault data type.\n",
                "type": "VegaLite.PositionChannel"
            },
            {
                "name": "pNum",
                "comment": " Set a position to an arbitrary value. Useful for placing items at the top of\na plot area (`pNum 0`) or a fixed number of pixels from the top. To place in data\nspace rather than screen space, use [pDatum](#pDatum).\n",
                "type": "Basics.Float -> VegaLite.PositionChannel"
            },
            {
                "name": "pOrdinal",
                "comment": " Indicate a data field encoded as a position is ordinal.\n",
                "type": "VegaLite.PositionChannel"
            },
            {
                "name": "pQuant",
                "comment": " Indicate a data field encoded as a position is quantitative. This is not necessary\nwhen field is aggregated by a numeric operator (e.g. [opSum](#opSum)), scaled with a\nnumeric operator (e.g. [scLog](#scLog)), a position field is longitude/latitude or it\nis binned numerically.\n",
                "type": "VegaLite.PositionChannel"
            },
            {
                "name": "pRepeat",
                "comment": " Reference in a position channel to a field name generated by [repeatFlow](#repeatFlow)\nor [repeat](#repeat). The parameter identifies whether reference is being made to\nfields that are to be encoded in layers, or in columns / rows with a flow layout.\n\n    enc =\n        encoding\n            << position X [ pRepeat arFlow, pQuant ]\n\n    spec =\n          asSpec [ data [], tick [], enc [] ]\n\n    toVegaLite\n        [ repeatFlow [ \"Horsepower\", \"Miles_per_Gallon\", \"Acceleration\"]\n        , specification spec\n        ]\n\n",
                "type": "VegaLite.Arrangement -> VegaLite.PositionChannel"
            },
            {
                "name": "pRepeatDatum",
                "comment": " Reference in a position channel to a datum value generated by [repeat](#repeat).\n",
                "type": "VegaLite.Arrangement -> VegaLite.PositionChannel"
            },
            {
                "name": "pScale",
                "comment": " Scaling applied to a field when encoding with a position channel.\nThe scale will transform a field's value into a position along one axis.\n\nFor example, the following will scale the bars positioned along a horizontal axis\nto have an inner spacing of 50% (0.5) of the total space allocated to each bar:\n\n    enc =\n        encoding\n            << position X [ pName \"ageGroup\", pNominal, pScale [ scPaddingInner 0.5 ] ]\n\n",
                "type": "List.List VegaLite.ScaleProperty -> VegaLite.PositionChannel"
            },
            {
                "name": "pSort",
                "comment": " Sort order for field when encoding with a position channel.\n",
                "type": "List.List VegaLite.SortProperty -> VegaLite.PositionChannel"
            },
            {
                "name": "pStack",
                "comment": " Type of stacking offset for field when encoding with a position channel. For\nexample, stacking areas away from a centre-line can be used to create a\n[streamgraph](https://vega.github.io/vega-lite/examples/stacked_area_stream.html):\n\n    enc =\n        encoding\n            << position X [ pName \"week\", pOrdinal ]\n            << position Y [ pName \"takings\", pQuant, pStack stCenter ]\n            << color [ mName \"shop\", mNominal ]\n\n",
                "type": "VegaLite.StackOffset -> VegaLite.PositionChannel"
            },
            {
                "name": "pTemporal",
                "comment": " Indicate a data field encoded as a position is temporal. This is not necessary\nif the field is aggregated with a time unit (e.g. [pTimeUnit](#pTimeUnit)) or scaled\nwith [scTime](#scTime) or [scUtc](#scUtc).\n",
                "type": "VegaLite.PositionChannel"
            },
            {
                "name": "pTimeUnit",
                "comment": " Form of time unit aggregation of field values when encoding with a position channel.\n",
                "type": "VegaLite.TimeUnit -> VegaLite.PositionChannel"
            },
            {
                "name": "pTitle",
                "comment": " Title of a field when encoding with a position channel. For multi-line titles,\ninsert `\\n` at each line break or use a `\"\"\"` multi-line string.\n",
                "type": "String.String -> VegaLite.PositionChannel"
            },
            {
                "name": "pWidth",
                "comment": " Set the position to the width of the enclosing data space. Useful for justifying\na mark to the right hand edge of a view. e.g. to position a mark at the right of\nthe data rectangle:\n\n    enc =\n        encoding\n            << position X [ pWidth ]\n\n",
                "type": "VegaLite.PositionChannel"
            },
            {
                "name": "paBind",
                "comment": " The dynamic binding associated with a parameter. Can be used to create a parameter\nvalue that varies as an interactive input control (e.g. slider) is updated. For\ndetails see the [Vega-Lite binding documentation](https://vega.github.io/vega-lite/docs/bind.html)\n\n    param \"mySlider\"\n        [ paSelect sePoint []\n        , paBind (ipRange [ inMin 1, inMax 10 ])\n        ]\n\n",
                "type": "VegaLite.PBinding -> VegaLite.ParamProperty"
            },
            {
                "name": "paBindLegend",
                "comment": " Bind a named parameter selection to a legend for interactive selection of\nfield values from a legend. Can be bound to a field or channel. For example the\nfollowing will bind a color legend to a point selection allowing filtering or\nhighlighting by the selected value that has been encoded with color.\n\n    ps =\n        params\n            << param \"legSel\"\n                [ paSelect sePoint [ seEncodings [ chColor ] ]\n                , paBindLegend \"\"\n                ]\n\nTo customise which events should trigger legend interaction, provide a\n[Vega event stream string](https://vega.github.io/vega/docs/event-streams/). If an\nempty string is provided, the default single-click interaction is used.\n\nFor example, to allow legend selection with a double click:\n\n    paBindLegend \"dblClick\"\n\nor with shift-click:\n\n    paBindLegend \"click[event.shiftKey]\"\n\n",
                "type": "String.String -> VegaLite.ParamProperty"
            },
            {
                "name": "paBindScales",
                "comment": " Bind a named parameter selection to the scales of a view to allow interactive\nzooming and panning. For example,\n\n    ps =\n        params\n            << param \"zoomer\" [ paSelect seInterval [], paBindScales ]\n\n",
                "type": "VegaLite.ParamProperty"
            },
            {
                "name": "paBindings",
                "comment": " One or more named dynamic bindings associated with a parameter.\nUnlike [paBind](#paBind), this allows multiple input elements to be bound to the\nsame field. For example, to bind a selection to the 'And' selection of two sliders:\n\n    param \"CylYr\"\n        [ paSelect sePoint [ seFields [ \"Cylinders\", \"Year\" ] ]\n        , paBindings\n            [ ( \"Cylinders\", ipRange [ inMin 3, inMax 8, inStep 1 ] )\n            , ( \"Year\", ipRange [ inMin 1969, inMax 1981, inStep 1 ] )\n            ]\n        ]\n\n",
                "type": "List.List ( String.String, VegaLite.PBinding ) -> VegaLite.ParamProperty"
            },
            {
                "name": "paEdges",
                "comment": " Padding around a visualization in pixel units. The four parameters\nrefer to _left_, _top_, _right_, and _bottom_ edges respectively.\n",
                "type": "Basics.Float -> Basics.Float -> Basics.Float -> Basics.Float -> VegaLite.Padding"
            },
            {
                "name": "paEdgesExpr",
                "comment": " Expressions that each evaluate to a numeric values indicating padding around\na visualization in pixel units. The four parameters refer to _left_, _top_, _right_\nand _bottom_ edges respectively. Can be useful when padding is to be determined\ninteractively through input elements.\n",
                "type": "String.String -> String.String -> String.String -> String.String -> VegaLite.Padding"
            },
            {
                "name": "paExpr",
                "comment": " Initial value of a parameter specified as a\n[Vega expression](https://vega.github.io/vega/docs/expressions).\n",
                "type": "String.String -> VegaLite.ParamProperty"
            },
            {
                "name": "paNumExpr",
                "comment": " Provide an [expression](https://vega.github.io/vega/docs/expressions/) to a\npadding property function requiring a numeric value such as [paSize](#paSize).\n",
                "type": "String.String -> (number -> VegaLite.Padding) -> VegaLite.Padding"
            },
            {
                "name": "paSelect",
                "comment": " Specify a selection parameter to be used for interaction. For example, to create\nan interval selection:\n\n    param \"mySelection\" [ paSelect seInterval [] ]\n\nTo project a point selection across the field encoded with colour:\n\n    param \"mySelection\" [ paSelect sePoint [ seEncodings [ chColor ] ] ]\n\n",
                "type": "VegaLite.Selection -> List.List VegaLite.SelectionProperty -> VegaLite.ParamProperty"
            },
            {
                "name": "paSize",
                "comment": " Indicate uniform padding around a visualization in pixel units.\n",
                "type": "Basics.Float -> VegaLite.Padding"
            },
            {
                "name": "paValue",
                "comment": " Initial value of a parameter.\n",
                "type": "VegaLite.DataValue -> VegaLite.ParamProperty"
            },
            {
                "name": "paValues",
                "comment": " Initial set of values of a parameter. Useful for passing to functions that require a\nlist of values.\n",
                "type": "VegaLite.DataValues -> VegaLite.ParamProperty"
            },
            {
                "name": "padding",
                "comment": " Padding around the visualization in pixel units. The way padding is interpreted\nwill depend on the `autosize` properties.\n",
                "type": "VegaLite.Padding -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "param",
                "comment": " Add a named parameter to a list of parameters. A parameter should have a name\nand a list of parameter details. For example,\n\n    param \"mySelection\" [ paSelect seInterval [] ]\n\n",
                "type": "String.String -> List.List VegaLite.ParamProperty -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"
            },
            {
                "name": "params",
                "comment": " Specify top-level parameters to be used within a specification. While literals\nmay be specified as parameters, these are better handled directly in Elm. More\nuseful expression parameters are those that use the\n[vega-lite built-in parameters](https://vega.github.io/vega-lite/docs/parameter.html#built-in-variable-parameters)\n`width`, `height`, `padding`, `autosize`, `background` and `cursor`. For example\nto keep text size a fixed proportion of the plot height:\n\n    ps =\n        params\n            << param \"textSize\" [ paExpr \"height/20\" ]\n\nAlso useful is the ability to bind parameters to input elements such as range\nsliders that may be updated at runtime. For example the value of the `radius` parameter\nis determined by the slider position and then used as a mark property to alter\ncircle size dynamically:\n\n    let\n        ps =\n            params\n                << param \"radius\"\n                    [ paValue (num 0)\n                    , paBind (ipRange [ inMax 100 ])\n                    ]\n\n        enc =\n            encoding\n                << position Theta [ pName \"value\", pQuant ]\n                << color [ mName \"category\" ]\n    in\n    toVegaLite\n        [ ps []\n        , data []\n        , enc []\n        , arc [ maNumExpr \"radius\" maInnerRadius ]\n        ]\n\n",
                "type": "List.List VegaLite.LabelledSpec -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "parse",
                "comment": " Parsing rules when processing some data text, specified as a list of tuples\nin the form (_fieldName_, _dataType_). Useful when automatic type inference needs\nto be overridden, for example when converting integers representing years into dates\nand strings into numbers:\n\n    data =\n        dataFromUrl \"myDataFile.csv\"\n            [ parse [ ( \"year\", foDate \"%Y\" ), ( \"y\", foNum ) ] ]\n\n",
                "type": "List.List ( String.String, VegaLite.DataType ) -> VegaLite.Format"
            },
            {
                "name": "piGroupBy",
                "comment": " The data fields to group by when pivoting. If not specified, a single group\ncontaining all data objects will be used.\n",
                "type": "List.List String.String -> VegaLite.PivotProperty"
            },
            {
                "name": "piLimit",
                "comment": " Maximum number of fields to generate when pivoting. If 0 or unspecified, all\nfields are pivoted. The pivot names are sorted in ascending order before any limit\nis applied.\n",
                "type": "Basics.Int -> VegaLite.PivotProperty"
            },
            {
                "name": "piOp",
                "comment": " The aggregation to apply to grouped fields during a pivot.\n",
                "type": "VegaLite.Operation -> VegaLite.PivotProperty"
            },
            {
                "name": "pivot",
                "comment": " Perform a _pivot_ operation on a table. Spreads a key-value pair of fields across\nmultiple fields according to the data in the _key_ field. The first two parameters\nare the key and value fields respectively. The third is a set of customisation options.\nThis performs the same function as\n['spread' in the Tidy Elm package](https://package.elm-lang.org/packages/gicentre/tidy/latest/Tidy#spread)\nand the [pivot\\_wider](https://tidyr.tidyverse.org/dev/articles/pivot.html) /\n[spread](https://tidyr.tidyverse.org/reference/spread.html) operation in the R\ntidyverse. It is the inverse of [fold](#fold).\n\n    data =\n        dataFromColumns []\n            << dataColumn \"city\" (strs [ \"Bristol\", \"Bristol\", \"Sheffield\", \"Sheffield\", \"Glasgow\", \"Glasgow\" ])\n            << dataColumn \"temperature\" (nums [ 12, 14, 11, 13, 7, 10 ])\n            << dataColumn \"year\" (nums [ 2017, 2018, 2017, 2018, 2017, 2018 ])\n\n    trans =\n        transform\n            << pivot \"year\" \"temperature\" [ piGroupBy [ \"city\" ] ]\n\n    enc =\n        encoding\n            -- 2017 temperatures for the Bristol, Sheffield and Glasgow\n            << position X [ pName \"2017\", pQuant ]\n            << position Y [ pName \"city\", pNominal ]\n\n",
                "type": "String.String -> String.String -> List.List VegaLite.PivotProperty -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"
            },
            {
                "name": "pmMarker",
                "comment": " Properties of a point marker that is overlaid on a line or area mark. Used\nwhen specifying an [maPoint](#maPoint).\n",
                "type": "List.List VegaLite.MarkProperty -> VegaLite.PointMarker"
            },
            {
                "name": "pmNone",
                "comment": " No point marker to be shown on a line or area mark.\n",
                "type": "VegaLite.PointMarker"
            },
            {
                "name": "pmTransparent",
                "comment": " Transparent point marker to be placed on area or line mark. Useful for\ninteractive selections.\n",
                "type": "VegaLite.PointMarker"
            },
            {
                "name": "point",
                "comment": " [Point mark](https://vega.github.io/vega-lite/docs/point.html) for\nsymbolising a data point with a symbol.\n",
                "type": "List.List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "position",
                "comment": " Encode a position channel. The first parameter identifies the channel, the\nsecond a list of position encoding options.\n\n    enc =\n        encoding\n            << position X [ pName \"month\", pTemporal ]\n            << position Y [ pName \"numHires\", pQuant ]\n\n",
                "type": "VegaLite.Position -> List.List VegaLite.PositionChannel -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"
            },
            {
                "name": "prCenter",
                "comment": " Projection’s center as longitude and latitude in degrees.\n",
                "type": "Basics.Float -> Basics.Float -> VegaLite.ProjectionProperty"
            },
            {
                "name": "prCenterExpr",
                "comment": " Specify a projection’s centre with two expressions that should evaluate to\na longitude and latitude respectively.\n",
                "type": "String.String -> String.String -> VegaLite.ProjectionProperty"
            },
            {
                "name": "prClipAngle",
                "comment": " Projection’s clipping circle radius to the specified angle in degrees.\nA value of 0 will switch to antimeridian cutting rather than small-circle\nclipping.\n",
                "type": "Basics.Float -> VegaLite.ProjectionProperty"
            },
            {
                "name": "prClipExtent",
                "comment": " Projection’s viewport clip extent to the specified bounds in pixels.\n",
                "type": "VegaLite.ClipRect -> VegaLite.ProjectionProperty"
            },
            {
                "name": "prCoefficient",
                "comment": " 'Hammer' map projection coefficient.\n",
                "type": "Basics.Float -> VegaLite.ProjectionProperty"
            },
            {
                "name": "prDistance",
                "comment": " 'Satellite' map projection distance.\n",
                "type": "Basics.Float -> VegaLite.ProjectionProperty"
            },
            {
                "name": "prExpr",
                "comment": " Specify a map projection with an expression that evaluates to a valid projection\nname.\n",
                "type": "String.String -> VegaLite.Projection"
            },
            {
                "name": "prFit",
                "comment": " Adjust map projection to fit the given geoShape within the display area. The\ngeoShape can be a feature collection, a single feature or array of features. This\nis usually easier than adjusting a projection's [prScale](#prScale) and\n[prTranslate](#prTranslate). For example,\n\n    geoFrame =\n        geometry (geoPoints [ ( -8, 60 ), ( 1, 47 ) ])\n            []\n\n    proj =\n        projection [ prFit geoFrame ]\n\n",
                "type": "VegaLite.Spec -> VegaLite.ProjectionProperty"
            },
            {
                "name": "prFraction",
                "comment": " `Bottomley` map projection fraction.\n",
                "type": "Basics.Float -> VegaLite.ProjectionProperty"
            },
            {
                "name": "prLobes",
                "comment": " Number of lobes in lobed map projections such as the 'Berghaus star'.\n",
                "type": "Basics.Int -> VegaLite.ProjectionProperty"
            },
            {
                "name": "prNumExpr",
                "comment": " Provide an [expression](https://vega.github.io/vega/docs/expressions/) to\na map projection property function requiring a numeric value. This can be used for\ninteractive parameterisation when an expression is bound to an input element.\nFor example,\n\n    ps =\n        params\n            << param \"angle\"\n                [ paValue (num 0)\n                , paBind (ipRange [ inMax 180 ])\n                ]\n\n    proj =\n        projection [ prNumExpr \"angle\" prClipAngle ]\n\n",
                "type": "String.String -> (number -> VegaLite.ProjectionProperty) -> VegaLite.ProjectionProperty"
            },
            {
                "name": "prParallel",
                "comment": " Standard parallel for map projections such as the 'Armadillo'.\n",
                "type": "Basics.Float -> VegaLite.ProjectionProperty"
            },
            {
                "name": "prParallels",
                "comment": " A conic projection’s two standard parallels.\n",
                "type": "Basics.Float -> Basics.Float -> VegaLite.ProjectionProperty"
            },
            {
                "name": "prParallelsExpr",
                "comment": " Specify a conic projection’s two standard parallels with two expressions.\n",
                "type": "String.String -> String.String -> VegaLite.ProjectionProperty"
            },
            {
                "name": "prParam",
                "comment": " Parameter name that should evaluate to either true or false for use in functions\nthat use predicates, such as [mCondition](#mCondition).\n",
                "type": "String.String -> VegaLite.Predicate"
            },
            {
                "name": "prParamEmpty",
                "comment": " Parameter name that should evaluate to either true or false for use in selections\nfor conditional encoding. Same as [prParam](#prParam) except that an empty selection\nis assumed to be false.\n",
                "type": "String.String -> VegaLite.Predicate"
            },
            {
                "name": "prPointRadius",
                "comment": " Radius in pixels when drawing geo point features in a GeoFeature.\n",
                "type": "Basics.Float -> VegaLite.ProjectionProperty"
            },
            {
                "name": "prPrecision",
                "comment": " Threshold for the projection’s adaptive resampling in pixels.\nCorresponds to the Douglas–Peucker distance. If precision is not specified, the\nprojection’s current resampling precision of 0.707 is used.\n",
                "type": "Basics.Float -> VegaLite.ProjectionProperty"
            },
            {
                "name": "prRadius",
                "comment": " Radius value for map projections such as the 'Gingery'.\n",
                "type": "Basics.Float -> VegaLite.ProjectionProperty"
            },
            {
                "name": "prRatio",
                "comment": " Ratio value for map projections such as the 'Hill'.\n",
                "type": "Basics.Float -> VegaLite.ProjectionProperty"
            },
            {
                "name": "prReflectX",
                "comment": " Reflect the x-coordinates after performing an identity projection. This\ncreates a left-right mirror image of the geoshape marks when subject to an\n[identityProjection](#identityProjection).\n",
                "type": "Basics.Bool -> VegaLite.ProjectionProperty"
            },
            {
                "name": "prReflectY",
                "comment": " Reflect the y-coordinates after performing an identity projection. This\ncreates a top-bottom mirror image of the geoshape marks when subject to an\n[identityProjection](#identityProjection).\n",
                "type": "Basics.Bool -> VegaLite.ProjectionProperty"
            },
            {
                "name": "prRotate",
                "comment": " A projection’s three-axis rotation angle. This should be in order _lambda phi\ngamma_ specifying the rotation angles in degrees about each spherical axis.\n",
                "type": "Basics.Float -> Basics.Float -> Basics.Float -> VegaLite.ProjectionProperty"
            },
            {
                "name": "prRotateExpr",
                "comment": " Specify a projection’s three-axis rotation angle with three expressions that\nshould evaluate to angular rotations (degrees) in _lambda phi gamma_ order.\n",
                "type": "String.String -> String.String -> String.String -> VegaLite.ProjectionProperty"
            },
            {
                "name": "prScale",
                "comment": " A projection’s zoom scale, which if set, overrides automatic scaling of a\ngeo feature to fit within the viewing area.\n",
                "type": "Basics.Float -> VegaLite.ProjectionProperty"
            },
            {
                "name": "prSpacing",
                "comment": " Spacing value for map projections such as the 'Lagrange'.\n",
                "type": "Basics.Float -> VegaLite.ProjectionProperty"
            },
            {
                "name": "prTest",
                "comment": " Test that should evaluate to either true or false for use in functions\nthat use predicates, such as [mCondition](#mCondition)\n",
                "type": "VegaLite.BooleanOp -> VegaLite.Predicate"
            },
            {
                "name": "prTilt",
                "comment": " 'Satellite' map projection tilt.\n",
                "type": "Basics.Float -> VegaLite.ProjectionProperty"
            },
            {
                "name": "prTranslate",
                "comment": " A projection’s panning translation in pixel units, which if set, override\nautomatic positioning of a geo feature to fit within the viewing area. Parameters\nshould be provided in x y order.\n",
                "type": "Basics.Float -> Basics.Float -> VegaLite.ProjectionProperty"
            },
            {
                "name": "prTranslateExpr",
                "comment": " Specify a projection’s panning translation in pixel units, with two expressions\nthat should evaluate to x and y translations respectively.\n",
                "type": "String.String -> String.String -> VegaLite.ProjectionProperty"
            },
            {
                "name": "prType",
                "comment": " Type of global map projection.\n",
                "type": "VegaLite.Projection -> VegaLite.ProjectionProperty"
            },
            {
                "name": "projection",
                "comment": " Map projection used for geospatial coordinates.\n\n    proj =\n        projection [ prType equirectangular, prRotate -156 0 0 ]\n\n",
                "type": "List.List VegaLite.ProjectionProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "qtAs",
                "comment": " The field names to give the probability and associated quantile values generated\nby a quantile transformation. If not specified, `prob` and `value` are used.\n",
                "type": "String.String -> String.String -> VegaLite.QuantileProperty"
            },
            {
                "name": "qtGroupBy",
                "comment": " The data fields to group by when performing a quantile transformation. If not\nspecified, a single group containing all data objects will be used.\n",
                "type": "List.List String.String -> VegaLite.QuantileProperty"
            },
            {
                "name": "qtProbs",
                "comment": " A list of probabilities in the range [0,1] for which to compute quantile values.\nIf not specified, the default step size of 0.01 or the value specified via [qtStep](#qtStep)\nwill be used.\n",
                "type": "List.List Basics.Float -> VegaLite.QuantileProperty"
            },
            {
                "name": "qtStep",
                "comment": " The interval between probabilities to use when performing a quantile transformation.\nAll values from half the given step size to 1 will be sampled. Only used if [qtProbs](#qtProbs)\nis not specified.\n",
                "type": "Basics.Float -> VegaLite.QuantileProperty"
            },
            {
                "name": "quantile",
                "comment": " Calculate quantile values from an input data stream. Useful for examining\ndistributional properties of a data stream and for creating\n[Q-Q plots](https://en.wikipedia.org/wiki/Q–Q_plot).\n",
                "type": "String.String -> List.List VegaLite.QuantileProperty -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"
            },
            {
                "name": "quarter",
                "comment": " Year quarter time unit used for discretizing temporal data.\n",
                "type": "VegaLite.TimeUnit"
            },
            {
                "name": "quarterMonth",
                "comment": " Year quarter and month time unit used for discretizing temporal data.\n",
                "type": "VegaLite.TimeUnit"
            },
            {
                "name": "raExprs",
                "comment": " A list of expressions that each evaluate to an element of a scale range. For\nexample to set a positional range based on two sliders:\n\n    ps =\n        params\n            << param \"xMin\"\n                [ paValue (num 0)\n                , paBind (ipRange [ inMin 0, inMax 400 ])\n                ]\n            << param \"xMax\"\n                [ paValue (num 400)\n                , paBind (ipRange [ inMin 0, inMax 400 ])\n                ]\n\n    enc =\n        encoding\n            << position X\n                [ pName \"x\"\n                , pScale [ scRange (raExprs [ \"xMin\", \"xMax\" ]) ]\n                ]\n\n",
                "type": "List.List String.String -> VegaLite.ScaleRange"
            },
            {
                "name": "raField",
                "comment": " Specify the field that contains explicit range values. This should be a one-to-one\nmatch with the field of domain values. Can be used, for example, to set color values\nexplicitly from a data source.\n",
                "type": "String.String -> VegaLite.ScaleRange"
            },
            {
                "name": "raMax",
                "comment": " Set the maximum value of a continuous numeric range. To set both the min and\nmax values use [raNums](#raNums).\n",
                "type": "Basics.Float -> VegaLite.ScaleRange"
            },
            {
                "name": "raMin",
                "comment": " Set the minimum value of a continuous numeric range. To set both the min and\nmax values use [raNums](#raNums).\n",
                "type": "Basics.Float -> VegaLite.ScaleRange"
            },
            {
                "name": "raName",
                "comment": " Name of a pre-defined scale range (e.g. `symbol` or `diverging`).\n",
                "type": "String.String -> VegaLite.ScaleRange"
            },
            {
                "name": "raNumExpr",
                "comment": " Provide an [expression](https://vega.github.io/vega/docs/expressions/) to\na range scale property function requiring a numeric value. This can be used for\ninteractive parameterisation when an expression is bound to an input element.\nFor example,\n\n    ps =\n        params\n            << param \"right\"\n                [ paValue (num 0)\n                , paBind (ipRange [ inMax 500 ])\n                ]\n\n    enc =\n        encoding\n            << position X\n                [ pName \"x\"\n                , pScale [ scRange (raNumExpr \"right\" raMax) ]\n                ]\n\n",
                "type": "String.String -> (number -> VegaLite.ScaleRange) -> VegaLite.ScaleRange"
            },
            {
                "name": "raNumLists",
                "comment": " Scale range comprising numeric lists. Useful, for example, when defining custom\ndash styles for a [strokeDash](#strokeDash) channel encoding.\n",
                "type": "List.List (List.List Basics.Float) -> VegaLite.ScaleRange"
            },
            {
                "name": "raNums",
                "comment": " Numeric scale range. Depending on the scaling this may be a [min, max]\npair, or a list of explicit numerical values.\n",
                "type": "List.List Basics.Float -> VegaLite.ScaleRange"
            },
            {
                "name": "raStrs",
                "comment": " Text scale range for discrete scales.\n",
                "type": "List.List String.String -> VegaLite.ScaleRange"
            },
            {
                "name": "racoCategory",
                "comment": " Default color scheme for categorical ranges.\n",
                "type": "String.String -> VegaLite.RangeConfig"
            },
            {
                "name": "racoDiverging",
                "comment": " Default diverging color scheme.\n",
                "type": "String.String -> VegaLite.RangeConfig"
            },
            {
                "name": "racoHeatmap",
                "comment": " Default 'heatmap' color scheme.\n",
                "type": "String.String -> VegaLite.RangeConfig"
            },
            {
                "name": "racoOrdinal",
                "comment": " Default ordinal color scheme.\n",
                "type": "String.String -> VegaLite.RangeConfig"
            },
            {
                "name": "racoRamp",
                "comment": " Default ramp (continuous) color scheme.\n",
                "type": "String.String -> VegaLite.RangeConfig"
            },
            {
                "name": "racoSymbols",
                "comment": " Default set of symbols for shape encoding.\n",
                "type": "List.List VegaLite.Symbol -> VegaLite.RangeConfig"
            },
            {
                "name": "racoSymbolsExpr",
                "comment": " Default set of symbols for shape encoding determined by the value of the\ngiven expression.\n",
                "type": "String.String -> VegaLite.RangeConfig"
            },
            {
                "name": "reAxis",
                "comment": " Indicate how a channel's axes should be resolved when defined in more than\none view in a composite visualization.\n",
                "type": "List.List ( VegaLite.Channel, VegaLite.Resolution ) -> VegaLite.Resolve"
            },
            {
                "name": "reIndependent",
                "comment": " Channel should be independent of others in a composite visualization.\n",
                "type": "VegaLite.Resolution"
            },
            {
                "name": "reLegend",
                "comment": " Indicate how a channel's legends should be resolved when defined in more\nthan one view in a composite visualization.\n",
                "type": "List.List ( VegaLite.Channel, VegaLite.Resolution ) -> VegaLite.Resolve"
            },
            {
                "name": "reScale",
                "comment": " Indicate how a channel's scales should be resolved when defined in more\nthan one view in a composite visualization.\n",
                "type": "List.List ( VegaLite.Channel, VegaLite.Resolution ) -> VegaLite.Resolve"
            },
            {
                "name": "reShared",
                "comment": " Channel should be shared with others in a composite visualization.\n",
                "type": "VegaLite.Resolution"
            },
            {
                "name": "rect",
                "comment": " [Rectangle mark](https://vega.github.io/vega-lite/docs/rect.html).\n",
                "type": "List.List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "regression",
                "comment": " Generate a 2d regression model for smoothing and predicting data. The first\nparameter is the name of the field representing the dependent variable (commonly\nmapped to the y-axis), the second is the name of the field representing the\nindependent variable (commonly mapped to the x-axis). The third parameter is a\nlist of optional regression customisation options.\n",
                "type": "String.String -> String.String -> List.List VegaLite.RegressionProperty -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"
            },
            {
                "name": "repeat",
                "comment": " Define the fields that will be used to make a composite view from multiple fields.\nSimilar to [repeatFlow](#repeatFlow) except that the fields for repetition are explicitly\nallocated to rows, columns or layers.\n\nUnlike _faceting_, which creates multiple charts based on different values of a\nsingle field, _repeating_ uses a different field for each chart.\n\n    spec = asSpec [...]\n    toVegaLite\n        [ repeat [ columnFields [ \"Cat\", \"Dog\", \"Fish\" ] ]\n        , specification spec\n        ]\n\n",
                "type": "List.List VegaLite.RepeatFields -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "repeatFlow",
                "comment": " Define the fields that will be used to compose a flow layout of a set of\nsmall multiples. Used when the encoding is largely identical, but the data field\nused in each might vary. When a list of fields is identified with `repeat` you also\nneed to define a full specification to apply to each of those fields using `asSpec`.\n\nSmall multiples will be laid out from left to right, moving on to new rows only\nif the number of plots exceeds an optional column limit (specified via\n[columns](#columns)).\n\n    spec = asSpec [...]\n    toVegaLite\n        [ repeatFlow [ \"Cat\", \"Dog\", \"Fish\" ]\n        , specification spec\n        ]\n\n",
                "type": "List.List String.String -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "resolution",
                "comment": " Define a resolution option to be applied when scales, axes or legends in composite\nviews share channel encodings. For example, it allows different color scales to be\nused in a layered view, or different axis scales to be used in a faceted view. Each\nresolution rule should be in a tuple pairing the channel to which it applies and\nthe rule type. The first parameter identifies the type of resolution.\n\n    resolve\n        << resolution (reScale [ ( chY, reIndependent ) ])\n        << resolution (reScale [ ( chColor, reIndependent ) ])\n        << resolution (reLegend [ ( chShape, reShared ) ])\n\n",
                "type": "VegaLite.Resolve -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"
            },
            {
                "name": "resolve",
                "comment": " Determine whether or not scales, axes or legends in composite views should\nshare channel encodings.\n\n    let\n        data =\n            dataFromColumns []\n                << dataColumn \"x\" (nums [ 1, 2, 3, 4, 5 ])\n                << dataColumn \"a\" (nums [ 28, 91, 43, 55, 81 ])\n                << dataColumn \"b\" (nums [ 17, 22, 28, 30, 40 ])\n\n        encBar =\n            encoding\n                << position X [ pName \"x\", pQuant ]\n                << position Y [ pName \"a\", pQuant ]\n\n        specBar =\n            asSpec [ bar [], encBar [] ]\n\n        encLine =\n            encoding\n                << position X [ pName \"x\", pQuant ]\n                << position Y [ pName \"b\", pQuant ]\n\n        specLine =\n            asSpec [ line [ maColor \"firebrick\" ], encLine [] ]\n\n        res =\n            resolve\n                << resolution (reScale [ ( chY, reIndependent ) ])\n    in\n    toVegaLite [ data [], res [], layer [ specBar, specLine ] ]\n\n",
                "type": "List.List VegaLite.LabelledSpec -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "rgAs",
                "comment": " Name the outputs of a regression transform. The first parameter is the name to\ngive the field containing the independent variable, the second the name to\ngive the field containing dependent variable. If not specified, the\noriginal input independent and dependent field names are used.\n",
                "type": "String.String -> String.String -> VegaLite.RegressionProperty"
            },
            {
                "name": "rgExp",
                "comment": " Indicate an exponential regression method.\n",
                "type": "VegaLite.RegressionMethod"
            },
            {
                "name": "rgExtent",
                "comment": " The min (first parameter) - max (second parameter) domain over which to estimate\nthe dependent variable in a regression. If unspecified, the full extent of input\nvalues will be used.\n",
                "type": "Basics.Float -> Basics.Float -> VegaLite.RegressionProperty"
            },
            {
                "name": "rgGroupBy",
                "comment": " The data fields to group by when generating a regression model. If not\nspecified, a single group containing all data objects will be used.\n",
                "type": "List.List String.String -> VegaLite.RegressionProperty"
            },
            {
                "name": "rgLinear",
                "comment": " Indicate a linear regression method.\n",
                "type": "VegaLite.RegressionMethod"
            },
            {
                "name": "rgLog",
                "comment": " Indicate a log regression method.\n",
                "type": "VegaLite.RegressionMethod"
            },
            {
                "name": "rgMethod",
                "comment": " The type of regression model to use when generating a 2d regression.\n",
                "type": "VegaLite.RegressionMethod -> VegaLite.RegressionProperty"
            },
            {
                "name": "rgOrder",
                "comment": " The order of a polynomial model to use when generating a 2d regression. Only\napplies if [rgMethod](#rgMethod) is set to [rgPoly](#rgPoly).\n",
                "type": "Basics.Int -> VegaLite.RegressionProperty"
            },
            {
                "name": "rgParams",
                "comment": " Whether or not the regression transform should return just the parameters\nof the regression function (one object per group) instead of trend line points.\nIf `True`, objects include a `coef` array of fitted coefficient values, starting\nwith the intercept term and then terms of increasing order and an `rSquared` value,\nindicating the total variance explained by the model.\n",
                "type": "Basics.Bool -> VegaLite.RegressionProperty"
            },
            {
                "name": "rgPoly",
                "comment": " Indicate a polynomial regression method. The order of the polynomial can be\nset with [rgOrder](#rgOrder) (defaulting to cubic if not provided).\n",
                "type": "VegaLite.RegressionMethod"
            },
            {
                "name": "rgPow",
                "comment": " Indicate a power regression method.\n",
                "type": "VegaLite.RegressionMethod"
            },
            {
                "name": "rgQuad",
                "comment": " Indicate a quadratic regression method.\n",
                "type": "VegaLite.RegressionMethod"
            },
            {
                "name": "rgb",
                "comment": " RGB color interpolation for continuous color scales using the given gamma\nvalue (anchored at 1).\n",
                "type": "Basics.Float -> VegaLite.CInterpolate"
            },
            {
                "name": "row",
                "comment": " Encode a new facet to be arranged in rows. The first parameter is a list of\nfacet properties that define the faceting channel. See the\n[Vega-Lite row documentation](https://vega.github.io/vega-lite/docs/facet.html#row--column-encoding-channels).\n\nNote that when faceting, dimensions specified with [width](#width) and [height](#height)\nrefer to the individual faceted plots, not the assemblage as a whole.\n\n    let\n        data =\n            dataFromUrl \"crimeData.csv\"\n\n        enc =\n            encoding\n                << position X [ pName \"month\", pTemporal ]\n                << position Y\n                    [ pName \"reportedCrimes\"\n                    , pQuant\n                    , pAggregate opSum\n                    , pTitle \"\"\n                    ]\n                << row [ fName \"crimeType\", fNominal ]\n    in\n    toVegaLite [ height 80, data [], bar [], enc [] ]\n\n",
                "type": "List.List VegaLite.FacetChannel -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"
            },
            {
                "name": "rowBy",
                "comment": " The mapping between a row and its field definitions in a set of faceted\nsmall multiples. This is used when specifying a more flexible [facet](#facet)\nrather than the compact, but simplified, [row](#row).\n",
                "type": "List.List VegaLite.FacetChannel -> VegaLite.FacetMapping"
            },
            {
                "name": "rowFields",
                "comment": " Create a list of fields to use in set of repeated small multiples arranged in\nrows. The list of fields named here can be referenced in an encoding with\n`pRepeat row`, `mRepeat row` etc.\n",
                "type": "List.List String.String -> VegaLite.RepeatFields"
            },
            {
                "name": "rule",
                "comment": " [Rule line](https://vega.github.io/vega-lite/docs/rule.html) connecting\ntwo vertices.\n",
                "type": "List.List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "sacoBandPaddingInner",
                "comment": " Default inner padding for x and y band-ordinal scales.\n",
                "type": "Basics.Float -> VegaLite.ScaleConfig"
            },
            {
                "name": "sacoBandPaddingOuter",
                "comment": " Default outer padding for x and y band-ordinal scales.\n",
                "type": "Basics.Float -> VegaLite.ScaleConfig"
            },
            {
                "name": "sacoBarBandPaddingInner",
                "comment": " Default inner padding for x and y band-ordinal scales of `bar` marks.\n",
                "type": "Basics.Float -> VegaLite.ScaleConfig"
            },
            {
                "name": "sacoBooExpr",
                "comment": " Provide an [expression](https://vega.github.io/vega/docs/expressions/) to\na scale property configuration function requiring a Boolean value.\n",
                "type": "String.String -> (Basics.Bool -> VegaLite.ScaleConfig) -> VegaLite.ScaleConfig"
            },
            {
                "name": "sacoClamp",
                "comment": " Whether or not by default values that exceed the data domain are clamped to\nthe min/max range value.\n",
                "type": "Basics.Bool -> VegaLite.ScaleConfig"
            },
            {
                "name": "sacoContinuousPadding",
                "comment": " Default padding for continuous scales.\n",
                "type": "Basics.Float -> VegaLite.ScaleConfig"
            },
            {
                "name": "sacoMaxBandSize",
                "comment": " Default maximum value for mapping quantitative fields to a bar's\nsize/bandSize.\n",
                "type": "Basics.Float -> VegaLite.ScaleConfig"
            },
            {
                "name": "sacoMaxFontSize",
                "comment": " Default maximum value for mapping a quantitative field to a text\nmark's size.\n",
                "type": "Basics.Float -> VegaLite.ScaleConfig"
            },
            {
                "name": "sacoMaxOpacity",
                "comment": " Default maximum opacity (in the range [0, 1]) for mapping a field\nto opacity.\n",
                "type": "Basics.Float -> VegaLite.ScaleConfig"
            },
            {
                "name": "sacoMaxSize",
                "comment": " Default maximum size for point-based scales.\n",
                "type": "Basics.Float -> VegaLite.ScaleConfig"
            },
            {
                "name": "sacoMaxStrokeWidth",
                "comment": " Default maximum stroke width for rule, line and trail marks.\n",
                "type": "Basics.Float -> VegaLite.ScaleConfig"
            },
            {
                "name": "sacoMinBandSize",
                "comment": " Default minimum value for mapping quantitative fields to a bar's size/bandSize.\n",
                "type": "Basics.Float -> VegaLite.ScaleConfig"
            },
            {
                "name": "sacoMinFontSize",
                "comment": " Default minimum value for mapping a quantitative field to a text mark's size.\n",
                "type": "Basics.Float -> VegaLite.ScaleConfig"
            },
            {
                "name": "sacoMinOpacity",
                "comment": " Default minimum opacity (0 to 1) for mapping a field to opacity.\n",
                "type": "Basics.Float -> VegaLite.ScaleConfig"
            },
            {
                "name": "sacoMinSize",
                "comment": " Default minimum size for point-based scales (when not forced to start at zero).\n",
                "type": "Basics.Float -> VegaLite.ScaleConfig"
            },
            {
                "name": "sacoMinStrokeWidth",
                "comment": " Default minimum stroke width for rule, line and trail marks.\n",
                "type": "Basics.Float -> VegaLite.ScaleConfig"
            },
            {
                "name": "sacoNumExpr",
                "comment": " Provide an [expression](https://vega.github.io/vega/docs/expressions/) to\na scale property configuration function requiring a numeric value.\n",
                "type": "String.String -> (number -> VegaLite.ScaleConfig) -> VegaLite.ScaleConfig"
            },
            {
                "name": "sacoPointPadding",
                "comment": " Default padding for point-ordinal scales.\n",
                "type": "Basics.Float -> VegaLite.ScaleConfig"
            },
            {
                "name": "sacoRectBandPaddingInner",
                "comment": " Default inner padding for x and y band-ordinal scales of `rect` marks.\n",
                "type": "Basics.Float -> VegaLite.ScaleConfig"
            },
            {
                "name": "sacoRound",
                "comment": " Whether or not numeric values are rounded to integers when scaling. Useful\nfor snapping to the pixel grid.\n",
                "type": "Basics.Bool -> VegaLite.ScaleConfig"
            },
            {
                "name": "sacoUseUnaggregatedDomain",
                "comment": " Whether or not to use the source data range before aggregation.\n",
                "type": "Basics.Bool -> VegaLite.ScaleConfig"
            },
            {
                "name": "sacoXReverse",
                "comment": " Whether or not to reverse the x-scaling by default (useful for right to left\ncharts).\n",
                "type": "Basics.Bool -> VegaLite.ScaleConfig"
            },
            {
                "name": "sample",
                "comment": " Randomly sample rows from a data source up to a given maximum. For example,\nto randomly sample 50 values from a sine curve:\n\n    data =\n        dataSequenceAs 0 13 0.001 \"x\"\n\n    trans =\n        transform\n            << calculateAs \"sin(datum.x)\" \"y\"\n            << sample 50\n\n",
                "type": "Basics.Float -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"
            },
            {
                "name": "scAlign",
                "comment": " Alignment of the steps within the scale range. Parameter is capped between 0\nand 1 where 0.5 indicates steps are centred within range, 0 shifts bands to an\naxis, 1 away from axis.\n",
                "type": "Basics.Float -> VegaLite.ScaleProperty"
            },
            {
                "name": "scBand",
                "comment": " A band scale.\n",
                "type": "VegaLite.Scale"
            },
            {
                "name": "scBase",
                "comment": " The base to use for log scaling.\n",
                "type": "Basics.Float -> VegaLite.ScaleProperty"
            },
            {
                "name": "scBinOrdinal",
                "comment": " An ordinal band scale.\n",
                "type": "VegaLite.Scale"
            },
            {
                "name": "scBooExpr",
                "comment": " Provide an [expression](https://vega.github.io/vega/docs/expressions/) to\na scale property function requiring a Boolean value. This can be used to provide an\ninteractive parameterisation of a mark property by providing an expression bound\nto an input element. For example,\n\n    ps =\n        params\n            << param \"rev\"\n                [ paValue (boo False)\n                , paBind (ipCheckbox [ inName \"reverse colours\" ])\n                ]\n\n    enc =\n        encoding\n            << color [ mName \"val\" mScale [ scBooExpr \"rev\" scReverse ] ]\n\n",
                "type": "String.String -> (Basics.Bool -> VegaLite.ScaleProperty) -> VegaLite.ScaleProperty"
            },
            {
                "name": "scClamp",
                "comment": " Whether or not values outside the data domain are clamped to the minimum or\nmaximum value.\n",
                "type": "Basics.Bool -> VegaLite.ScaleProperty"
            },
            {
                "name": "scConstant",
                "comment": " The desired desired slope of the [scSymLog](#scSymLog) function at zero. If\nunspecified, the default is 1.\n",
                "type": "Basics.Float -> VegaLite.ScaleProperty"
            },
            {
                "name": "scDomain",
                "comment": " Custom scaling domain.\n",
                "type": "VegaLite.ScaleDomain -> VegaLite.ScaleProperty"
            },
            {
                "name": "scDomainExpr",
                "comment": " Expression that defines a scaling domain.\n",
                "type": "String.String -> VegaLite.ScaleProperty"
            },
            {
                "name": "scExponent",
                "comment": " The exponent to use for power scaling.\n",
                "type": "Basics.Float -> VegaLite.ScaleProperty"
            },
            {
                "name": "scInterpolate",
                "comment": " Interpolation method for scaling range values.\n",
                "type": "VegaLite.CInterpolate -> VegaLite.ScaleProperty"
            },
            {
                "name": "scLinear",
                "comment": " A linear scale.\n",
                "type": "VegaLite.Scale"
            },
            {
                "name": "scLog",
                "comment": " A log scale. Defaults to log of base 10, but can be customised by setting\n[scBase](#scBase) to some other value. If data to be scaled contain zeros or negative\nvalues, consider [scSymLog](#scSymLog) instead.\n",
                "type": "VegaLite.Scale"
            },
            {
                "name": "scNice",
                "comment": " 'Nice' minimum and maximum values in a scaling (e.g. multiples of 10).\n",
                "type": "VegaLite.ScaleNice -> VegaLite.ScaleProperty"
            },
            {
                "name": "scNumExpr",
                "comment": " Provide an [expression](https://vega.github.io/vega/docs/expressions/) to\na scale property function requiring a numeric value. This can be used to provide\nan interactive parameterisation of a mark property by providing an expression bound\nto an input element. For example,\n\n    ps =\n        params\n            << param \"pad\"\n                [ paValue (num 0)\n                , paBind (ipRange [ inMax 100 ])\n                ]\n\n    enc =\n        encoding\n            << position X [ mName \"val\" mScale [ scNumExpr \"pad\" scPadding ] ]\n\n",
                "type": "String.String -> (number -> VegaLite.ScaleProperty) -> VegaLite.ScaleProperty"
            },
            {
                "name": "scOrdinal",
                "comment": " An ordinal scale.\n",
                "type": "VegaLite.Scale"
            },
            {
                "name": "scPadding",
                "comment": " Padding in pixels to apply to a scaling.\n",
                "type": "Basics.Float -> VegaLite.ScaleProperty"
            },
            {
                "name": "scPaddingInner",
                "comment": " Inner padding to apply to a band scaling.\n",
                "type": "Basics.Float -> VegaLite.ScaleProperty"
            },
            {
                "name": "scPaddingOuter",
                "comment": " Outer padding to apply to a band scaling.\n",
                "type": "Basics.Float -> VegaLite.ScaleProperty"
            },
            {
                "name": "scPoint",
                "comment": " A point scale.\n",
                "type": "VegaLite.Scale"
            },
            {
                "name": "scPow",
                "comment": " A power scale. The exponent to use for scaling is specified with\n[scExponent](#scExponent).\n",
                "type": "VegaLite.Scale"
            },
            {
                "name": "scQuantile",
                "comment": " A quantile scale.\n",
                "type": "VegaLite.Scale"
            },
            {
                "name": "scQuantize",
                "comment": " A quantizing scale.\n",
                "type": "VegaLite.Scale"
            },
            {
                "name": "scRange",
                "comment": " Range of a scaling. The type of range depends on the encoding channel.\n",
                "type": "VegaLite.ScaleRange -> VegaLite.ScaleProperty"
            },
            {
                "name": "scReverse",
                "comment": " Whether or not to reverse sorting order of a scaling.\n",
                "type": "Basics.Bool -> VegaLite.ScaleProperty"
            },
            {
                "name": "scRound",
                "comment": " Whether or not numeric values in a scaling are rounded to integers.\n",
                "type": "Basics.Bool -> VegaLite.ScaleProperty"
            },
            {
                "name": "scScheme",
                "comment": " Color scheme used by a color scaling with [mScale](#mScale). The first parameter\nis the name of the scheme (e.g. \"viridis\") and the second an optional specification\nof the number of colors to use (list of one number), or the extent of the color\nrange to use (list of two numbers between 0 and 1).\n\n    color\n        [ mName \"value\"\n        , mOrdinal\n        , mScale [ scScheme \"redblue\" [ 0, 0.8 ] ]\n        ]\n\n",
                "type": "String.String -> List.List Basics.Float -> VegaLite.ScaleProperty"
            },
            {
                "name": "scSchemeExpr",
                "comment": " Expression that evaluates to a color scheme for color scaling. The first parameter\nis the expression and the second as for [scScheme](#scScheme). For example, to\nchoose from a pair of preset schemes:\n\n    ps =\n        params\n            << param \"clrs\"\n                [ paValue (str \"plasma\")\n                , paBind (ipSelect [ inOptions [ \"plasma\", \"oranges\" ] ])\n                ]\n\n    enc =\n        encoding\n            << color [ mName \"val\", mScale [ scSchemeExpr \"clrs\" [] ] ]\n\nCan be used to specify a custom interpolated colour scheme by providing a list of\ncolours as a parameter value:\n\n    ps =\n        params\n            << param \"myScheme\" [ paValues (strs [ \"blue\", \"white\", \"red\" ]) ]\n\n    enc =\n        encoding\n            << color [ mName \"val\", mScale [ scSchemeExpr \"myScheme\" [] ] ]\n\n",
                "type": "String.String -> List.List Basics.Float -> VegaLite.ScaleProperty"
            },
            {
                "name": "scSqrt",
                "comment": " A square root scale.\n",
                "type": "VegaLite.Scale"
            },
            {
                "name": "scSymLog",
                "comment": " A [symmetrical log](https://www.researchgate.net/profile/John_Webber4/publication/233967063_A_bi-symmetric_log_transformation_for_wide-range_data/links/0fcfd50d791c85082e000000.pdf)\nscale. Similar to a log scale but supports zero and negative values. The slope\nof the function at zero can be set with [scConstant](#scConstant).\n",
                "type": "VegaLite.Scale"
            },
            {
                "name": "scThreshold",
                "comment": " A threshold scale.\n",
                "type": "VegaLite.Scale"
            },
            {
                "name": "scTime",
                "comment": " A temporal scale.\n",
                "type": "VegaLite.Scale"
            },
            {
                "name": "scType",
                "comment": " Type of scaling to apply.\n",
                "type": "VegaLite.Scale -> VegaLite.ScaleProperty"
            },
            {
                "name": "scUtc",
                "comment": " A UTC temporal scale.\n",
                "type": "VegaLite.Scale"
            },
            {
                "name": "scZero",
                "comment": " Whether or not a numeric scaling should be forced to include a zero value.\n",
                "type": "Basics.Bool -> VegaLite.ScaleProperty"
            },
            {
                "name": "seClear",
                "comment": " [Vega event stream selector](https://vega.github.io/vega/docs/event-streams/#selector)\nthat can clear a selection. For example, to allow a zoomed/panned view to be reset\non shift-click:\n\n    ps =\n        params\n            << param \"myZoomPan\"\n                [ paSelect seInterval [ seClear \"click[event.shiftKey]\" ]\n                , paBindScales\n                ]\n\nTo remove the default clearing behaviour of a selection, provide an empty string\nrather than an event stream selector.\n\n",
                "type": "String.String -> VegaLite.SelectionProperty"
            },
            {
                "name": "seEncodings",
                "comment": " Encoding channels that form a named selection. For example, to _project_ a\nselection across all items that share the same value in the color channel:\n\n    ps =\n        params\n            << param \"sel\" [ paSelect sePoint [ seEncodings [ chColor ] ] ]\n\n",
                "type": "List.List VegaLite.Channel -> VegaLite.SelectionProperty"
            },
            {
                "name": "seFields",
                "comment": " Field names for projecting a selection over multiple fields.\n",
                "type": "List.List String.String -> VegaLite.SelectionProperty"
            },
            {
                "name": "seGlobal",
                "comment": " One selection available across all subviews (default).\n",
                "type": "VegaLite.SelectionResolution"
            },
            {
                "name": "seIntersection",
                "comment": " Each subview contains its own brush and marks are selected if they lie\nwithin _all_ of these individual selections.\n",
                "type": "VegaLite.SelectionResolution"
            },
            {
                "name": "seInterval",
                "comment": " Indicate a draggable bounding rectangle can be made for selecting all items\nthat intersect with it.\n",
                "type": "VegaLite.Selection"
            },
            {
                "name": "seNearest",
                "comment": " Whether or not a selection should capture nearest marks to a pointer\nrather than an exact position match.\n",
                "type": "Basics.Bool -> VegaLite.SelectionProperty"
            },
            {
                "name": "seOn",
                "comment": " [Vega event stream selector](https://vega.github.io/vega/docs/event-streams/#selector)\nthat triggers a selection. For example, to create a paintbrush effect under the\npointer:\n\n    ps =\n        params\n            << param \"paint\" [ paSelect sePoint [ seOn \"mouseover\" ] ]\n\n",
                "type": "String.String -> VegaLite.SelectionProperty"
            },
            {
                "name": "sePoint",
                "comment": " Specify a point selection type.\n",
                "type": "VegaLite.Selection"
            },
            {
                "name": "seResolve",
                "comment": " Strategy that determines how selections’ data queries are resolved when applied\nin a filter transform, conditional encoding rule, or scale domain.\n",
                "type": "VegaLite.SelectionResolution -> VegaLite.SelectionProperty"
            },
            {
                "name": "seSelectionMark",
                "comment": " Appearance of an interval selection mark (dragged rectangle).\n",
                "type": "List.List VegaLite.SelectionMarkProperty -> VegaLite.SelectionProperty"
            },
            {
                "name": "seToggle",
                "comment": " Predicate expression that determines a toggled selection. See the\n[Vega-Lite toggle documentation](https://vega.github.io/vega-lite/docs/selection.html#toggle)\n\nFor example, to create a paintbrush type effect that leaves a trail of selections\nunder the pointer while the shift key is pressed down:\n\n    ps =\n        params\n            << param \"paint\"\n                [ paSelect sePoint [ seOn \"mouseover\", seToggle tpShiftKey ] ]\n\n",
                "type": "VegaLite.TogglePredicate -> VegaLite.SelectionProperty"
            },
            {
                "name": "seTranslate",
                "comment": " Interaction [event stream](https://vega.github.io/vega/docs/event-streams/)\nfor translating an interval selection. If an empty string, selection translation\nwill be disabled. See the\n[Vega-Lite zoom documentation](https://vega.github.io/vega-lite/docs/selection.html#interval)\n",
                "type": "String.String -> VegaLite.SelectionProperty"
            },
            {
                "name": "seUnion",
                "comment": " Each subview contains its own brush and marks are selected if they lie\nwithin _any_ of these individual selections.\n",
                "type": "VegaLite.SelectionResolution"
            },
            {
                "name": "seZoom",
                "comment": " Interaction [event stream](https://vega.github.io/vega/docs/event-streams/)\nfor zooming an interval selection. If an empty string, zooming will be disabled.\nSee the [Vega-Lite zoom documentation](https://vega.github.io/vega-lite/docs/selection.html#interval)\n",
                "type": "String.String -> VegaLite.SelectionProperty"
            },
            {
                "name": "seconds",
                "comment": " Second of a minute time unit used for discretizing temporal data.\n",
                "type": "VegaLite.TimeUnit"
            },
            {
                "name": "secondsMilliseconds",
                "comment": " Seconds and milliseconds time unit used for discretizing temporal data.\n",
                "type": "VegaLite.TimeUnit"
            },
            {
                "name": "shape",
                "comment": " Encode a shape channel. The first parameter is a list of shape encoding options\nsuch as the data to encode, custom shape encodings etc.\n\n    enc =\n        encoding\n            << shape [ mName \"company\", mNominal ]\n\n",
                "type": "List.List VegaLite.MarkChannel -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"
            },
            {
                "name": "siBottom",
                "comment": " Bottom side, used, for example, to specify an axis position.\n",
                "type": "VegaLite.Side"
            },
            {
                "name": "siExpr",
                "comment": " Specify a side position with an interactive expression.\n",
                "type": "String.String -> VegaLite.Side"
            },
            {
                "name": "siLeft",
                "comment": " Left side, used, for example, to specify an axis position.\n",
                "type": "VegaLite.Side"
            },
            {
                "name": "siRight",
                "comment": " Right side, used, for example, to specify an axis position.\n",
                "type": "VegaLite.Side"
            },
            {
                "name": "siTop",
                "comment": " Top side, used, for example, to specify an axis position.\n",
                "type": "VegaLite.Side"
            },
            {
                "name": "size",
                "comment": " Encode a size channel. The first parameter is a list of size encoding options\nsuch as the data to encode, size scaling etc.\n\n    enc =\n        encoding\n            << size [ mName \"population\", mQuant ]\n\n",
                "type": "List.List VegaLite.MarkChannel -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"
            },
            {
                "name": "smCursor",
                "comment": " Cursor type to appear when pointer is over an interval selection mark\n(dragged rectangular area).\n",
                "type": "VegaLite.Cursor -> VegaLite.SelectionMarkProperty"
            },
            {
                "name": "smFill",
                "comment": " Fill color of an interval selection mark (dragged rectangular area).\n",
                "type": "String.String -> VegaLite.SelectionMarkProperty"
            },
            {
                "name": "smFillOpacity",
                "comment": " Fill opacity of an interval selection mark in the range 0 to 1.\n",
                "type": "Basics.Float -> VegaLite.SelectionMarkProperty"
            },
            {
                "name": "smStroke",
                "comment": " Stroke color of an interval selection mark.\n",
                "type": "String.String -> VegaLite.SelectionMarkProperty"
            },
            {
                "name": "smStrokeDash",
                "comment": " Stroke dash style of an interval selection mark.\n",
                "type": "List.List Basics.Float -> VegaLite.SelectionMarkProperty"
            },
            {
                "name": "smStrokeDashOffset",
                "comment": " Stroke dash offset of an interval selection mark.\n",
                "type": "Basics.Float -> VegaLite.SelectionMarkProperty"
            },
            {
                "name": "smStrokeOpacity",
                "comment": " Stroke opacity of an interval selection mark in the range 0 to 1.\n",
                "type": "Basics.Float -> VegaLite.SelectionMarkProperty"
            },
            {
                "name": "smStrokeWidth",
                "comment": " Stroke width of an interval selection mark.\n",
                "type": "Basics.Float -> VegaLite.SelectionMarkProperty"
            },
            {
                "name": "soAscending",
                "comment": " Indicate sorting is to be applied from low to high.\n",
                "type": "VegaLite.SortProperty"
            },
            {
                "name": "soByChannel",
                "comment": " Sort by another channel.\n\n    position Y [ pName \"age\", pOrdinal, pSort [ soByChannel chX ] ]\n\n",
                "type": "VegaLite.Channel -> VegaLite.SortProperty"
            },
            {
                "name": "soByField",
                "comment": " Sort by the aggregated summary of a given field using a given aggregation\noperation. e.g., sort the categorical data field `variety` by the mean age of\nthe data in each variety category:\n\n    position Y\n        [ pName \"variety\"\n        , pOrdinal\n        , pSort [ soByField \"age\" opMean, soDescending ]\n        ]\n\n",
                "type": "String.String -> VegaLite.Operation -> VegaLite.SortProperty"
            },
            {
                "name": "soByRepeat",
                "comment": " Sort by the aggregated summaries of the given fields (referenced by a repeat\niterator) using a given aggregation operation.\n",
                "type": "VegaLite.Arrangement -> VegaLite.Operation -> VegaLite.SortProperty"
            },
            {
                "name": "soCustom",
                "comment": " Custom sort order listing data values explicitly.\n",
                "type": "VegaLite.DataValues -> VegaLite.SortProperty"
            },
            {
                "name": "soDescending",
                "comment": " Indicate sorting is to be applied from high to low.\n",
                "type": "VegaLite.SortProperty"
            },
            {
                "name": "spacing",
                "comment": " Spacing between sub-views in a composition operator.\n",
                "type": "Basics.Float -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "spacingRC",
                "comment": " Similar to [spacing](#spacing) but with independent spacing for rows (first\nparameter) and columns (second parameter).\n",
                "type": "Basics.Float -> Basics.Float -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "specification",
                "comment": " Define a specification object for use with faceted and repeated small multiples.\n\n    spec = ...\n    toVegaLite\n        [ facet [ rowBy [ fName \"Origin\", fNominal ] ]\n        , specification spec\n        ]\n\n",
                "type": "VegaLite.Spec -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "sphere",
                "comment": " Generate a data source that is a sphere for bounding global geographic data.\nThe sphere will be subject to whatever projection is specified for the view.\n\n    toVegaLite\n        [ sphere\n        , projection [ prType orthographic ]\n        , geoshape [ maFill \"aliceblue\" ]\n        ]\n\n",
                "type": "VegaLite.Data"
            },
            {
                "name": "square",
                "comment": " [Square mark](https://vega.github.io/vega-lite/docs/square.html) for symbolising\npoints.\n",
                "type": "List.List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "stAscending",
                "comment": " Indicate that the given field should be sorted in ascending order.\n",
                "type": "String.String -> VegaLite.SortField"
            },
            {
                "name": "stCenter",
                "comment": " Offset a stacked layout using a central stack baseline.\n",
                "type": "VegaLite.StackOffset"
            },
            {
                "name": "stDescending",
                "comment": " Indicate that the given field should be sorted in descending order.\n",
                "type": "String.String -> VegaLite.SortField"
            },
            {
                "name": "stNone",
                "comment": " Do not stack marks (produces a layered plot).\n",
                "type": "VegaLite.StackOffset"
            },
            {
                "name": "stNormalize",
                "comment": " Rescale a stacked layout to use a common height while preserving relative size\nof stacked quantities.\n",
                "type": "VegaLite.StackOffset"
            },
            {
                "name": "stOffset",
                "comment": " Stack offset when applying a stack transformation.\n",
                "type": "VegaLite.StackOffset -> VegaLite.StackProperty"
            },
            {
                "name": "stSort",
                "comment": " Ordering within a stack when applying a stack transformation.\n",
                "type": "List.List VegaLite.SortField -> VegaLite.StackProperty"
            },
            {
                "name": "stZero",
                "comment": " Offset a stacked layout using a baseline at the foot of a stack.\n",
                "type": "VegaLite.StackOffset"
            },
            {
                "name": "stack",
                "comment": " Apply a stack transform for positioning multiple values. This is an alternative\nto specifying stacking directly when encoding position. First parameter is the field\nto be stacked; the second the fields to group by; the third and fourth are the names\nto give the output field names; the fifth lists the optional offset and sort properties.\n",
                "type": "String.String -> List.List String.String -> String.String -> String.String -> List.List VegaLite.StackProperty -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"
            },
            {
                "name": "stereographic",
                "comment": " A stereographic map projection.\n",
                "type": "VegaLite.Projection"
            },
            {
                "name": "str",
                "comment": " A string data value.\n",
                "type": "String.String -> VegaLite.DataValue"
            },
            {
                "name": "stroke",
                "comment": " Encode a stroke channel. This acts in a similar way to encoding by `color` but\nonly affects the exterior boundary of marks.\n",
                "type": "List.List VegaLite.MarkChannel -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"
            },
            {
                "name": "strokeDash",
                "comment": " Encode a stroke dash channel.\n\n    enc =\n        encoding\n            << position X [ pName \"date\", pTemporal ]\n            << position Y [ pName \"price\", pQuant ]\n            << strokeDash [ mName \"company\" ]\n\n",
                "type": "List.List VegaLite.MarkChannel -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"
            },
            {
                "name": "strokeOpacity",
                "comment": " Encode a stroke opacity channel. This acts in a similar way to encoding by\n`opacity` but only affects the exterior boundary of marks. If both `opacity` and\n`strokeOpacity` are specified, `strokeOpacity` takes precedence for stroke encoding.\n",
                "type": "List.List VegaLite.MarkChannel -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"
            },
            {
                "name": "strokeWidth",
                "comment": " Encode a stroke width channel.\n",
                "type": "List.List VegaLite.MarkChannel -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"
            },
            {
                "name": "strs",
                "comment": " A list of string data values. Used when declaring inline data with\n[dataColumn](#dataColumn), filtering ([fiOneOf](#fiOneOf)), imputation\n([imKeyVals](#imKeyVals)) and customised sorting ([soCustom](#soCustom)).\n",
                "type": "List.List String.String -> VegaLite.DataValues"
            },
            {
                "name": "symArrow",
                "comment": " Specify a centred arrow symbol for a shape mark. Useful for vector plots.\n",
                "type": "VegaLite.Symbol"
            },
            {
                "name": "symCircle",
                "comment": " Specify a circular symbol for a shape mark.\n",
                "type": "VegaLite.Symbol"
            },
            {
                "name": "symCross",
                "comment": " Specify a cross symbol for a shape mark.\n",
                "type": "VegaLite.Symbol"
            },
            {
                "name": "symDiamond",
                "comment": " Specify a diamond symbol for a shape mark.\n",
                "type": "VegaLite.Symbol"
            },
            {
                "name": "symExpr",
                "comment": " Expression that evaluates to some symbol such as \"diamond\", \"cross\" or \"circle\".\n",
                "type": "String.String -> VegaLite.Symbol"
            },
            {
                "name": "symPath",
                "comment": " A custom symbol shape as an\n[SVG path description](https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths).\n",
                "type": "String.String -> VegaLite.Symbol"
            },
            {
                "name": "symSquare",
                "comment": " Specify a square symbol for a shape mark.\n",
                "type": "VegaLite.Symbol"
            },
            {
                "name": "symStroke",
                "comment": " Specify a linear symbol for a shape mark. Note that this will only be visible\nif the symbol has a stroke setting (unlike all the other areal symbols filling it\nhas no effect).\n",
                "type": "VegaLite.Symbol"
            },
            {
                "name": "symTriangle",
                "comment": " Specify a centred triangle symbol for a shape mark. Useful for vector plots.\n",
                "type": "VegaLite.Symbol"
            },
            {
                "name": "symTriangleDown",
                "comment": " Specify a downward triangular symbol for a shape mark.\n",
                "type": "VegaLite.Symbol"
            },
            {
                "name": "symTriangleLeft",
                "comment": " Specify a leftward facing triangular symbol for a shape mark.\n",
                "type": "VegaLite.Symbol"
            },
            {
                "name": "symTriangleRight",
                "comment": " Specify a rightward facing triangular symbol for a shape mark.\n",
                "type": "VegaLite.Symbol"
            },
            {
                "name": "symTriangleUp",
                "comment": " Specify an upward triangular symbol for a shape mark.\n",
                "type": "VegaLite.Symbol"
            },
            {
                "name": "symWedge",
                "comment": " Specify a centred wedge (thin triangle) symbol for a shape mark. Useful for\nvector plots.\n",
                "type": "VegaLite.Symbol"
            },
            {
                "name": "tAggregate",
                "comment": " Compute some aggregate summary statistics for a field to be encoded with a\ntext channel. The type of aggregation is determined by the given operation\nparameter.\n",
                "type": "VegaLite.Operation -> VegaLite.TextChannel"
            },
            {
                "name": "tBin",
                "comment": " Discretize numeric values into bins when encoding with a text channel.\n",
                "type": "List.List VegaLite.BinProperty -> VegaLite.TextChannel"
            },
            {
                "name": "tBinned",
                "comment": " Indicate that data encoded with a text channel are already binned.\n",
                "type": "VegaLite.TextChannel"
            },
            {
                "name": "tCondition",
                "comment": " Make a text channel encoding conditional on a predicate expression. A predicate\nmight be the result of evaluating a parameter ([prParam](#prParam)) or an expression\n([prTest](#prTest)). The first parameter is the predicate that evaluates to true\nor false; the second the encoding if true, the third the encoding if false.\n",
                "type": "VegaLite.Predicate -> List.List VegaLite.TextChannel -> List.List VegaLite.TextChannel -> VegaLite.TextChannel"
            },
            {
                "name": "tConditions",
                "comment": " Make an text channel conditional on a sequence of predicate values. This can\nbe used when several predicates need to be tested in sequence each with their own\nencoding outcomes ('if-else').\n",
                "type": "List.List ( VegaLite.Predicate, List.List VegaLite.TextChannel ) -> List.List VegaLite.TextChannel -> VegaLite.TextChannel"
            },
            {
                "name": "tDatum",
                "comment": " Name of a literal data item used for encoding with a text channel. Unlike\n[tStr](#tStr) datum literals represent values in data space.\n",
                "type": "VegaLite.DataValue -> VegaLite.TextChannel"
            },
            {
                "name": "tFormat",
                "comment": " [Formatting pattern](https://vega.github.io/vega-lite/docs/format.html)\nfor text marks. To distinguish between formatting as numeric values and data/time\nvalues, additionally use [tFormatAsNum](#tFormatAsNum), [tFormatAsTemporal](#tFormatAsTemporal)\nor [tFormatAsCustom](#tFormatAsCustom).\n",
                "type": "String.String -> VegaLite.TextChannel"
            },
            {
                "name": "tFormatAsCustom",
                "comment": " Indicate that values encoded with a text channel should be formatted with a\nregistered custom formatter with the given name. See\n[how to register a Vega-Lite custom formatter](https://vega.github.io/vega-lite/usage/compile.html#format-type).\n",
                "type": "String.String -> VegaLite.TextChannel"
            },
            {
                "name": "tFormatAsNum",
                "comment": " Indicate that values encoded with a text channel should be formatted as numbers.\nTo control the precise numeric format, additionally use [tFormat](#tFormat) providing\na [d3 numeric format string](https://github.com/d3/d3-format#locale_format).\n",
                "type": "VegaLite.TextChannel"
            },
            {
                "name": "tFormatAsTemporal",
                "comment": " Indicate that values encoded with a text channel should be formatted as dates/times.\nTo control the precise temporal format, additionally use [tFormat](#tFormat) providing\na [d3 date/time format string](https://github.com/d3/d3-time-format#locale_format).\n",
                "type": "VegaLite.TextChannel"
            },
            {
                "name": "tGeo",
                "comment": " Indicate a data field encoded as a text property is a geo feature.\n",
                "type": "VegaLite.TextChannel"
            },
            {
                "name": "tName",
                "comment": " Name of field used for encoding with a text channel.\n",
                "type": "String.String -> VegaLite.TextChannel"
            },
            {
                "name": "tNominal",
                "comment": " Indicate a data field encoded as a text property is nominal. This is\nthe default data type.\n",
                "type": "VegaLite.TextChannel"
            },
            {
                "name": "tOrdinal",
                "comment": " Indicate a data field encoded as a text property is ordinal.\n",
                "type": "VegaLite.TextChannel"
            },
            {
                "name": "tQuant",
                "comment": " Indicate a data field encoded as a text property is quantitative.\n",
                "type": "VegaLite.TextChannel"
            },
            {
                "name": "tRepeat",
                "comment": " Reference in a text channel to a field name generated by [repeatFlow](#repeatFlow)\nor [repeat](#repeat). The parameter identifies whether reference is being made to\nfields that are to be arranged in columns, in rows or a with a flow layout.\n",
                "type": "VegaLite.Arrangement -> VegaLite.TextChannel"
            },
            {
                "name": "tStr",
                "comment": " Literal string value when encoding with a text channel. Can be useful for\nquick text annotation. For multi-line text, insert `\\n` at each line break or use\na `\"\"\"` multi-line string.\n\n    encoding\n        << position X [ pNum 300 ]\n        << position Y [ pNum 300 ]\n        << text [ tStr \"Upper limit\\nof range\" ]\n\n",
                "type": "String.String -> VegaLite.TextChannel"
            },
            {
                "name": "tTemporal",
                "comment": " Indicate a data field encoded as a text property is temporal.\n",
                "type": "VegaLite.TextChannel"
            },
            {
                "name": "tTimeUnit",
                "comment": " Time unit aggregation of field values when encoding with a text channel.\n",
                "type": "VegaLite.TimeUnit -> VegaLite.TextChannel"
            },
            {
                "name": "tTitle",
                "comment": " Title of a field when encoding with a text or tooltip channel. For multi-line\ntitles, insert `\\n` at each line break or use a `\"\"\"` multi-line string.\n",
                "type": "String.String -> VegaLite.TextChannel"
            },
            {
                "name": "tbCenter",
                "comment": " Align to centre of tick band.\n",
                "type": "VegaLite.TickBand"
            },
            {
                "name": "tbExpr",
                "comment": " Specify a tick band alignment with an expression that should evaluate to \"center\"\nor \"extent\".\n",
                "type": "String.String -> VegaLite.TickBand"
            },
            {
                "name": "tbExtent",
                "comment": " Align to extent (edges) of tick band.\n",
                "type": "VegaLite.TickBand"
            },
            {
                "name": "tdExpr",
                "comment": " Expression that evaluates to a text direction \"ltr\" (left-to-right) or\n'rtl' (right-to-left) .\n",
                "type": "String.String -> VegaLite.TextDirection"
            },
            {
                "name": "tdLeftToRight",
                "comment": " Indicate a left-to-right text direction.\n",
                "type": "VegaLite.TextDirection"
            },
            {
                "name": "tdRightToLeft",
                "comment": " Indicate a right-to-left text direction.\n",
                "type": "VegaLite.TextDirection"
            },
            {
                "name": "text",
                "comment": " Encode a text channel. The first parameter is a list of text encoding options\nsuch as the data to encode, number formatting etc.\n\n    enc =\n        encoding\n            << text [ tName \"keyword\", tNominal ]\n\n",
                "type": "List.List VegaLite.TextChannel -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"
            },
            {
                "name": "textMark",
                "comment": " [Text mark](https://vega.github.io/vega-lite/docs/text.html) to be\ndisplayed at some point location.\n",
                "type": "List.List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "tfBounds",
                "comment": " Specify a title anchor position relative to the full bounding box.\n",
                "type": "VegaLite.TitleFrame"
            },
            {
                "name": "tfExpr",
                "comment": " Specify a title anchor position as an expression that should evaluate to one\nof \"bounds\" or \"frame\".\n",
                "type": "String.String -> VegaLite.TitleFrame"
            },
            {
                "name": "tfGroup",
                "comment": " Specify a title anchor position relative to the group width / height.\n",
                "type": "VegaLite.TitleFrame"
            },
            {
                "name": "tiAnchor",
                "comment": " Anchor position when placing a title.\n",
                "type": "VegaLite.Anchor -> VegaLite.TitleProperty"
            },
            {
                "name": "tiAngle",
                "comment": " Angle of title text (degrees from horizontal).\n",
                "type": "Basics.Float -> VegaLite.TitleProperty"
            },
            {
                "name": "tiBaseline",
                "comment": " Vertical alignment of a title.\n",
                "type": "VegaLite.VAlign -> VegaLite.TitleProperty"
            },
            {
                "name": "tiColor",
                "comment": " Text colour of a title.\n",
                "type": "String.String -> VegaLite.TitleProperty"
            },
            {
                "name": "tiDx",
                "comment": " Delta offset of title and subtitle x-position.\n",
                "type": "Basics.Float -> VegaLite.TitleProperty"
            },
            {
                "name": "tiDy",
                "comment": " Delta offset of title and subtitle y-position.\n",
                "type": "Basics.Float -> VegaLite.TitleProperty"
            },
            {
                "name": "tiFont",
                "comment": " Title font.\n",
                "type": "String.String -> VegaLite.TitleProperty"
            },
            {
                "name": "tiFontSize",
                "comment": " Title font size.\n",
                "type": "Basics.Float -> VegaLite.TitleProperty"
            },
            {
                "name": "tiFontStyle",
                "comment": " Title font style (italic etc.).\n",
                "type": "String.String -> VegaLite.TitleProperty"
            },
            {
                "name": "tiFontWeight",
                "comment": " Title font weight.\n",
                "type": "VegaLite.FontWeight -> VegaLite.TitleProperty"
            },
            {
                "name": "tiFrame",
                "comment": " Title position anchor. Can be relative to the full bounding box\n([frBounds](#frBounds)) or the group in which the titled visualization belongs\n([frGroup](#frGroup)).\n",
                "type": "VegaLite.TitleFrame -> VegaLite.TitleProperty"
            },
            {
                "name": "tiLimit",
                "comment": " Maximum length of the title display in pixel units.\n",
                "type": "Basics.Float -> VegaLite.TitleProperty"
            },
            {
                "name": "tiLineHeight",
                "comment": " Line height (vertical spacing) for title text.\n",
                "type": "Basics.Float -> VegaLite.TitleProperty"
            },
            {
                "name": "tiNumExpr",
                "comment": " Provide an [expression](https://vega.github.io/vega/docs/expressions/) to a\ntitle property function requiring a numeric value. This can be used for interactive\nparameterisation when an expression is bound to an input element. For example,\n\n    ps =\n        params\n            << param \"fs\"\n                [ paValue (num 0)\n                , paBind (ipRange [ inMax 32 ])\n                ]\n\n    ttl =\n        title \"My title\" [ tiNumExpr \"fs\" tiFontSize ]\n\n",
                "type": "String.String -> (number -> VegaLite.TitleProperty) -> VegaLite.TitleProperty"
            },
            {
                "name": "tiOffset",
                "comment": " Offset in pixel units of the title relative to the chart body.\n",
                "type": "Basics.Float -> VegaLite.TitleProperty"
            },
            {
                "name": "tiOrient",
                "comment": " Placement of title relative to the chart body.\n",
                "type": "VegaLite.Side -> VegaLite.TitleProperty"
            },
            {
                "name": "tiStrExpr",
                "comment": " Provide an [expression](https://vega.github.io/vega/docs/expressions/) to\na title property function requiring a string value. This can be used to provide an\ninteractive parameterisation of a title property when an expression is bound to an\ninput element. For example,\n\n    ps =\n        params\n            << params \"clr\"\n                [ paValue (str \"black\")\n                , paBind (ipColor [])\n                ]\n\n    ttl =\n        title \"My title\" [ tiStrExpr \"clr\" tiColor ]\n\n",
                "type": "String.String -> (String.String -> VegaLite.TitleProperty) -> VegaLite.TitleProperty"
            },
            {
                "name": "tiStyle",
                "comment": " A list of named styles to apply to title. A named style can be specified via\n[coMarkStyles](#coMarkStyles) if more than one style is required. Later styles\nin the list will override earlier styles if there is a conflict in any of the mark\nproperties specified.\n\nWhile this is provided for compatibility with Vega-Lite style specification, for\ngreater type safety in elm-vegalite, instead create functions that generate\n[TitleProperties](#TitleProperty).\n\n",
                "type": "List.List String.String -> VegaLite.TitleProperty"
            },
            {
                "name": "tiSubtitle",
                "comment": " Subtitle text, placed beneath the primary title. For multi-line subtitles,\ninsert `\\n` at each line break or use a `\"\"\"` multi-line string.\n",
                "type": "String.String -> VegaLite.TitleProperty"
            },
            {
                "name": "tiSubtitleColor",
                "comment": " Color of a subtitle.\n",
                "type": "String.String -> VegaLite.TitleProperty"
            },
            {
                "name": "tiSubtitleFont",
                "comment": " Font name of a subtitle.\n",
                "type": "String.String -> VegaLite.TitleProperty"
            },
            {
                "name": "tiSubtitleFontSize",
                "comment": " Font size of a subtitle.\n",
                "type": "Basics.Float -> VegaLite.TitleProperty"
            },
            {
                "name": "tiSubtitleFontStyle",
                "comment": " Font style of a subtitle such as `\"normal\"` or `\"italic\"`.\n",
                "type": "String.String -> VegaLite.TitleProperty"
            },
            {
                "name": "tiSubtitleFontWeight",
                "comment": " Font weight of a subtitle.\n",
                "type": "VegaLite.FontWeight -> VegaLite.TitleProperty"
            },
            {
                "name": "tiSubtitleLineHeight",
                "comment": " Line height in pixels of each line of text in a multi-line subtitle.\n",
                "type": "Basics.Float -> VegaLite.TitleProperty"
            },
            {
                "name": "tiSubtitlePadding",
                "comment": " Padding in pixels between title and subtitle text.\n",
                "type": "Basics.Float -> VegaLite.TitleProperty"
            },
            {
                "name": "tiZIndex",
                "comment": " Drawing order of a title relative to the other chart elements. 1 indicates\ntitle is drawn in front of chart marks, 0 indicates it is drawn behind them.\n",
                "type": "Basics.Int -> VegaLite.TitleProperty"
            },
            {
                "name": "tick",
                "comment": " Short line ([tick](https://vega.github.io/vega-lite/docs/tick.html))\nmark for symbolising point locations.\n",
                "type": "List.List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "ticoAnchor",
                "comment": " Default anchor position when placing titles.\n",
                "type": "VegaLite.Anchor -> VegaLite.TitleConfig"
            },
            {
                "name": "ticoAngle",
                "comment": " Default angle when orientating titles (degrees from horizontal).\n",
                "type": "Basics.Float -> VegaLite.TitleConfig"
            },
            {
                "name": "ticoBaseline",
                "comment": " Default vertical alignment when placing titles.\n",
                "type": "VegaLite.VAlign -> VegaLite.TitleConfig"
            },
            {
                "name": "ticoColor",
                "comment": " Default color when showing titles.\n",
                "type": "String.String -> VegaLite.TitleConfig"
            },
            {
                "name": "ticoDx",
                "comment": " Default delta offset of title and subtitle x-position.\n",
                "type": "Basics.Float -> VegaLite.TitleConfig"
            },
            {
                "name": "ticoDy",
                "comment": " Default delta offset of title and subtitle y-position.\n",
                "type": "Basics.Float -> VegaLite.TitleConfig"
            },
            {
                "name": "ticoFont",
                "comment": " Default font when showing titles.\n",
                "type": "String.String -> VegaLite.TitleConfig"
            },
            {
                "name": "ticoFontSize",
                "comment": " Default font size when showing titles.\n",
                "type": "Basics.Float -> VegaLite.TitleConfig"
            },
            {
                "name": "ticoFontStyle",
                "comment": " Default font style (italic etc.) when showing titles.\n",
                "type": "String.String -> VegaLite.TitleConfig"
            },
            {
                "name": "ticoFontWeight",
                "comment": " Default font weight when showing titles.\n",
                "type": "VegaLite.FontWeight -> VegaLite.TitleConfig"
            },
            {
                "name": "ticoFrame",
                "comment": " Title position anchor. Can be relative to the full bounding box\n([frBounds](#frBounds)) or the group in which the titled visualization belongs\n([frGroup](#frGroup)).\n",
                "type": "VegaLite.TitleFrame -> VegaLite.TitleConfig"
            },
            {
                "name": "ticoLimit",
                "comment": " Default maximum length in pixel units when showing titles.\n",
                "type": "Basics.Float -> VegaLite.TitleConfig"
            },
            {
                "name": "ticoLineHeight",
                "comment": " Line height (vertical spacing) for title text.\n",
                "type": "Basics.Float -> VegaLite.TitleConfig"
            },
            {
                "name": "ticoNumExpr",
                "comment": " Provide an [expression](https://vega.github.io/vega/docs/expressions/) to a\ntitle configuration function requiring a numeric value.\n",
                "type": "String.String -> (number -> VegaLite.TitleConfig) -> VegaLite.TitleConfig"
            },
            {
                "name": "ticoOffset",
                "comment": " Default offset in pixel units of titles relative to the chart body.\n",
                "type": "Basics.Float -> VegaLite.TitleConfig"
            },
            {
                "name": "ticoOrient",
                "comment": " Default placement of titles relative to the chart body.\n",
                "type": "VegaLite.Side -> VegaLite.TitleConfig"
            },
            {
                "name": "ticoStrExpr",
                "comment": " Provide an [expression](https://vega.github.io/vega/docs/expressions/) to\na title configuration function requiring a string value.\n",
                "type": "String.String -> (String.String -> VegaLite.TitleConfig) -> VegaLite.TitleConfig"
            },
            {
                "name": "ticoStyle",
                "comment": " A list of named styles to apply to titles. A named style can be specified via\n[coMarkStyles](#coMarkStyles) if more than one style is required. Later styles\nin the list will override earlier styles if there is a conflict in any of the\nmark properties specified.\n",
                "type": "List.List String.String -> VegaLite.TitleConfig"
            },
            {
                "name": "ticoSubtitleColor",
                "comment": " Default color of a subtitle.\n",
                "type": "String.String -> VegaLite.TitleProperty"
            },
            {
                "name": "ticoSubtitleFont",
                "comment": " Default font name of a subtitle.\n",
                "type": "String.String -> VegaLite.TitleConfig"
            },
            {
                "name": "ticoSubtitleFontSize",
                "comment": " Default font size of a subtitle.\n",
                "type": "Basics.Float -> VegaLite.TitleConfig"
            },
            {
                "name": "ticoSubtitleFontStyle",
                "comment": " Default ont style of a subtitle such as `\"normal\"` or `\"italic\"`.\n",
                "type": "String.String -> VegaLite.TitleConfig"
            },
            {
                "name": "ticoSubtitleFontWeight",
                "comment": " Default font weight of a subtitle.\n",
                "type": "VegaLite.FontWeight -> VegaLite.TitleConfig"
            },
            {
                "name": "ticoSubtitleLineHeight",
                "comment": " Default line height in pixels of each line of text in a subtitle.\n",
                "type": "Basics.Float -> VegaLite.TitleConfig"
            },
            {
                "name": "ticoSubtitlePadding",
                "comment": " Default padding in pixels between title and subtitle text.\n",
                "type": "Basics.Float -> VegaLite.TitleConfig"
            },
            {
                "name": "ticoZIndex",
                "comment": " Default drawing order of titles relative to the other chart elements. 1 indicates\ntitles are drawn in front of chart marks, 0 indicates they are drawn behind them.\n",
                "type": "Basics.Int -> VegaLite.TitleConfig"
            },
            {
                "name": "timeUnitAs",
                "comment": " Create a new data field based on the given temporal binning. Unlike the\ndirect encoding binning, this transformation is named and so can be referred\nto in multiple encodings. The first parameter is the width of each temporal bin,\nthe second is the field to bin and the third is name to give the newly binned\nfield.\n",
                "type": "VegaLite.TimeUnit -> String.String -> String.String -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"
            },
            {
                "name": "title",
                "comment": " Title to be displayed for a plot. The first parameter is the text of the title,\nthe second a list of any title properties to configure its appearance. To display\na title over more than one line, insert `\\n` at each line break or use a `\"\"\"`\nmulti-line string.\n\n    title \"First line\\nSecond line\" []\n\nor\n\n    title \"\"\"First line\n    Second line\"\"\" []\n\n",
                "type": "String.String -> List.List VegaLite.TitleProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "titleExpr",
                "comment": " Expression that evaluates to a title. Similar to [title](#title) except the\ncontent of the title is the evaluated expression (first parameter). For example:\n\n    let\n        ps =\n            params << param \"ttl\" [ paValue (num (2 * pi)) ]\n    in\n    toVegaLite [ titleExpr \"ttl\" [] ]\n\n",
                "type": "String.String -> List.List VegaLite.TitleProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "toVegaLite",
                "comment": " Convert a list of Vega-Lite specifications into a single JSON object that may be\npassed to Vega-Lite for graphics generation. Commonly these will include at least\ndata, mark and encoding specifications.\n\nWhile simple functions like `bar` may be provided directly, it is usually clearer\nto label more complex functions such as encodings with separate expressions.\n\nSpecifications can be built up by chaining functions such as [dataColumn](#dataColumn)\nor [position](#position). Functional composition using the `<<` operator allows\nthis to be done compactly:\n\n    let\n        data =\n            dataFromColumns []\n                << dataColumn \"a\" (strs [ \"C\", \"C\", \"D\" ])\n                << dataColumn \"b\" (nums [ 2, 7, 1 ])\n\n        enc =\n            encoding\n                << position X [ pName \"a\" ]\n                << position Y [ pName \"b\", pAggregate opMean ]\n    in\n    toVegaLite [ data [], enc [], bar [] ]\n\n",
                "type": "List.List ( VegaLite.VLProperty, VegaLite.Spec ) -> VegaLite.Spec"
            },
            {
                "name": "tooltip",
                "comment": " Encode a tooltip channel using a single data field.\n\n     tooltip [ tName \"Month\", tTemporal, tFormat \"%B %Y\" ]\n\nTo encode multiple tooltip values with a mark, use [tooltips](#tooltips).\n\n",
                "type": "List.List VegaLite.TextChannel -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"
            },
            {
                "name": "tooltips",
                "comment": " Encode a tooltip channel using multiple data fields. The first parameter is a\nlist of the multiple tooltips, each of which is a list of text channel properties\nthat define the channel.\n\n    tooltips\n        [ [ tName \"month\", tTemporal, tFormat \"%B %Y\" ]\n        , [ tName \"temperature\", tQuant ]\n        ]\n\n",
                "type": "List.List (List.List VegaLite.TextChannel) -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"
            },
            {
                "name": "topojsonFeature",
                "comment": " A topoJSON feature format containing an object with the given name. The name\nof the object can be found by inspecting the topoJSON file and searching for the\nvalue associated with the `objects` key.\n\n    geodata =\n        dataFromUrl \"city.json\" [ topojsonFeature \"boroughs\" ]\n\n",
                "type": "String.String -> VegaLite.Format"
            },
            {
                "name": "topojsonMesh",
                "comment": " A topoJSON mesh format containing an object with the given name. Unlike\n`topojsonFeature`, the corresponding geo data are returned as a single unified mesh,\nnot as individual GeoJSON features.\n",
                "type": "String.String -> VegaLite.Format"
            },
            {
                "name": "tpAltKey",
                "comment": " Specify that data values in a selection are toggled when interacted with on\nmultiple occasions while the alt key is held down.\n",
                "type": "VegaLite.TogglePredicate"
            },
            {
                "name": "tpCtrlKey",
                "comment": " Specify that data values in a selection are toggled when interacted with on\nmultiple occasions while the control key is held down.\n",
                "type": "VegaLite.TogglePredicate"
            },
            {
                "name": "tpExpr",
                "comment": " Specify that repeated selections are toggled when the given\n[expression](https://vega.github.io/vega/docs/expressions/) evaluates to true.\nThis allows, for example, multiple key modifiers to generate toggling:\n\n    ps =\n        params\n            << param \"paint\"\n                [ paSelect sePoint\n                    [ seOn \"mouseover\"\n                    , seToggle (tpExpr \"event.shiftKey && event.ctrlKey\")\n                    ]\n                ]\n\n",
                "type": "String.String -> VegaLite.TogglePredicate"
            },
            {
                "name": "tpFalse",
                "comment": " Specify that data values in a selection are never unselected when interacted\nwith on multiple occasions. This allows a single selected item to be guaranteed.\n",
                "type": "VegaLite.TogglePredicate"
            },
            {
                "name": "tpShiftKey",
                "comment": " Specify that data values in a selection are toggled when interacted with on\nmultiple occasions while the shift key is held down. This is the default behaviour\nso should only be needed if moving back from some other specified behavior.\n",
                "type": "VegaLite.TogglePredicate"
            },
            {
                "name": "trail",
                "comment": " [Trail mark](https://vega.github.io/vega-lite/docs/trail.html) (line\nwith variable width along its length).\n",
                "type": "List.List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "transform",
                "comment": " Create a single transform from a list of transformation specifications. The\norder of transformations can be important, e.g. labels created with [calculateAs](#calculateAs),\n[timeUnitAs](#timeUnitAs) and [binAs](#binAs) that are used in other transformations.\nUsing the functional composition pipeline idiom (as example below) allows you to\nprovide the transformations in the order intended in a clear manner.\n\n    trans =\n        transform\n            << filter (fiExpr \"datum.year == 2010\")\n            << calculateAs \"datum.sex == 2 ? 'Female' : 'Male'\" \"gender\"\n\n",
                "type": "List.List VegaLite.LabelledSpec -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "transverseMercator",
                "comment": " A transverse Mercator map projection.\n",
                "type": "VegaLite.Projection"
            },
            {
                "name": "true",
                "comment": " A true value used for functions that can accept a Boolean literal or a reference\nto something that generates a Boolean value. Convenience function equivalent to `boo True`\n",
                "type": "VegaLite.DataValue"
            },
            {
                "name": "tsv",
                "comment": " TSV data file format (only necessary if the file extension does not indicate the\ntype).\n",
                "type": "VegaLite.Format"
            },
            {
                "name": "ttData",
                "comment": " Indicate tooltips are generated by all fields in the underlying data.\n\n    circle [ maTooltip ttData ]\n\n",
                "type": "VegaLite.TooltipContent"
            },
            {
                "name": "ttEncoding",
                "comment": " Indicate tooltips should be enabled using the encoded data of the mark.\n\n    circle [ maTooltip ttEncoding ]\n\n",
                "type": "VegaLite.TooltipContent"
            },
            {
                "name": "ttNone",
                "comment": " Indicate that tooltips should be disabled for the mark (default).\n\n    circle [ maTooltip ttNone ]\n\n",
                "type": "VegaLite.TooltipContent"
            },
            {
                "name": "tuMaxBins",
                "comment": " Specify the maximum number of bins used when discretizing time units. Can be\nuseful as an alternative to explicitly providing a time unit to bin by as it will\nbe inferred from the temporal domain extent and the number of bins. For example,\nwhen applied to a dataset of hourly readings for a full year, the following will\nbin into days:\n\n    tuMaxBins 366\n\n",
                "type": "Basics.Int -> VegaLite.TimeUnit"
            },
            {
                "name": "tuStep",
                "comment": " Specify the the number of steps between time unit bins, in terms of the least\nsignificant unit provided. For example, the following will bin temporal data into\nbiweekly weekly groups:\n\n    tuStep 14 yearMonthDate\n\n",
                "type": "Basics.Float -> VegaLite.TimeUnit -> VegaLite.TimeUnit"
            },
            {
                "name": "url",
                "comment": " Encode a url channel. The first parameter is a list of url channel\nproperties that characterise the hyperlink to encode with. This is used for\nspecifying data-driven image files for the [image](#image) mark.\n\n    encData =\n        encoding\n            << url [ hName \"url\", hNominal ]\n\n    encLiteral =\n        encoding\n            << url [ hStr \"http://www.imdb.com\" ]\n\n",
                "type": "List.List VegaLite.HyperlinkChannel -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"
            },
            {
                "name": "utc",
                "comment": " UTC version of a given a time (coordinated universal time, independent of local\ntime zones or daylight saving). To encode a time as UTC (coordinated universal time,\nindependent of local time zones or daylight saving), just use this function to convert\nanother `TimeUnit` generating function.\n\n    encoding\n        << position X\n            [ pName \"date\"\n            , pTemporal\n            , pTimeUnit (utc yearMonthDateHours)\n            ]\n\n",
                "type": "VegaLite.TimeUnit -> VegaLite.TimeUnit"
            },
            {
                "name": "vConcat",
                "comment": " Juxtapose some specifications vertically in a row layout of views.\n",
                "type": "List.List VegaLite.Spec -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "vaAlphabetic",
                "comment": " Vertically align text marks by their baseline (e.g. bottom of an 'x').\n",
                "type": "VegaLite.VAlign"
            },
            {
                "name": "vaBottom",
                "comment": " Vertically align text marks by the bottom of descenders (e.g. bottom of a 'g').\n",
                "type": "VegaLite.VAlign"
            },
            {
                "name": "vaExpr",
                "comment": " Expression that evaluates to some vertical text alignment such as \"top\", \"bottom\"\nor \"alphabetic\".\n",
                "type": "String.String -> VegaLite.VAlign"
            },
            {
                "name": "vaLineBottom",
                "comment": " Vertically align text marks by the bottom of the space defined by line height\n([maLineHeight](#maLineHeight), [tiLineHeight](#tiLineHeight) etc.).\n",
                "type": "VegaLite.VAlign"
            },
            {
                "name": "vaLineTop",
                "comment": " Vertically align text marks by the top of the space defined by line height\n([maLineHeight](#maLineHeight), [tiLineHeight](#tiLineHeight) etc.).\n",
                "type": "VegaLite.VAlign"
            },
            {
                "name": "vaMiddle",
                "comment": " Vertically align text marks by their middle (e.g. middle of an 'x').\n",
                "type": "VegaLite.VAlign"
            },
            {
                "name": "vaTop",
                "comment": " Vertically align text marks by the top of ascenders (e.g. top of an 'A').\n",
                "type": "VegaLite.VAlign"
            },
            {
                "name": "vbNumExpr",
                "comment": " Provide an [expression](https://vega.github.io/vega/docs/expressions/) to a\nview background function requiring a numeric value. This can be used for interactive\nparameterisation when an expression is bound to an input element. For example,\n\n    ps =\n        params\n            << param \"r\"\n                [ paValue (num 0)\n                , paBind (ipRange [ inMax 20 ])\n                ]\n\n    bg =\n        viewBackground [ vbNumExpr \"r\" viewCornerRadius ]\n\n",
                "type": "String.String -> (number -> VegaLite.ViewBackground) -> VegaLite.ViewBackground"
            },
            {
                "name": "vbNumsExpr",
                "comment": " Provide an [expression](https://vega.github.io/vega/docs/expressions/) to\na view background function requiring a list of numbers (for dash styles). This can\nbe used to provide an interactive parameterisation of a view background dash property\nwhen an expression is bound to an input element. For example,\n\n    ps =\n        params\n            << param \"dashStyle\"\n                [ paValue (nums [ 2, 2 ])\n                , paBind (ipSelect [ inDataOptions [ nums [ 2, 2 ], nums [ 8, 8 ] ] ])\n                ]\n\n    bg =\n        viewBackground [ vbNumsExpr \"dashStyle\" viewStrokeDash ]\n\n",
                "type": "String.String -> (List.List number -> VegaLite.ViewBackground) -> VegaLite.ViewBackground"
            },
            {
                "name": "vbStrExpr",
                "comment": " Provide an [expression](https://vega.github.io/vega/docs/expressions/) to\na view background function requiring a `Maybe String` value. This can be used to\nprovide an interactive parameterisation of a view background when an expression\nis bound to an input element. For example,\n\n    ps =\n        params\n            << param \"clr\"\n                [ paValue (str \"white\")\n                , paBind (ipColor [])\n                ]\n\n    bg =\n        viewBackground [ vbStrExpr \"clr\" viewFill ]\n\n",
                "type": "String.String -> (Maybe.Maybe String.String -> VegaLite.ViewBackground) -> VegaLite.ViewBackground"
            },
            {
                "name": "vicoBackground",
                "comment": " Configure the default single view style.\n",
                "type": "List.List VegaLite.ViewBackground -> VegaLite.ViewConfig"
            },
            {
                "name": "vicoBooExpr",
                "comment": " Provide an [expression](https://vega.github.io/vega/docs/expressions/) to a\nview configuration function a Boolean value.\n",
                "type": "String.String -> (Basics.Bool -> VegaLite.ViewConfig) -> VegaLite.ViewConfig"
            },
            {
                "name": "vicoClip",
                "comment": " Whether or not by default single views should be clipped. Clipping will remove\neveryhing outside the data area including axes and legends.\n",
                "type": "Basics.Bool -> VegaLite.ViewConfig"
            },
            {
                "name": "vicoContinuousHeight",
                "comment": " Default height of single views when the plot has continuous y-field.\n",
                "type": "Basics.Float -> VegaLite.ViewConfig"
            },
            {
                "name": "vicoContinuousWidth",
                "comment": " Default width of single views when the plot has continuous x-field.\n",
                "type": "Basics.Float -> VegaLite.ViewConfig"
            },
            {
                "name": "vicoCornerRadius",
                "comment": " The radius in pixels of rounded rectangle corners.\n",
                "type": "Basics.Float -> VegaLite.ViewConfig"
            },
            {
                "name": "vicoCursor",
                "comment": " Default cursor for single views.\n",
                "type": "VegaLite.Cursor -> VegaLite.ViewConfig"
            },
            {
                "name": "vicoDiscreteHeight",
                "comment": " Default height of single views when the plot has discrete y-field.\n",
                "type": "Basics.Float -> VegaLite.ViewConfig"
            },
            {
                "name": "vicoDiscreteWidth",
                "comment": " Default width of single views when the plot has discrete x-field.\n",
                "type": "Basics.Float -> VegaLite.ViewConfig"
            },
            {
                "name": "vicoFill",
                "comment": " Default fill color for single views.\n",
                "type": "Maybe.Maybe String.String -> VegaLite.ViewConfig"
            },
            {
                "name": "vicoFillOpacity",
                "comment": " Default fill opacity for single views.\n",
                "type": "Basics.Float -> VegaLite.ViewConfig"
            },
            {
                "name": "vicoNumExpr",
                "comment": " Provide an [expression](https://vega.github.io/vega/docs/expressions/) to a\nview background confguration function requiring a numeric value.\n",
                "type": "String.String -> (number -> VegaLite.ViewConfig) -> VegaLite.ViewConfig"
            },
            {
                "name": "vicoNumsExpr",
                "comment": " Provide an [expression](https://vega.github.io/vega/docs/expressions/) to a\nview background configuration function requiring a list of numbers (for dash styles).\n",
                "type": "String.String -> (List.List number -> VegaLite.ViewConfig) -> VegaLite.ViewConfig"
            },
            {
                "name": "vicoOpacity",
                "comment": " Default overall opacity for single views.\n",
                "type": "Basics.Float -> VegaLite.ViewConfig"
            },
            {
                "name": "vicoStep",
                "comment": " Default step size for x/y discrete fields.\n",
                "type": "Basics.Float -> VegaLite.ViewConfig"
            },
            {
                "name": "vicoStrExpr",
                "comment": " Provide an [expression](https://vega.github.io/vega/docs/expressions/) to a\nview background configuration function requiring a `Maybe String` value.\n",
                "type": "String.String -> (Maybe.Maybe String.String -> VegaLite.ViewConfig) -> VegaLite.ViewConfig"
            },
            {
                "name": "vicoStroke",
                "comment": " Default stroke color for single views. If `Nothing` is provided,\nno strokes are drawn around the view.\n",
                "type": "Maybe.Maybe String.String -> VegaLite.ViewConfig"
            },
            {
                "name": "vicoStrokeCap",
                "comment": " Default stroke cap line-ending style for single views.\n",
                "type": "VegaLite.StrokeCap -> VegaLite.ViewConfig"
            },
            {
                "name": "vicoStrokeDash",
                "comment": " Default stroke dash style for single views.\n",
                "type": "List.List Basics.Float -> VegaLite.ViewConfig"
            },
            {
                "name": "vicoStrokeDashOffset",
                "comment": " Default stroke dash offset for single views.\n",
                "type": "Basics.Float -> VegaLite.ViewConfig"
            },
            {
                "name": "vicoStrokeJoin",
                "comment": " Default stroke line-joining style for single views.\n",
                "type": "VegaLite.StrokeJoin -> VegaLite.ViewConfig"
            },
            {
                "name": "vicoStrokeMiterLimit",
                "comment": " Default stroke mitre limit at which to bevel a line join in single views.\n",
                "type": "Basics.Float -> VegaLite.ViewConfig"
            },
            {
                "name": "vicoStrokeOpacity",
                "comment": " Default stroke opacity for single views.\n",
                "type": "Basics.Float -> VegaLite.ViewConfig"
            },
            {
                "name": "vicoStrokeWidth",
                "comment": " Default stroke width of single views.\n",
                "type": "Basics.Float -> VegaLite.ViewConfig"
            },
            {
                "name": "viewBackground",
                "comment": " The background style of a single view or layer in a view composition.\n",
                "type": "List.List VegaLite.ViewBackground -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "viewCornerRadius",
                "comment": " The radius in pixels of rounded corners in single view or layer background.\n",
                "type": "Basics.Float -> VegaLite.ViewBackground"
            },
            {
                "name": "viewFill",
                "comment": " Fill color for a single view or layer background.\n",
                "type": "Maybe.Maybe String.String -> VegaLite.ViewBackground"
            },
            {
                "name": "viewFillOpacity",
                "comment": " Fill opacity for a single view or layer background.\n",
                "type": "Basics.Float -> VegaLite.ViewBackground"
            },
            {
                "name": "viewOpacity",
                "comment": " Overall opacity for a single view or layer background.\n",
                "type": "Basics.Float -> VegaLite.ViewBackground"
            },
            {
                "name": "viewStroke",
                "comment": " Stroke color for line around a single view or layer background. If `Nothing`\nis provided, no strokes are drawn around the view.\n",
                "type": "Maybe.Maybe String.String -> VegaLite.ViewBackground"
            },
            {
                "name": "viewStrokeCap",
                "comment": " Stroke cap line-ending around a single view or layer background.\n",
                "type": "VegaLite.StrokeCap -> VegaLite.ViewBackground"
            },
            {
                "name": "viewStrokeDash",
                "comment": " Stroke dash style for a line around a single view or layer background.\n",
                "type": "List.List Basics.Float -> VegaLite.ViewBackground"
            },
            {
                "name": "viewStrokeDashOffset",
                "comment": " Stroke dash offset for line around a single view or layer background.\n",
                "type": "Basics.Float -> VegaLite.ViewBackground"
            },
            {
                "name": "viewStrokeJoin",
                "comment": " Stroke line-joining style around a single view or layer background.\n",
                "type": "VegaLite.StrokeJoin -> VegaLite.ViewBackground"
            },
            {
                "name": "viewStrokeMiterLimit",
                "comment": " Stroke mitre limit at which to bevel a line join around a single view or\nlayer background.\n",
                "type": "Basics.Float -> VegaLite.ViewBackground"
            },
            {
                "name": "viewStrokeOpacity",
                "comment": " Stroke opacity around a single view or layer background.\n",
                "type": "Basics.Float -> VegaLite.ViewBackground"
            },
            {
                "name": "viewStrokeWidth",
                "comment": " Stroke around a single view or layer background.\n",
                "type": "Basics.Float -> VegaLite.ViewBackground"
            },
            {
                "name": "viewStyle",
                "comment": " A list of named styles to apply to a single view background. A named style\ncan be specified via [coMarkStyles](#coMarkStyles) if more than one style is required.\nLater styles in the list will override earlier styles if there is a conflict in\nany of the mark properties specified.\n",
                "type": "List.List String.String -> VegaLite.ViewBackground"
            },
            {
                "name": "week",
                "comment": " Indicate temporal binning by week of year, so a 10 year sequence would have\nup to 53 bins. Weeks are Sunday-based and days before the first Sunday of the year\nare considered to be in week 0, the first Sunday of the year is the start of week 1,\nthe second Sunday week 2, _etc._\n",
                "type": "VegaLite.TimeUnit"
            },
            {
                "name": "weekDay",
                "comment": " Indicate temporal binning by day of week though the year, so a 10 year sequence\nwould have up to 53\\*7 bins.\n",
                "type": "VegaLite.TimeUnit"
            },
            {
                "name": "weekDayHours",
                "comment": " Indicate temporal binning by hour of day though the year, so a 10 year sequence\nwould have up to 52\\*7\\*24 bins.\n",
                "type": "VegaLite.TimeUnit"
            },
            {
                "name": "weekDayHoursMinutes",
                "comment": " Indicate temporal binning by minute though the year, so a 10 year sequence\nwould have up to 52\\*7\\*24\\*60 bins.\n",
                "type": "VegaLite.TimeUnit"
            },
            {
                "name": "weekDayHoursMinutesSeconds",
                "comment": " Indicate temporal binning by the second though the year, so a 10 year sequence\nwould have up to 52\\*7\\*24\\*60\\*60 bins.\n",
                "type": "VegaLite.TimeUnit"
            },
            {
                "name": "wiAggregateOp",
                "comment": " An aggregate operation to be used in a window transformation.\n\n    transform\n        << window [ ( [ wiAggregateOp opSum, wiField \"Time\" ], \"TotalTime\" ) ]\n            [ wiFrame Nothing Nothing ]\n\n",
                "type": "VegaLite.Operation -> VegaLite.Window"
            },
            {
                "name": "wiAscending",
                "comment": " Indicate that the given field should be sorted in ascending order when performing\na window transform.\n",
                "type": "String.String -> VegaLite.SortField"
            },
            {
                "name": "wiDescending",
                "comment": " Indicate that the given field should be sorted in descending order when performing\na window transform.\n",
                "type": "String.String -> VegaLite.SortField"
            },
            {
                "name": "wiField",
                "comment": " Field for which to compute a window operation. Not needed for\noperations that do not apply to fields such as [opCount](#opCount), [woRank](#woRank)\nand [woDenseRank](#woDenseRank).\n",
                "type": "String.String -> VegaLite.Window"
            },
            {
                "name": "wiFrame",
                "comment": " Moving window for use by a window transform. The two parameters should either\nbe [Just](https://package.elm-lang.org/packages/elm/core/latest/Maybe#Maybe) a number\nindicating the offset from the current data object, or\n[Nothing](https://package.elm-lang.org/packages/elm/core/latest/Maybe#Maybe) to\nindicate unbounded rows preceding or following the current data object.\n",
                "type": "Maybe.Maybe Basics.Int -> Maybe.Maybe Basics.Int -> VegaLite.WindowProperty"
            },
            {
                "name": "wiGroupBy",
                "comment": " Fields for partitioning data objects in a window transform into separate windows.\nIf unspecified, all points will be in a single group.\n",
                "type": "List.List String.String -> VegaLite.WindowProperty"
            },
            {
                "name": "wiIgnorePeers",
                "comment": " Whether or not the sliding window frame in a window transform should ignore\npeer values (those considered identical by the sort criteria).\n",
                "type": "Basics.Bool -> VegaLite.WindowProperty"
            },
            {
                "name": "wiOp",
                "comment": " Window-specific operation to be used in a window transformation.\n",
                "type": "VegaLite.WOperation -> VegaLite.Window"
            },
            {
                "name": "wiParam",
                "comment": " Numeric parameter for window-only operations that can be parameterised\n([woPercentile](#woPercentile), [woLag](#woLag), [woLead](#woLead) and\n[woNthValue](#woNthValue)).\n",
                "type": "Basics.Int -> VegaLite.Window"
            },
            {
                "name": "wiSort",
                "comment": " Comparator for sorting data objects within a window transform.\n",
                "type": "List.List VegaLite.SortField -> VegaLite.WindowProperty"
            },
            {
                "name": "width",
                "comment": " Override the default width of the visualization in pixel units. If not\nspecified, the width will be calculated based on the content of the visualization.\n\n    toVegaLite [ width 540, data [], enc [], bar [] ]\n\nHow the content is sized relative to this width specification can be customised\nwith [autosize](#autosize).\n\n",
                "type": "Basics.Float -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "widthOfContainer",
                "comment": " Set the width of the view to be that of the surrounding container. Allows\nresponsive sizing to be specified.\n",
                "type": "( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "widthStep",
                "comment": " Set the width of the discrete x-field (e.g. individual bars in a bar chart).\nThe total width is then calculated based on the number of discrete fields (e.g. bars).\n\n    toVegaLite [ widthStep 17, data [], enc [], bar [] ]\n\n",
                "type": "Basics.Float -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "widthStepOffset",
                "comment": " Set the width of the offset-grouped discrete x-fields. The total width is then\ncalculated based on the number of offset discrete fields (e.g. groups of bars with\n`position XOffset` applied).\n",
                "type": "Basics.Float -> ( VegaLite.VLProperty, VegaLite.Spec )"
            },
            {
                "name": "window",
                "comment": " Window transform for performing calculations over sorted groups of\ndata objects such as ranking, lead/lag analysis, running sums and averages.\n\nThe first parameter is a list of tuples each comprising a window transform field\ndefinition and an output name. The second is the window transform definition.\n\n       trans =\n           transform\n               << window [ ( [ wiAggregateOp opSum, wiField \"Time\" ], \"TotalTime\" ) ]\n                   [ wiFrame Nothing Nothing ]\n\n",
                "type": "List.List ( List.List VegaLite.Window, String.String ) -> List.List VegaLite.WindowProperty -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"
            },
            {
                "name": "woCumeDist",
                "comment": " Cumulative distribution function to be applied in a window transform.\n",
                "type": "VegaLite.WOperation"
            },
            {
                "name": "woDenseRank",
                "comment": " Dense rank function to be applied in a window transform.\n",
                "type": "VegaLite.WOperation"
            },
            {
                "name": "woFirstValue",
                "comment": " First value in a sliding window to be applied in a window transform.\n",
                "type": "VegaLite.WOperation"
            },
            {
                "name": "woLag",
                "comment": " Value preceding the current object in a sliding window to be applied in a window transform.\n",
                "type": "VegaLite.WOperation"
            },
            {
                "name": "woLastValue",
                "comment": " Last value in a sliding window to be applied in a window transform.\n",
                "type": "VegaLite.WOperation"
            },
            {
                "name": "woLead",
                "comment": " Value following the current object in a sliding window to be applied in a window transform.\n",
                "type": "VegaLite.WOperation"
            },
            {
                "name": "woNthValue",
                "comment": " Nth value in a sliding window to be applied in a window transform.\n",
                "type": "VegaLite.WOperation"
            },
            {
                "name": "woPercentRank",
                "comment": " Percentile of values in a sliding window to be applied in a window transform.\n",
                "type": "VegaLite.WOperation"
            },
            {
                "name": "woPercentile",
                "comment": " Value preceding the current object in a sliding window to be applied in a window transform.\n",
                "type": "VegaLite.WOperation"
            },
            {
                "name": "woRank",
                "comment": " Rank function to be applied in a window transform.\n",
                "type": "VegaLite.WOperation"
            },
            {
                "name": "woRowNumber",
                "comment": " Assign consecutive row number to values in a data object to be applied in a\nwindow transform.\n",
                "type": "VegaLite.WOperation"
            },
            {
                "name": "year",
                "comment": " Indicate temporal binning into year categories.\n",
                "type": "VegaLite.TimeUnit"
            },
            {
                "name": "yearDayOfYear",
                "comment": " Indicate temporal binning with a resolution of days so a ten year sequence\nwould have up to approximately 10\\*365 bins.\n",
                "type": "VegaLite.TimeUnit"
            },
            {
                "name": "yearMonth",
                "comment": " Indicate temporal binning with a resolution of months so a ten year sequence\nwould have up to 10\\*12 bins.\n",
                "type": "VegaLite.TimeUnit"
            },
            {
                "name": "yearMonthDate",
                "comment": " Indicate temporal binning with a resolution of days so a ten year sequence\nwould have up to approximately 10\\*12\\*31 bins.\n",
                "type": "VegaLite.TimeUnit"
            },
            {
                "name": "yearMonthDateHours",
                "comment": " Indicate temporal binning with a resolution of hours so a ten year sequence\nwould have up to approximately 10\\*12\\*31\\*24 bins.\n",
                "type": "VegaLite.TimeUnit"
            },
            {
                "name": "yearMonthDateHoursMinutes",
                "comment": " Indicate temporal binning with a resolution of minutes so a ten year sequence\nwould have up to approximately 10\\*12\\*31\\*24\\*60 bins.\n",
                "type": "VegaLite.TimeUnit"
            },
            {
                "name": "yearMonthDateHoursMinutesSeconds",
                "comment": " Indicate temporal binning with a resolution of seconds so a ten year sequence\nwould have up to approximately 10\\*12\\*31\\*24\\*60\\*60 bins.\n",
                "type": "VegaLite.TimeUnit"
            },
            {
                "name": "yearQuarter",
                "comment": " Indicate temporal binning with a resolution of quarters so a ten year sequence\nwould have up to 10\\*4 bins.\n",
                "type": "VegaLite.TimeUnit"
            },
            {
                "name": "yearQuarterMonth",
                "comment": " Indicate temporal binning with a resolution of months so a ten year sequence\nwould have up to 10\\*12 bins. Unlike [yearMonth](#yearMonth), this will also label\nbins with quarters.\n",
                "type": "VegaLite.TimeUnit"
            },
            {
                "name": "yearWeek",
                "comment": " Indicate temporal binning with a resolution of weeks so a ten year sequence\nwould have up to 10\\*52 bins.\n",
                "type": "VegaLite.TimeUnit"
            },
            {
                "name": "yearWeekDay",
                "comment": " Indicate temporal binning with a resolution of day of week so a ten year\nsequence would have up to 10\\*52\\*7 bins.\n",
                "type": "VegaLite.TimeUnit"
            },
            {
                "name": "yearWeekDayHours",
                "comment": " Indicate temporal binning with a resolution of hours so a ten year sequence\nwould have up to 10\\*52\\*7\\*24 bins.\n",
                "type": "VegaLite.TimeUnit"
            },
            {
                "name": "yearWeekDayHoursMinutes",
                "comment": " Indicate temporal binning with a resolution of minutes so a ten year sequence\nwould have up to 10\\*52\\*7\\*24\\*60 bins.\n",
                "type": "VegaLite.TimeUnit"
            },
            {
                "name": "yearWeekDayHoursMinutesSeconds",
                "comment": " Indicate temporal binning with a resolution of seconds so a ten year sequence\nwould have up to 10\\*52\\*7\\*24\\*60\\*60 bins.\n",
                "type": "VegaLite.TimeUnit"
            }
        ],
        "binops": []
    }
]