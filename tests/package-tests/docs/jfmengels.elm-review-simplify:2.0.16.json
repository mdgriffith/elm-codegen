[
    {
        "name": "Simplify",
        "comment": " Reports when an expression can be simplified.\n\nðŸ”§ Running with `--fix` will automatically remove all the reported errors.\n\n    config =\n        [ Simplify.rule Simplify.defaults\n        ]\n\n@docs rule\n@docs Configuration, defaults, ignoreCaseOfForTypes\n\n\n## Try it out\n\nYou can try this rule out by running the following command:\n\n```bash\nelm-review --template jfmengels/elm-review-simplify/example --rules Simplify\n```\n\n\n## Simplifications\n\nBelow is the list of all kinds of simplifications this rule applies.\n\n\n### Booleans\n\n    x || True\n    --> True\n\n    x || False\n    --> x\n\n    x && True\n    --> x\n\n    x && False\n    --> False\n\n    not True\n    --> False\n\n    not (not x)\n    --> x\n\n    not >> not\n    --> identity\n\n\n### Comparisons\n\n    x == True\n    --> x\n\n    x /= False\n    --> x\n\n    not x == not y\n    --> x == y\n\n    anything == anything\n    --> True\n\n    anything /= anything\n    --> False\n\n    { r | a = 1 } == { r | a = 2 }\n    --> False\n\n\n### If expressions\n\n    if True then x else y\n    --> x\n\n    if False then x else y\n    --> y\n\n    if condition then x else x\n    --> x\n\n    if condition then True else False\n    --> condition\n\n    if condition then False else True\n    --> not condition\n\n\n### Case expressions\n\n    case condition of\n        True -> x\n        False -> y\n    --> if condition then x else y\n\n    case condition of\n        False -> y\n        True -> x\n    --> if not condition then x else y\n\n    case value of\n        A _ -> x\n        B -> x\n    --> x\n\n\n### Record updates\n\n    { a | b = a.b }\n    --> a\n\n    { a | b = a.b, c = 1 }\n    --> { a | c = 1 }\n\n\n### Basics functions\n\n    identity x\n    --> x\n\n    f >> identity\n    --> f\n\n    always x y\n    --> x\n\n    f >> always x\n    --> always x\n\n\n### Lambdas\n\n    (\\\\() -> x) data\n    --> x\n\n    (\\\\() y -> x) data\n    --> (\\y -> x)\n\n    (\\\\_ y -> x) data\n    --> (\\y -> x)\n\n\n### Operators\n\n    (++) a b\n    --> a ++ b\n\n\n### Numbers\n\n    n + 0\n    --> n\n\n    n - 0\n    --> n\n\n    0 - n\n    --> -n\n\n    n * 1\n    --> n\n\n    n * 0\n    --> 0\n\n    n / 1\n    --> n\n\n    -(-n)\n    --> n\n\n    negate >> negate\n    --> identity\n\n    negate (negate x)\n    --> x\n\n\n### Strings\n\n    \"a\" ++ \"\"\n    --> \"a\"\n\n    String.isEmpty \"\"\n    --> True\n\n    String.isEmpty \"a\"\n    --> False\n\n    String.concat []\n    --> \"\"\n\n    String.join str []\n    --> \"\"\n\n    String.join \"\" list\n    --> String.concat list\n\n    String.length \"abc\"\n    --> 3\n\n    String.repeat n \"\"\n    --> \"\"\n\n    String.repeat 0 str\n    --> \"\"\n\n    String.repeat 1 str\n    --> str\n\n    String.replace x y \"\"\n    --> \"\"\n\n    String.replace x x z\n    --> z\n\n    String.replace \"x\" \"y\" \"z\"\n    --> \"z\" -- only when resulting string is unchanged\n\n    String.words \"\"\n    --> []\n\n    String.lines \"\"\n    --> []\n\n    String.reverse \"\"\n    --> \"\"\n\n    String.reverse <| String.reverse x\n    --> x\n\n\n### Maybe\n\n    Maybe.map identity x\n    --> x\n\n    Maybe.map f Nothing\n    --> Nothing\n\n    Maybe.map f (Just x)\n    --> Just (f x)\n\n    MaybeThen f Nothing\n    --> Nothing\n\n    Maybe.andThen (always Nothing) x\n    --> Nothing\n\n    Maybe.andThen (\\a -> Just b) x\n    --> Maybe.map (\\a -> b) x\n\n    Maybe.andThen (\\a -> if condition a then Just b else Just c) x\n    --> Maybe.map (\\a -> if condition a then b else c) x\n\n    Maybe.andThen f (Just x)\n    --> f x\n\n    Maybe.withDefault x Nothing\n    --> x\n\n    Maybe.withDefault x (Just y)\n    --> y\n\n\n### Result\n\n    Result.map identity x\n    --> x.and\n\n    Result.map f (Err x)\n    --> Err x\n\n    Result.map f (Ok x)\n    --> Ok (f x)\n\n    Result.andThen f (Err x)\n    --> Err x\n\n    Result.andThen f (Ok x)\n    --> f x\n\n    Result.andThen (\\a -> Ok b) x\n    --> Result.map (\\a -> b) x\n\n    Result.withDefault x (Err y)\n    --> x\n\n    Result.withDefault x (Ok y)\n    --> y\n\n\n### Lists\n\n    a :: []\n    --> [ a ]\n\n    a :: [ b ]\n    --> [ a, b ]\n\n    [ a ] ++ list\n    --> a :: list\n\n    [] ++ list\n    --> list\n\n    [ a, b ] ++ [ c ]\n    --> [ a, b, c ]\n\n    [ a, b ] ++ [ c ]\n    --> [ a, b, c ]\n\n    List.map fn [] -- same for most List functions like List.filter, List.filterMap, ...\n    --> []\n\n    List.map identity list\n    --> list\n\n    List.map identity\n    --> identity\n\n    List.filter (always True) list\n    --> list\n\n    List.filter (\\a -> True) list\n    --> list\n\n    List.filter (always False) list\n    --> []\n\n    List.filter (always True)\n    --> identity\n\n    List.filter (always False)\n    --> always []\n\n    List.filterMap Just list\n    --> list\n\n    List.filterMap (\\a -> Just a) list\n    --> list\n\n    List.filterMap Just\n    --> identity\n\n    List.filterMap (\\a -> if condition a then Just b else Just c) list\n    --> List.map (\\a -> if condition a then b else c) list\n\n    List.filterMap (always Nothing) list\n    --> []\n\n    List.filterMap (always Nothing)\n    --> (always [])\n\n    List.filterMap identity (List.map f x)\n    --> List.filterMap f x\n\n    List.filterMap identity [ Just x, Just y ]\n    --> [ x, y ]\n\n\n    List.concat [ [ a, b ], [ c ] ]\n    --> [ a, b, c ]\n\n    List.concat [ a, [ 1 ], [ 2 ] ]\n    --> List.concat [ a, [ 1, 2 ] ]\n\n    List.concatMap identity x\n    --> List.concat list\n\n    List.concatMap identity\n    --> List.concat\n\n    List.concatMap (\\a -> a) list\n    --> List.concat list\n\n    List.concatMap (\\a -> [ b ]) list\n    --> List.map (\\a -> b) list\n\n    List.concatMap fn [ x ]\n    --> fn x\n\n    List.concatMap (always []) list\n    --> []\n\n    List.concat (List.map f x)\n    --> List.concatMap f x\n\n    List.indexedMap (\\_ value -> f value) list\n    --> List.map (\\value -> f value) list\n\n    List.isEmpty []\n    --> True\n\n    List.isEmpty [ a ]\n    --> False\n\n    List.isEmpty (x :: xs)\n    --> False\n\n    List.all fn []\n    --> True\n\n    List.all (always True) list\n    --> True\n\n    List.any fn []\n    --> True\n\n    List.any (always False) list\n    --> True\n\n    List.range 6 3\n    --> []\n\n    List.length [ a ]\n    --> 1\n\n    List.repeat 0 list\n    --> []\n\n    List.partition fn []\n    --> ( [], [] )\n\n    List.partition (always True) list\n    --> ( list, [] )\n\n\n    List.take 0 x\n    --> []\n\n\n    List.drop 0 x\n    --> x\n\n\n    List.reverse <| List.reverse x\n    --> x\n\n\n### Set\n\n    Set.map fn Set.empty -- same for Set.filter, Set.remove...\n    --> Set.empty\n\n    Set.map identity set\n    --> set\n\n    Set.map identity\n    --> identity\n\n    Set.isEmpty Set.empty\n    --> True\n\n    Set.member x Set.empty\n    --> False\n\n    Set.fromList []\n    --> Set.empty\n\n    Set.toList Set.empty\n    --> []\n\n    Set.length Set.empty\n    --> 0\n\n    Set.intersect Set.empty set\n    --> Set.empty\n\n    Set.diff Set.empty set\n    --> Set.empty\n\n    Set.diff set Set.empty\n    --> set\n\n    Set.union set Set.empty\n    --> set\n\n    Set.insert x Set.empty\n    --> Set.singleton x\n\n    Set.partition fn Set.empty\n    --> ( Set.empty, Set.empty )\n\n    Set.partition (always True) set\n    --> ( set, Set.empty )\n\n\n### Dict\n\n    Dict.isEmpty Dict.empty\n    --> True\n\n    Dict.fromList []\n    --> Dict.empty\n\n    Dict.toList Dict.empty\n    --> []\n\n    Dict.size Dict.empty\n    --> 0\n\n\n### Cmd / Sub\n\nAll of these also apply for `Sub`.\n\n    Cmd.batch []\n    --> Cmd.none\n\n    Cmd.batch [ a ]\n    --> a\n\n    Cmd.batch [ a, Cmd.none, b ]\n    --> Cmd.batch [ a, b ]\n\n    Cmd.map identity cmd\n    --> cmd\n\n    Cmd.map fn Cmd.none\n    --> Cmd.none\n\n\n### Json.Decode\n\n    Json.Decode.oneOf [a]\n    --> a\n\n\n### Parser\n\n    Parser.oneOf [a]\n    --> a\n\n",
        "unions": [
            {
                "name": "Configuration",
                "comment": " Configuration for this rule. Create a new one with [`defaults`](#defaults) and use [`ignoreCaseOfForTypes`](#ignoreCaseOfForTypes) to alter it.\n",
                "args": [],
                "cases": []
            }
        ],
        "aliases": [],
        "values": [
            {
                "name": "defaults",
                "comment": " Default configuration for this rule. Use [`ignoreCaseOfForTypes`](#ignoreCaseOfForTypes) if you want to change the configuration.\n\n    config =\n        [ Simplify.defaults\n            |> Simplify.ignoreCaseOfForTypes [ \"Module.Name.Type\" ]\n            |> Simplify.rule\n        ]\n\n",
                "type": "Simplify.Configuration"
            },
            {
                "name": "ignoreCaseOfForTypes",
                "comment": " Ignore some reports about types used in case expressions.\n\nThis rule simplifies the following construct:\n\n    module Module.Name exposing (..)\n\n    type Type = A | B\n\n    case value of\n        A -> x\n        B -> x\n    --> x\n\nIn some cases, you may want to disable this simplification because you expect to change or add constructors to this custom type.\nKeeping the case expression as it is will make the compiler remind you to update this code when you add new variants, which can be valuable.\n\nUsing the following configuration, case of expressions â€” where all variants of the `Type` custom type\nfrom the `Module.Name` module appear â€” will not be simplified.\n\n    config =\n        [ Simplify.defaults\n            |> Simplify.ignoreCaseOfForTypes [ \"Module.Name.Type\" ]\n            |> Simplify.rule\n        ]\n\nNote that if you use a wildcard, you will still get the simplification, since in this case the compiler will\nnot remind you anyway.\n\n    case value of\n        A -> x\n        _ -> x\n    --> x\n\nI personally don't recommend to use this function too much, because this could be a sign of premature abstraction, and because\nI think that often [You Aren't Gonna Need this code](https://jfmengels.net/safe-dead-code-removal/#yagni-you-arent-gonna-need-it).\n\nOnly use it for custom types that you think will change soon. When using it, I recommend not keeping it there too long.\nCome back after a while to see if this exception is still worth having. Maybe add a comment with the date and an\nexplanation next to each exception?\n\n",
                "type": "List.List String.String -> Simplify.Configuration -> Simplify.Configuration"
            },
            {
                "name": "rule",
                "comment": " Rule to simplify Elm code.\n",
                "type": "Simplify.Configuration -> Review.Rule.Rule"
            }
        ],
        "binops": []
    }
]