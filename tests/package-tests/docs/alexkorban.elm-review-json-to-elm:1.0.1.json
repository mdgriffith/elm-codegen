[
    {
        "name": "JsonToElm",
        "comment": "\n\n@docs rule\n\n",
        "unions": [],
        "aliases": [],
        "values": [
            {
                "name": "rule",
                "comment": " Generates Elm code from a JSON sample in JsonString\n\n    config =\n        [ JsonToElm.rule\n        ]\n\n\n## Before fix\n\nThe fix runs on top-level values with a JsonString type annotation. It generates\nJSON decoders and encoders as well as the necessary types and type aliases.\n\n    import Json.Decode\n    import Json.Encode\n\n    sample : JsonString\n    sample =\n        \"\"\"@json{\"a\": 1}\"\"\"\n\n\n## After fix\n\n    import Json.Decode\n    import Json.Encode\n\n    type alias Sample =\n        { a : Int\n        }\n\n    sampleDecoder : Json.Decode.Decoder Sample\n    sampleDecoder =\n        Json.Decode.map Sample\n            (Json.Decode.field \"a\" Json.Decode.int)\n\n    encodedSample : Sample -> Json.Encode.Value\n    encodedSample sample =\n        Json.Encode.object\n            [ ( \"a\", Json.Encode.int sample.a )\n            ]\n\nNote that the imports in the module are examined to determine the style of decoders.\n\nIf a `Json.Decode.Extra` import is present, then applicative-style decoders\nusing `Json.Decode.Extra.andMap` will be generated.\n\nIf a `Json.Decode.Pipeline` import is present, then pipeline decoders are\ngenerated.\n\n\n## Try it out\n\nYou can try this rule out by running the following command:\n\n```bash\nelm-review --template alexkorban/elm-review-json-to-elm/example --rules JsonToElm\n```\n\n",
                "type": "Review.Rule.Rule"
            }
        ],
        "binops": []
    }
]