[
    {
        "name": "Elm.Dependency",
        "comment": " This module contains types regarding dependencies of a codebase.\nTo gain the most information of a codebase, information of the dependencies may be required.\nFor example, what operators does it define, or what constructors are defined for a custom type.\n\n\n## Types\n\n@docs Dependency, Version\n\n",
        "unions": [],
        "aliases": [
            {
                "name": "Dependency",
                "comment": " Record that represents a dependency. For example:\n\n    { name = \"elm/core\"\n    , version = \"1.0.0\"\n    , interfaces = Dict.fromList [ ( \"Basics\", basicsInterface ), ... ]\n    }\n\n",
                "args": [],
                "type": "{ name : String.String, version : Elm.Dependency.Version, interfaces : Dict.Dict Elm.Syntax.ModuleName.ModuleName Elm.Interface.Interface }"
            },
            {
                "name": "Version",
                "comment": " Alias for a version string. For example \"1.2.3\".\n",
                "args": [],
                "type": "String.String"
            }
        ],
        "values": [],
        "binops": []
    },
    {
        "name": "Elm.Interface",
        "comment": " A type that represents the interface for an Elm module.\nYou can see this as a trimmed down version of a file that only contains the header (`module X exposing (..)`) and some small set of additional data.\n\n\n## Types\n\n@docs Interface, Exposed\n\n\n## Functions\n\n@docs build, exposesAlias, exposesFunction, operators\n\n",
        "unions": [
            {
                "name": "Exposed",
                "comment": " Union type for the things that a module can expose. These are `Function`s, `CustomType`s, and `Alias`es.\n\nElm core packages can also define `Operator`s, and thus we take that into account as well.\nThe `Infix` type alias will contain all the information regarding the operator\n\n",
                "args": [],
                "cases": [
                    [
                        "Function",
                        [
                            "String.String"
                        ]
                    ],
                    [
                        "CustomType",
                        [
                            "( String.String, List.List String.String )"
                        ]
                    ],
                    [
                        "Alias",
                        [
                            "String.String"
                        ]
                    ],
                    [
                        "Operator",
                        [
                            "Elm.Syntax.Infix.Infix"
                        ]
                    ]
                ]
            }
        ],
        "aliases": [
            {
                "name": "Interface",
                "comment": " An interface is just a list of 'things' that are exposed by a module.\n\n    [ Type \"Color\" [ \"Red\", \"Blue\" ], Function \"asRgb\" ]\n\n",
                "args": [],
                "type": "List.List Elm.Interface.Exposed"
            }
        ],
        "values": [
            {
                "name": "build",
                "comment": " Build an interface from a file\n",
                "type": "Elm.Internal.RawFile.RawFile -> Elm.Interface.Interface"
            },
            {
                "name": "exposesAlias",
                "comment": " A function to check whether an `Interface` exposes an certain type alias.\n",
                "type": "String.String -> Elm.Interface.Interface -> Basics.Bool"
            },
            {
                "name": "exposesFunction",
                "comment": " Check whether an `Interface` exposes an function.\n\n    exposesFunction \"A\" [ Function \"A\", CustomType \"B\", [ \"C\" ] ] == True\n    exposesFunction \"B\" [ Function \"A\", CustomType \"B\", [ \"C\" ] ] == False\n    exposesFunction \"<\" [ Infix { operator = \"<\" , ... } ] == True\n    exposesFunction \"A\" [ Alias \"A\" ] == False\n\n",
                "type": "String.String -> Elm.Interface.Interface -> Basics.Bool"
            },
            {
                "name": "operators",
                "comment": " Retrieve all operators exposed by the `Interface`\n",
                "type": "Elm.Interface.Interface -> List.List Elm.Syntax.Infix.Infix"
            }
        ],
        "binops": []
    },
    {
        "name": "Elm.Parser",
        "comment": "\n\n@docs parse\n\n",
        "unions": [],
        "aliases": [],
        "values": [
            {
                "name": "parse",
                "comment": " Parse some text as if it is an Elm source file.\nWhen parsing fails, the result will contain a list of errors indicating what went wrong (and/or where).\nIf it succeeds, you will get a `RawFile`.\nThis `RawFile` will require some post-processing to properly setup documentation and ensure that operator precedence is applied correctly (based on dependencies).\nTo process a `RawFile`, check out the `Processing` module.\n",
                "type": "String.String -> Result.Result (List.List Parser.DeadEnd) Elm.Internal.RawFile.RawFile"
            }
        ],
        "binops": []
    },
    {
        "name": "Elm.Processing",
        "comment": " Processing raw files with the context of other files and dependencies.\n\n\n## Types\n\n@docs ProcessContext\n\n\n## Functions\n\n@docs init, addFile, addDependency, process\n\n",
        "unions": [
            {
                "name": "ProcessContext",
                "comment": " Opaque type to hold context for the processing\n",
                "args": [],
                "cases": []
            }
        ],
        "aliases": [],
        "values": [
            {
                "name": "addDependency",
                "comment": " Add a whole dependency with its modules to the context.\n",
                "type": "Elm.Dependency.Dependency -> Elm.Processing.ProcessContext -> Elm.Processing.ProcessContext"
            },
            {
                "name": "addFile",
                "comment": " Add a file to the context that may be a dependency for the file that will be processed.\n",
                "type": "Elm.Internal.RawFile.RawFile -> Elm.Processing.ProcessContext -> Elm.Processing.ProcessContext"
            },
            {
                "name": "init",
                "comment": " Initialise an empty context\n",
                "type": "Elm.Processing.ProcessContext"
            },
            {
                "name": "process",
                "comment": " Process a rawfile with a context.\nOperator precedence and documentation will be fixed.\n",
                "type": "Elm.Processing.ProcessContext -> Elm.Internal.RawFile.RawFile -> Elm.Syntax.File.File"
            }
        ],
        "binops": []
    },
    {
        "name": "Elm.RawFile",
        "comment": "\n\n@docs RawFile\n\n@docs moduleName, imports\n\n\n## Serialization\n\n@docs encode, decoder\n\n",
        "unions": [],
        "aliases": [
            {
                "name": "RawFile",
                "comment": " A Raw file\n",
                "args": [],
                "type": "Elm.Internal.RawFile.RawFile"
            }
        ],
        "values": [
            {
                "name": "decoder",
                "comment": " JSON decoder for a `RawFile` syntax element.\n",
                "type": "Json.Decode.Decoder Elm.RawFile.RawFile"
            },
            {
                "name": "encode",
                "comment": " Encode a file to a value\n",
                "type": "Elm.RawFile.RawFile -> Json.Encode.Value"
            },
            {
                "name": "imports",
                "comment": " Encode a `RawFile` syntax element to JSON.\n",
                "type": "Elm.RawFile.RawFile -> List.List Elm.Syntax.Import.Import"
            },
            {
                "name": "moduleName",
                "comment": " Retrieve the module name for a raw file\n",
                "type": "Elm.RawFile.RawFile -> Elm.Syntax.ModuleName.ModuleName"
            }
        ],
        "binops": []
    },
    {
        "name": "Elm.Syntax.Comments",
        "comment": " This syntax represents both single and multi line comments in Elm. For example:\n\n    -- A comment\n\n\n\n\n    {- Some\n       multi\n       line\n       comment\n    -}\n\n\n## Types\n\n@docs Comment\n\n\n## Serialization\n\n@docs encode, decoder\n\n",
        "unions": [],
        "aliases": [
            {
                "name": "Comment",
                "comment": " Type representing the comment syntax\n",
                "args": [],
                "type": "String.String"
            }
        ],
        "values": [
            {
                "name": "decoder",
                "comment": " JSON decoder for a `Comment` syntax element.\n",
                "type": "Json.Decode.Decoder Elm.Syntax.Comments.Comment"
            },
            {
                "name": "encode",
                "comment": " Encode a `Comment` syntax element to JSON.\n",
                "type": "Elm.Syntax.Comments.Comment -> Json.Encode.Value"
            }
        ],
        "binops": []
    },
    {
        "name": "Elm.Syntax.Declaration",
        "comment": " Syntax for the different top-level declarations in Elm.\nThese can be one of the following (all declared in `Declaration`):\n\n  - Functions: `add x y = x + y`\n  - Custom types: `type Color = Blue | Red`\n  - Type aliases: `type alias Status = Int`\n  - Port declaration: `port sendMessage: String -> Cmd msg`\n  - Destructuring: `{name, age} = person`\n  - Infix declarations. You will probably not need this, while only core packages can define these.\n\n\n## Types\n\n@docs Declaration\n\n\n## Serialization\n\n@docs encode, decoder\n\n",
        "unions": [
            {
                "name": "Declaration",
                "comment": " Custom type that represents all different top-level declarations.\n",
                "args": [],
                "cases": [
                    [
                        "FunctionDeclaration",
                        [
                            "Elm.Syntax.Expression.Function"
                        ]
                    ],
                    [
                        "AliasDeclaration",
                        [
                            "Elm.Syntax.TypeAlias.TypeAlias"
                        ]
                    ],
                    [
                        "CustomTypeDeclaration",
                        [
                            "Elm.Syntax.Type.Type"
                        ]
                    ],
                    [
                        "PortDeclaration",
                        [
                            "Elm.Syntax.Signature.Signature"
                        ]
                    ],
                    [
                        "InfixDeclaration",
                        [
                            "Elm.Syntax.Infix.Infix"
                        ]
                    ],
                    [
                        "Destructuring",
                        [
                            "Elm.Syntax.Node.Node Elm.Syntax.Pattern.Pattern",
                            "Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression"
                        ]
                    ]
                ]
            }
        ],
        "aliases": [],
        "values": [
            {
                "name": "decoder",
                "comment": " JSON decoder for a `Declaration` syntax element.\n",
                "type": "Json.Decode.Decoder Elm.Syntax.Declaration.Declaration"
            },
            {
                "name": "encode",
                "comment": " Encode a `Declaration` syntax element to JSON.\n",
                "type": "Elm.Syntax.Declaration.Declaration -> Json.Encode.Value"
            }
        ],
        "binops": []
    },
    {
        "name": "Elm.Syntax.Documentation",
        "comment": " This syntax represents documentation comments in Elm.\n\n\n## Types\n\n@docs Documentation\n\n\n## Serialization\n\n@docs encode, decoder\n\n",
        "unions": [],
        "aliases": [
            {
                "name": "Documentation",
                "comment": " Type representing the documentation syntax\n",
                "args": [],
                "type": "String.String"
            }
        ],
        "values": [
            {
                "name": "decoder",
                "comment": " JSON decoder for a `Documentation` syntax element.\n",
                "type": "Json.Decode.Decoder Elm.Syntax.Documentation.Documentation"
            },
            {
                "name": "encode",
                "comment": " Encode a `Documentation` syntax element to JSON.\n",
                "type": "Elm.Syntax.Documentation.Documentation -> Json.Encode.Value"
            }
        ],
        "binops": []
    },
    {
        "name": "Elm.Syntax.Exposing",
        "comment": " This syntax represents the exposing declaration for both imports and module headers.\nFor example:\n\n    exposing (Foo(..))\n    exposing (..)\n\n\n## Types\n\n@docs Exposing, TopLevelExpose, ExposedType\n\n\n## Functions\n\n@docs exposesFunction, operators\n\n\n## Serialization\n\n@docs encode, decoder\n\n",
        "unions": [
            {
                "name": "Exposing",
                "comment": " Diffent kind of exposing declarations\n",
                "args": [],
                "cases": [
                    [
                        "All",
                        [
                            "Elm.Syntax.Range.Range"
                        ]
                    ],
                    [
                        "Explicit",
                        [
                            "List.List (Elm.Syntax.Node.Node Elm.Syntax.Exposing.TopLevelExpose)"
                        ]
                    ]
                ]
            },
            {
                "name": "TopLevelExpose",
                "comment": " An exposed entity\n",
                "args": [],
                "cases": [
                    [
                        "InfixExpose",
                        [
                            "String.String"
                        ]
                    ],
                    [
                        "FunctionExpose",
                        [
                            "String.String"
                        ]
                    ],
                    [
                        "TypeOrAliasExpose",
                        [
                            "String.String"
                        ]
                    ],
                    [
                        "TypeExpose",
                        [
                            "Elm.Syntax.Exposing.ExposedType"
                        ]
                    ]
                ]
            }
        ],
        "aliases": [
            {
                "name": "ExposedType",
                "comment": " Exposed Type\n",
                "args": [],
                "type": "{ name : String.String, open : Maybe.Maybe Elm.Syntax.Range.Range }"
            }
        ],
        "values": [
            {
                "name": "decoder",
                "comment": " JSON decoder for an `Exposing` syntax element.\n",
                "type": "Json.Decode.Decoder Elm.Syntax.Exposing.Exposing"
            },
            {
                "name": "encode",
                "comment": " Encode an `Exposing` syntax element to JSON.\n",
                "type": "Elm.Syntax.Exposing.Exposing -> Json.Encode.Value"
            },
            {
                "name": "exposesFunction",
                "comment": " Check whether an import/module exposing list exposes a certain function. Will yield `True` if `Exposing` is exposing everything (`All`).\n\n    exposesFunction \"something\" (All someRange) == True\n\n    exposesFunction \"divide\" (Explicit [ Node someRange (FunctionExpose \"add\") ]) == False\n\n    exposesFunction \"add\" (Explicit [ Node someRange (FunctionExpose \"add\") ]) == True\n\n",
                "type": "String.String -> Elm.Syntax.Exposing.Exposing -> Basics.Bool"
            },
            {
                "name": "operators",
                "comment": " Collect all operator names from a list of TopLevelExposes\n",
                "type": "List.List Elm.Syntax.Exposing.TopLevelExpose -> List.List String.String"
            }
        ],
        "binops": []
    },
    {
        "name": "Elm.Syntax.Expression",
        "comment": " This syntax represents all that you can express in Elm.\nAlthough it is a easy and simple language, you can express a lot! See the `Expression` type for all the things you can express.\n\n\n## Types\n\n@docs Expression, Lambda, LetBlock, LetDeclaration, RecordSetter, CaseBlock, Cases, Case, Function, FunctionImplementation\n\n\n## Functions\n\n@docs functionRange, isLambda, isLet, isIfElse, isCase, isOperatorApplication\n\n\n## Serialization\n\n@docs encode, encodeFunction, decoder, functionDecoder\n\n",
        "unions": [
            {
                "name": "Expression",
                "comment": " Custom type for all expressions such as:\n\n  - `Unit`: `()`\n  - `Application`: `add a b`\n  - `OperatorApplication`: `a + b`\n  - `FunctionOrValue`: `add` or `True`\n  - `IfBlock`: `if a then b else c`\n  - `PrefixOperator`: `(+)`\n  - `Operator`: `+` (not possible to get in practice)\n  - `Integer`: `42`\n  - `Hex`: `0x1F`\n  - `Floatable`: `42.0`\n  - `Negation`: `-a`\n  - `Literal`: `\"text\"`\n  - `CharLiteral`: `'a'`\n  - `TupledExpression`: `(a, b)` or `(a, b, c)`\n  - `ParenthesizedExpression`: `(a)`\n  - `LetExpression`: `let a = 4 in a`\n  - `CaseExpression`: `case a of` followed by pattern matches\n  - `LambdaExpression`: `(\\a -> a)`\n  - `RecordExpr`: `{ name = \"text\" }`\n  - `ListExpr`: `[ x, y ]`\n  - `RecordAccess`: `a.name`\n  - `RecordAccessFunction`: `.name`\n  - `RecordUpdateExpression`: `{ a | name = \"text\" }`\n  - `GLSLExpression`: `[glsl| ... |]`\n\n",
                "args": [],
                "cases": [
                    [
                        "UnitExpr",
                        []
                    ],
                    [
                        "Application",
                        [
                            "List.List (Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression)"
                        ]
                    ],
                    [
                        "OperatorApplication",
                        [
                            "String.String",
                            "Elm.Syntax.Infix.InfixDirection",
                            "Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression",
                            "Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression"
                        ]
                    ],
                    [
                        "FunctionOrValue",
                        [
                            "Elm.Syntax.ModuleName.ModuleName",
                            "String.String"
                        ]
                    ],
                    [
                        "IfBlock",
                        [
                            "Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression",
                            "Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression",
                            "Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression"
                        ]
                    ],
                    [
                        "PrefixOperator",
                        [
                            "String.String"
                        ]
                    ],
                    [
                        "Operator",
                        [
                            "String.String"
                        ]
                    ],
                    [
                        "Integer",
                        [
                            "Basics.Int"
                        ]
                    ],
                    [
                        "Hex",
                        [
                            "Basics.Int"
                        ]
                    ],
                    [
                        "Floatable",
                        [
                            "Basics.Float"
                        ]
                    ],
                    [
                        "Negation",
                        [
                            "Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression"
                        ]
                    ],
                    [
                        "Literal",
                        [
                            "String.String"
                        ]
                    ],
                    [
                        "CharLiteral",
                        [
                            "Char.Char"
                        ]
                    ],
                    [
                        "TupledExpression",
                        [
                            "List.List (Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression)"
                        ]
                    ],
                    [
                        "ParenthesizedExpression",
                        [
                            "Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression"
                        ]
                    ],
                    [
                        "LetExpression",
                        [
                            "Elm.Syntax.Expression.LetBlock"
                        ]
                    ],
                    [
                        "CaseExpression",
                        [
                            "Elm.Syntax.Expression.CaseBlock"
                        ]
                    ],
                    [
                        "LambdaExpression",
                        [
                            "Elm.Syntax.Expression.Lambda"
                        ]
                    ],
                    [
                        "RecordExpr",
                        [
                            "List.List (Elm.Syntax.Node.Node Elm.Syntax.Expression.RecordSetter)"
                        ]
                    ],
                    [
                        "ListExpr",
                        [
                            "List.List (Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression)"
                        ]
                    ],
                    [
                        "RecordAccess",
                        [
                            "Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression",
                            "Elm.Syntax.Node.Node String.String"
                        ]
                    ],
                    [
                        "RecordAccessFunction",
                        [
                            "String.String"
                        ]
                    ],
                    [
                        "RecordUpdateExpression",
                        [
                            "Elm.Syntax.Node.Node String.String",
                            "List.List (Elm.Syntax.Node.Node Elm.Syntax.Expression.RecordSetter)"
                        ]
                    ],
                    [
                        "GLSLExpression",
                        [
                            "String.String"
                        ]
                    ]
                ]
            },
            {
                "name": "LetDeclaration",
                "comment": " Union type for all possible declarations in a let block\n",
                "args": [],
                "cases": [
                    [
                        "LetFunction",
                        [
                            "Elm.Syntax.Expression.Function"
                        ]
                    ],
                    [
                        "LetDestructuring",
                        [
                            "Elm.Syntax.Node.Node Elm.Syntax.Pattern.Pattern",
                            "Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression"
                        ]
                    ]
                ]
            }
        ],
        "aliases": [
            {
                "name": "Case",
                "comment": " A case in a case block\n",
                "args": [],
                "type": "( Elm.Syntax.Node.Node Elm.Syntax.Pattern.Pattern, Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression )"
            },
            {
                "name": "CaseBlock",
                "comment": " Expression for a case block\n",
                "args": [],
                "type": "{ expression : Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression, cases : Elm.Syntax.Expression.Cases }"
            },
            {
                "name": "Cases",
                "comment": " Type alias for a list of cases\n",
                "args": [],
                "type": "List.List Elm.Syntax.Expression.Case"
            },
            {
                "name": "Function",
                "comment": " Type alias for a full function\n",
                "args": [],
                "type": "{ documentation : Maybe.Maybe (Elm.Syntax.Node.Node Elm.Syntax.Documentation.Documentation), signature : Maybe.Maybe (Elm.Syntax.Node.Node Elm.Syntax.Signature.Signature), declaration : Elm.Syntax.Node.Node Elm.Syntax.Expression.FunctionImplementation }"
            },
            {
                "name": "FunctionImplementation",
                "comment": " Type alias for a function's implementation\n",
                "args": [],
                "type": "{ name : Elm.Syntax.Node.Node String.String, arguments : List.List (Elm.Syntax.Node.Node Elm.Syntax.Pattern.Pattern), expression : Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression }"
            },
            {
                "name": "Lambda",
                "comment": " Expression for a lambda\n",
                "args": [],
                "type": "{ args : List.List (Elm.Syntax.Node.Node Elm.Syntax.Pattern.Pattern), expression : Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression }"
            },
            {
                "name": "LetBlock",
                "comment": " Expression for a let block\n",
                "args": [],
                "type": "{ declarations : List.List (Elm.Syntax.Node.Node Elm.Syntax.Expression.LetDeclaration), expression : Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression }"
            },
            {
                "name": "RecordSetter",
                "comment": " Expression for setting a record field\n",
                "args": [],
                "type": "( Elm.Syntax.Node.Node String.String, Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression )"
            }
        ],
        "values": [
            {
                "name": "decoder",
                "comment": " JSON decoder for an `Expression` syntax element.\n",
                "type": "Json.Decode.Decoder Elm.Syntax.Expression.Expression"
            },
            {
                "name": "encode",
                "comment": " Encode an `Expression` syntax element to JSON.\n",
                "type": "Elm.Syntax.Expression.Expression -> Json.Encode.Value"
            },
            {
                "name": "encodeFunction",
                "comment": " Encode a `Function` syntax element to JSON.\n",
                "type": "Elm.Syntax.Expression.Function -> Json.Encode.Value"
            },
            {
                "name": "functionDecoder",
                "comment": " JSON decoder for an `Function` syntax element.\n",
                "type": "Json.Decode.Decoder Elm.Syntax.Expression.Function"
            },
            {
                "name": "functionRange",
                "comment": " Get the full range of a function\n",
                "type": "Elm.Syntax.Expression.Function -> Elm.Syntax.Range.Range"
            },
            {
                "name": "isCase",
                "comment": " Check whether an expression is a case-expression\n",
                "type": "Elm.Syntax.Expression.Expression -> Basics.Bool"
            },
            {
                "name": "isIfElse",
                "comment": " Check whether an expression is an if-else-expression\n",
                "type": "Elm.Syntax.Expression.Expression -> Basics.Bool"
            },
            {
                "name": "isLambda",
                "comment": " Check whether an expression is a lambda-expression\n",
                "type": "Elm.Syntax.Expression.Expression -> Basics.Bool"
            },
            {
                "name": "isLet",
                "comment": " Check whether an expression is a let-expression\n",
                "type": "Elm.Syntax.Expression.Expression -> Basics.Bool"
            },
            {
                "name": "isOperatorApplication",
                "comment": " Check whether an expression is an operator appliation expression\n",
                "type": "Elm.Syntax.Expression.Expression -> Basics.Bool"
            }
        ],
        "binops": []
    },
    {
        "name": "Elm.Syntax.File",
        "comment": " This syntax represents a whole Elm file.\n\n\n## Types\n\n@docs File\n\n\n## Serialization\n\n@docs encode, decoder\n\n",
        "unions": [],
        "aliases": [
            {
                "name": "File",
                "comment": " Type annotation for a file\n",
                "args": [],
                "type": "{ moduleDefinition : Elm.Syntax.Node.Node Elm.Syntax.Module.Module, imports : List.List (Elm.Syntax.Node.Node Elm.Syntax.Import.Import), declarations : List.List (Elm.Syntax.Node.Node Elm.Syntax.Declaration.Declaration), comments : List.List (Elm.Syntax.Node.Node Elm.Syntax.Comments.Comment) }"
            }
        ],
        "values": [
            {
                "name": "decoder",
                "comment": " JSON decoder for a `File` syntax element.\n",
                "type": "Json.Decode.Decoder Elm.Syntax.File.File"
            },
            {
                "name": "encode",
                "comment": " Encode a `File` syntax element to JSON.\n",
                "type": "Elm.Syntax.File.File -> Json.Encode.Value"
            }
        ],
        "binops": []
    },
    {
        "name": "Elm.Syntax.Import",
        "comment": " This syntax represents imports in Elm.\nFor example:\n\n    import Html.Attributes as HA exposing (style)\n\n\n## Types\n\n@docs Import\n\n\n## Serialization\n\n@docs encode, decoder\n\n",
        "unions": [],
        "aliases": [
            {
                "name": "Import",
                "comment": " Type alias representing an Import\n",
                "args": [],
                "type": "{ moduleName : Elm.Syntax.Node.Node Elm.Syntax.ModuleName.ModuleName, moduleAlias : Maybe.Maybe (Elm.Syntax.Node.Node Elm.Syntax.ModuleName.ModuleName), exposingList : Maybe.Maybe (Elm.Syntax.Node.Node Elm.Syntax.Exposing.Exposing) }"
            }
        ],
        "values": [
            {
                "name": "decoder",
                "comment": " JSON decoder for a `Import` syntax element.\n",
                "type": "Json.Decode.Decoder Elm.Syntax.Import.Import"
            },
            {
                "name": "encode",
                "comment": " Encode a `Import` syntax element to JSON.\n",
                "type": "Elm.Syntax.Import.Import -> Json.Encode.Value"
            }
        ],
        "binops": []
    },
    {
        "name": "Elm.Syntax.Infix",
        "comment": "\n\n\n## Types\n\n@docs Infix, InfixDirection\n\n\n## Serialization\n\n@docs encode, encodeDirection, decoder, decodeDirection\n\n",
        "unions": [
            {
                "name": "InfixDirection",
                "comment": " Union type for infix direction\n",
                "args": [],
                "cases": [
                    [
                        "Left",
                        []
                    ],
                    [
                        "Right",
                        []
                    ],
                    [
                        "Non",
                        []
                    ]
                ]
            }
        ],
        "aliases": [
            {
                "name": "Infix",
                "comment": " Type annotation for a infix definition\n",
                "args": [],
                "type": "{ direction : Elm.Syntax.Node.Node Elm.Syntax.Infix.InfixDirection, precedence : Elm.Syntax.Node.Node Basics.Int, operator : Elm.Syntax.Node.Node String.String, function : Elm.Syntax.Node.Node String.String }"
            }
        ],
        "values": [
            {
                "name": "decodeDirection",
                "comment": " Decode a infix direction\n",
                "type": "Json.Decode.Decoder Elm.Syntax.Infix.InfixDirection"
            },
            {
                "name": "decoder",
                "comment": " Decode an infix\n",
                "type": "Json.Decode.Decoder Elm.Syntax.Infix.Infix"
            },
            {
                "name": "encode",
                "comment": " Encode an infix\n",
                "type": "Elm.Syntax.Infix.Infix -> Json.Encode.Value"
            },
            {
                "name": "encodeDirection",
                "comment": " Encode the infix direction\n",
                "type": "Elm.Syntax.Infix.InfixDirection -> Json.Encode.Value"
            }
        ],
        "binops": []
    },
    {
        "name": "Elm.Syntax.Module",
        "comment": " This syntax represents module definitions in Elm.\nFor example:\n\n    module Html.Attributes exposing (style)\n\n\n## Module\n\n@docs Module, DefaultModuleData, EffectModuleData\n\n@docs exposingList, moduleName, isPortModule, isEffectModule\n\n\n## Serialization\n\n@docs encode, decoder\n\n",
        "unions": [
            {
                "name": "Module",
                "comment": " Union type for different kind of modules\n",
                "args": [],
                "cases": [
                    [
                        "NormalModule",
                        [
                            "Elm.Syntax.Module.DefaultModuleData"
                        ]
                    ],
                    [
                        "PortModule",
                        [
                            "Elm.Syntax.Module.DefaultModuleData"
                        ]
                    ],
                    [
                        "EffectModule",
                        [
                            "Elm.Syntax.Module.EffectModuleData"
                        ]
                    ]
                ]
            }
        ],
        "aliases": [
            {
                "name": "DefaultModuleData",
                "comment": " Data for a default default\n",
                "args": [],
                "type": "{ moduleName : Elm.Syntax.Node.Node Elm.Syntax.ModuleName.ModuleName, exposingList : Elm.Syntax.Node.Node Elm.Syntax.Exposing.Exposing }"
            },
            {
                "name": "EffectModuleData",
                "comment": " Data for an effect module\n",
                "args": [],
                "type": "{ moduleName : Elm.Syntax.Node.Node Elm.Syntax.ModuleName.ModuleName, exposingList : Elm.Syntax.Node.Node Elm.Syntax.Exposing.Exposing, command : Maybe.Maybe (Elm.Syntax.Node.Node String.String), subscription : Maybe.Maybe (Elm.Syntax.Node.Node String.String) }"
            }
        ],
        "values": [
            {
                "name": "decoder",
                "comment": " JSON decoder for a `Module` syntax element.\n",
                "type": "Json.Decode.Decoder Elm.Syntax.Module.Module"
            },
            {
                "name": "encode",
                "comment": " Encode a `Module` syntax element to JSON.\n",
                "type": "Elm.Syntax.Module.Module -> Json.Encode.Value"
            },
            {
                "name": "exposingList",
                "comment": " Get the exposing list for a module.\n",
                "type": "Elm.Syntax.Module.Module -> Elm.Syntax.Exposing.Exposing"
            },
            {
                "name": "isEffectModule",
                "comment": " Check whether a module is defined as an effect-module\n",
                "type": "Elm.Syntax.Module.Module -> Basics.Bool"
            },
            {
                "name": "isPortModule",
                "comment": " Check whether a module is defined as a port-module\n",
                "type": "Elm.Syntax.Module.Module -> Basics.Bool"
            },
            {
                "name": "moduleName",
                "comment": " Get the name for a module. For older modules this may not be present.\n",
                "type": "Elm.Syntax.Module.Module -> Elm.Syntax.ModuleName.ModuleName"
            }
        ],
        "binops": []
    },
    {
        "name": "Elm.Syntax.ModuleName",
        "comment": " This syntax represents the module names in Elm. These can be used for imports, module names (duh), and for qualified access.\nFor example:\n\n    module Elm.Syntax.ModuleName ...\n\n    import Foo.Bar ...\n\n    import ... as Something\n\n    My.Module.something\n\n    My.Module.SomeType\n\n\n## Types\n\n@docs ModuleName\n\n\n## Serialization\n\n@docs encode, decoder\n\n",
        "unions": [],
        "aliases": [
            {
                "name": "ModuleName",
                "comment": " Base representation for a module name\n",
                "args": [],
                "type": "List.List String.String"
            }
        ],
        "values": [
            {
                "name": "decoder",
                "comment": " JSON decoder for a `ModuleName` syntax element.\n",
                "type": "Json.Decode.Decoder Elm.Syntax.ModuleName.ModuleName"
            },
            {
                "name": "encode",
                "comment": " Encode a `ModuleName` syntax element to JSON.\n",
                "type": "Elm.Syntax.ModuleName.ModuleName -> Json.Encode.Value"
            }
        ],
        "binops": []
    },
    {
        "name": "Elm.Syntax.Node",
        "comment": " Represents a `Node` of the AST (Abstract Syntax Tree).\n\nThe purpose of this type is to add the information of the [`Range`](./Elm-Syntax-Range), i.e. where in the source code the\nelement of the tree was found.\n\n\n## Types\n\n@docs Node\n\n\n## Functions\n\n@docs combine, range, value, map\n\n\n## Serialization\n\n@docs encode, decoder\n\n",
        "unions": [
            {
                "name": "Node",
                "comment": " Base representation for a syntax node in a source file.\n",
                "args": [
                    "a"
                ],
                "cases": [
                    [
                        "Node",
                        [
                            "Elm.Syntax.Range.Range",
                            "a"
                        ]
                    ]
                ]
            }
        ],
        "aliases": [],
        "values": [
            {
                "name": "combine",
                "comment": " Combine two nodes, constructing a new node which will have the outer most range of the child nodes\n",
                "type": "(Elm.Syntax.Node.Node a -> Elm.Syntax.Node.Node b -> c) -> Elm.Syntax.Node.Node a -> Elm.Syntax.Node.Node b -> Elm.Syntax.Node.Node c"
            },
            {
                "name": "decoder",
                "comment": " A JSON decoder for `Node`\n",
                "type": "Json.Decode.Decoder a -> Json.Decode.Decoder (Elm.Syntax.Node.Node a)"
            },
            {
                "name": "encode",
                "comment": " Encode a `Node` into JSON\n",
                "type": "(a -> Json.Encode.Value) -> Elm.Syntax.Node.Node a -> Json.Encode.Value"
            },
            {
                "name": "map",
                "comment": " Map the value within a node leaving the range untouched\n",
                "type": "(a -> b) -> Elm.Syntax.Node.Node a -> Elm.Syntax.Node.Node b"
            },
            {
                "name": "range",
                "comment": " Extract the range out of a `Node a`\n",
                "type": "Elm.Syntax.Node.Node a -> Elm.Syntax.Range.Range"
            },
            {
                "name": "value",
                "comment": " Extract the value (`a`) out of a `Node a`\n",
                "type": "Elm.Syntax.Node.Node a -> a"
            }
        ],
        "binops": []
    },
    {
        "name": "Elm.Syntax.Pattern",
        "comment": " This syntax represents the patterns.\nFor example:\n\n    Just x as someMaybe\n    {name, age}\n\n\n## Types\n\n@docs Pattern, QualifiedNameRef\n\n\n## Functions\n\n@docs moduleNames\n\n\n## Serialization\n\n@docs encode, decoder\n\n",
        "unions": [
            {
                "name": "Pattern",
                "comment": " Custom type for all patterns such as:\n\n  - `AllPattern`: `_`\n  - `UnitPattern`: `()`\n  - `CharPattern`: `'c'`\n  - `StringPattern`: `\"hello\"`\n  - `IntPattern`: `42`\n  - `HexPattern`: `0x11`\n  - `FloatPattern`: `42.0`\n  - `TuplePattern`: `(a, b)`\n  - `RecordPattern`: `{name, age}`\n  - `UnConsPattern`: `x :: xs`\n  - `ListPattern`: `[ x, y ]`\n  - `VarPattern`: `x`\n  - `NamedPattern`: `Just _`\n  - `AsPattern`: `_ as x`\n  - `ParenthesizedPattern`: `( _ )`\n\n",
                "args": [],
                "cases": [
                    [
                        "AllPattern",
                        []
                    ],
                    [
                        "UnitPattern",
                        []
                    ],
                    [
                        "CharPattern",
                        [
                            "Char.Char"
                        ]
                    ],
                    [
                        "StringPattern",
                        [
                            "String.String"
                        ]
                    ],
                    [
                        "IntPattern",
                        [
                            "Basics.Int"
                        ]
                    ],
                    [
                        "HexPattern",
                        [
                            "Basics.Int"
                        ]
                    ],
                    [
                        "FloatPattern",
                        [
                            "Basics.Float"
                        ]
                    ],
                    [
                        "TuplePattern",
                        [
                            "List.List (Elm.Syntax.Node.Node Elm.Syntax.Pattern.Pattern)"
                        ]
                    ],
                    [
                        "RecordPattern",
                        [
                            "List.List (Elm.Syntax.Node.Node String.String)"
                        ]
                    ],
                    [
                        "UnConsPattern",
                        [
                            "Elm.Syntax.Node.Node Elm.Syntax.Pattern.Pattern",
                            "Elm.Syntax.Node.Node Elm.Syntax.Pattern.Pattern"
                        ]
                    ],
                    [
                        "ListPattern",
                        [
                            "List.List (Elm.Syntax.Node.Node Elm.Syntax.Pattern.Pattern)"
                        ]
                    ],
                    [
                        "VarPattern",
                        [
                            "String.String"
                        ]
                    ],
                    [
                        "NamedPattern",
                        [
                            "Elm.Syntax.Pattern.QualifiedNameRef",
                            "List.List (Elm.Syntax.Node.Node Elm.Syntax.Pattern.Pattern)"
                        ]
                    ],
                    [
                        "AsPattern",
                        [
                            "Elm.Syntax.Node.Node Elm.Syntax.Pattern.Pattern",
                            "Elm.Syntax.Node.Node String.String"
                        ]
                    ],
                    [
                        "ParenthesizedPattern",
                        [
                            "Elm.Syntax.Node.Node Elm.Syntax.Pattern.Pattern"
                        ]
                    ]
                ]
            }
        ],
        "aliases": [
            {
                "name": "QualifiedNameRef",
                "comment": " Qualified name reference such as `Maybe.Just`.\n",
                "args": [],
                "type": "{ moduleName : List.List String.String, name : String.String }"
            }
        ],
        "values": [
            {
                "name": "decoder",
                "comment": " JSON decoder for a `Pattern` syntax element.\n",
                "type": "Json.Decode.Decoder Elm.Syntax.Pattern.Pattern"
            },
            {
                "name": "encode",
                "comment": " Encode a `Pattern` syntax element to JSON.\n",
                "type": "Elm.Syntax.Pattern.Pattern -> Json.Encode.Value"
            },
            {
                "name": "moduleNames",
                "comment": " Get all the modules names that are used in the pattern (and its nested patterns).\nUse this to collect qualified patterns, such as `Maybe.Just x`.\n",
                "type": "Elm.Syntax.Pattern.Pattern -> List.List Elm.Syntax.ModuleName.ModuleName"
            }
        ],
        "binops": []
    },
    {
        "name": "Elm.Syntax.Range",
        "comment": "\n\n\n## Types\n\n@docs Range, Location\n\n\n## Functions\n\n@docs emptyRange, combine\n\n\n## Comparison\n\nSee also [Basics.compare](https://package.elm-lang.org/packages/elm/core/latest/Basics#compare).\n\n@docs compare, compareLocations\n\n\n## Serialization\n\n@docs encode, decoder\n\n",
        "unions": [],
        "aliases": [
            {
                "name": "Location",
                "comment": " Source location\n",
                "args": [],
                "type": "{ row : Basics.Int, column : Basics.Int }"
            },
            {
                "name": "Range",
                "comment": " Range for a piece of code with a start and end\n",
                "args": [],
                "type": "{ start : Elm.Syntax.Range.Location, end : Elm.Syntax.Range.Location }"
            }
        ],
        "values": [
            {
                "name": "combine",
                "comment": " Compute the largest area of a list of ranges.\n",
                "type": "List.List Elm.Syntax.Range.Range -> Elm.Syntax.Range.Range"
            },
            {
                "name": "compare",
                "comment": " Compare the position of two Ranges.\n",
                "type": "Elm.Syntax.Range.Range -> Elm.Syntax.Range.Range -> Basics.Order"
            },
            {
                "name": "compareLocations",
                "comment": " Compare two Locations.\n",
                "type": "Elm.Syntax.Range.Location -> Elm.Syntax.Range.Location -> Basics.Order"
            },
            {
                "name": "decoder",
                "comment": " Decode a range\n",
                "type": "Json.Decode.Decoder Elm.Syntax.Range.Range"
            },
            {
                "name": "emptyRange",
                "comment": " Construct an empty range\n",
                "type": "Elm.Syntax.Range.Range"
            },
            {
                "name": "encode",
                "comment": " Encode a range\n",
                "type": "Elm.Syntax.Range.Range -> Json.Encode.Value"
            }
        ],
        "binops": []
    },
    {
        "name": "Elm.Syntax.Signature",
        "comment": " This syntax represents type signatures in Elm.\n\nFor example :\n\n    add : Int -> Int -> Int\n\n\n## Types\n\n@docs Signature\n\n\n## Serialization\n\n@docs encode, decoder\n\n",
        "unions": [],
        "aliases": [
            {
                "name": "Signature",
                "comment": " Type alias representing a signature in Elm.\n",
                "args": [],
                "type": "{ name : Elm.Syntax.Node.Node String.String, typeAnnotation : Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation }"
            }
        ],
        "values": [
            {
                "name": "decoder",
                "comment": " JSON decoder for a `Signature` syntax element.\n",
                "type": "Json.Decode.Decoder Elm.Syntax.Signature.Signature"
            },
            {
                "name": "encode",
                "comment": " Encode a `Signature` syntax element to JSON.\n",
                "type": "Elm.Syntax.Signature.Signature -> Json.Encode.Value"
            }
        ],
        "binops": []
    },
    {
        "name": "Elm.Syntax.Type",
        "comment": " This syntax represents custom types.\nFor example:\n\n    {-| This is a person\n    -}\n    type Color\n        = Blue\n        | Red\n\n\n## Types\n\n@docs Type, ValueConstructor\n\n\n## Serialization\n\n@docs encode, decoder\n\n",
        "unions": [],
        "aliases": [
            {
                "name": "Type",
                "comment": " Type alias that defines the syntax for a custom type.\nAll information that you can define in a type alias is embedded.\n",
                "args": [],
                "type": "{ documentation : Maybe.Maybe (Elm.Syntax.Node.Node Elm.Syntax.Documentation.Documentation), name : Elm.Syntax.Node.Node String.String, generics : List.List (Elm.Syntax.Node.Node String.String), constructors : List.List (Elm.Syntax.Node.Node Elm.Syntax.Type.ValueConstructor) }"
            },
            {
                "name": "ValueConstructor",
                "comment": " Syntax for a custom type value constructor\n",
                "args": [],
                "type": "{ name : Elm.Syntax.Node.Node String.String, arguments : List.List (Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation) }"
            }
        ],
        "values": [
            {
                "name": "decoder",
                "comment": " JSON decoder for a `Type` syntax element.\n",
                "type": "Json.Decode.Decoder Elm.Syntax.Type.Type"
            },
            {
                "name": "encode",
                "comment": " Encode a `Type` syntax element to JSON.\n",
                "type": "Elm.Syntax.Type.Type -> Json.Encode.Value"
            }
        ],
        "binops": []
    },
    {
        "name": "Elm.Syntax.TypeAlias",
        "comment": " This syntax represents type aliases.\nFor example:\n\n    {-| This is a person\n    -}\n    type alias Person =\n        { name : String\n        , age : Int\n        }\n\n\n## Types\n\n@docs TypeAlias\n\n\n## Serialization\n\n@docs encode, decoder\n\n",
        "unions": [],
        "aliases": [
            {
                "name": "TypeAlias",
                "comment": " Type alias that defines the syntax for a type alias.\nA bit meta, but you get the idea. All information that you can define in a type alias is embedded.\n",
                "args": [],
                "type": "{ documentation : Maybe.Maybe (Elm.Syntax.Node.Node Elm.Syntax.Documentation.Documentation), name : Elm.Syntax.Node.Node String.String, generics : List.List (Elm.Syntax.Node.Node String.String), typeAnnotation : Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation }"
            }
        ],
        "values": [
            {
                "name": "decoder",
                "comment": " JSON decoder for a `Declaration` syntax element.\n",
                "type": "Json.Decode.Decoder Elm.Syntax.TypeAlias.TypeAlias"
            },
            {
                "name": "encode",
                "comment": " Encode a `TypeAlias` syntax element to JSON.\n",
                "type": "Elm.Syntax.TypeAlias.TypeAlias -> Json.Encode.Value"
            }
        ],
        "binops": []
    },
    {
        "name": "Elm.Syntax.TypeAnnotation",
        "comment": " This syntax represents the type annotation syntax.\nFor example:\n\n    Int -> String\n\n\n## Types\n\n@docs TypeAnnotation, RecordDefinition, RecordField\n\n\n## Serialization\n\n@docs encode, decoder\n\n",
        "unions": [
            {
                "name": "TypeAnnotation",
                "comment": " Custom type for different type annotations. For example:\n\n  - `GenericType`: `a`\n  - `Typed`: `Maybe (Int -> String)`\n  - `Unit`: `()`\n  - `Tuples`: `(a, b, c)`\n  - `Record`: `{ name : String}`\n  - `GenericRecord`: `{ a | name : String}`\n  - `FunctionTypeAnnotation`: `Int -> String`\n\n",
                "args": [],
                "cases": [
                    [
                        "GenericType",
                        [
                            "String.String"
                        ]
                    ],
                    [
                        "Typed",
                        [
                            "Elm.Syntax.Node.Node ( Elm.Syntax.ModuleName.ModuleName, String.String )",
                            "List.List (Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation)"
                        ]
                    ],
                    [
                        "Unit",
                        []
                    ],
                    [
                        "Tupled",
                        [
                            "List.List (Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation)"
                        ]
                    ],
                    [
                        "Record",
                        [
                            "Elm.Syntax.TypeAnnotation.RecordDefinition"
                        ]
                    ],
                    [
                        "GenericRecord",
                        [
                            "Elm.Syntax.Node.Node String.String",
                            "Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.RecordDefinition"
                        ]
                    ],
                    [
                        "FunctionTypeAnnotation",
                        [
                            "Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation",
                            "Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation"
                        ]
                    ]
                ]
            }
        ],
        "aliases": [
            {
                "name": "RecordDefinition",
                "comment": " A list of fields in-order of a record type annotation.\n",
                "args": [],
                "type": "List.List (Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.RecordField)"
            },
            {
                "name": "RecordField",
                "comment": " Single field of a record. A name and its type.\n",
                "args": [],
                "type": "( Elm.Syntax.Node.Node String.String, Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation )"
            }
        ],
        "values": [
            {
                "name": "decoder",
                "comment": " JSON decoder for a `TypeAnnotation` syntax element.\n",
                "type": "Json.Decode.Decoder Elm.Syntax.TypeAnnotation.TypeAnnotation"
            },
            {
                "name": "encode",
                "comment": " Encode a `TypeAnnotation` syntax element to JSON.\n",
                "type": "Elm.Syntax.TypeAnnotation.TypeAnnotation -> Json.Encode.Value"
            }
        ],
        "binops": []
    },
    {
        "name": "Elm.Writer",
        "comment": " Write a file to a string.\n\n@docs write, writeFile, writePattern, writeExpression, writeTypeAnnotation, writeDeclaration\n\n",
        "unions": [],
        "aliases": [],
        "values": [
            {
                "name": "write",
                "comment": " Transform a writer to a string\n",
                "type": "StructuredWriter.Writer -> String.String"
            },
            {
                "name": "writeDeclaration",
                "comment": " Write a declaration\n",
                "type": "Elm.Syntax.Node.Node Elm.Syntax.Declaration.Declaration -> StructuredWriter.Writer"
            },
            {
                "name": "writeExpression",
                "comment": " Writer an expression\n",
                "type": "Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression -> StructuredWriter.Writer"
            },
            {
                "name": "writeFile",
                "comment": " Write a file\n",
                "type": "Elm.Syntax.File.File -> StructuredWriter.Writer"
            },
            {
                "name": "writePattern",
                "comment": " Write a pattern\n",
                "type": "Elm.Syntax.Node.Node Elm.Syntax.Pattern.Pattern -> StructuredWriter.Writer"
            },
            {
                "name": "writeTypeAnnotation",
                "comment": " Write a type annotation\n",
                "type": "Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation -> StructuredWriter.Writer"
            }
        ],
        "binops": []
    }
]