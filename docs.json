[{"name":"Elm","comment":"\n\n@docs File, file\n\n\n## Basics\n\n@docs Expression, toString\n\n@docs bool, int, float, char, string, hex, unit\n\n@docs maybe, just, nothing\n\n@docs list, tuple, triple\n\n@docs withType\n\n\n## Records\n\n@docs record, get, updateRecord\n\n\n## Flow control\n\n@docs ifThen\n\n**Note** If you need `let` or `case` expressions, check out the docs for [`Elm.Let`](./Elm-Let) or [`Elm.Case`](./Elm-Case)!\n\n\n## Declarations\n\nA `Declaration` is anything that is at the \"top level\" of your file, meaning all values with no indentation.\n\n@docs Declaration\n\n@docs comment, declaration\n\n@docs withDocumentation\n\n@docs expose, exposeWith\n\n@docs fileWith, docs\n\n\n## Functions\n\n@docs fn, fn2, fn3, fn4, fn5, fn6, function, functionReduced\n\n\n## Custom Types\n\n@docs customType, customTypeWith, Variant, variant, variantWith\n\n@docs alias, aliasWith\n\n\n# Ports\n\n@docs portIncoming, portOutgoing\n\n\n# Parsing existing Elm\n\n@docs parse, unsafe\n\n\n# Low-level\n\n@docs apply, val, value\n\n@docs unwrap, unwrapper\n\n","unions":[{"name":"Variant","comment":" ","args":[],"cases":[]}],"aliases":[{"name":"Declaration","comment":" ","args":[],"type":"Internal.Compiler.Declaration"},{"name":"Expression","comment":" ","args":[],"type":"Internal.Compiler.Expression"},{"name":"File","comment":" ","args":[],"type":"{ path : String.String, contents : String.String, warnings : List.List { declaration : String.String, warning : String.String } }"}],"values":[{"name":"alias","comment":" A type alias declaration.\n\n    import Elm.Annotation as Type\n\n    Elm.alias \"MyAlias\"\n        (Type.record\n            [ ( \"one\", Type.string )\n            , ( \"two\", Type.int )\n            , ( \"three\", Type.var \"content\" )\n            ]\n        )\n\nShould result in\n\n    type alias MyAlias content =\n        { one : String\n        , two : Int\n        , three : content\n        }\n\n","type":"String.String -> Elm.Annotation.Annotation -> Elm.Declaration"},{"name":"aliasWith","comment":" A type alias declaration, with the ability to specify in which order to put the type variables.\n\n    import Elm.Annotation as Type\n\n    Elm.aliasWith \"MyAlias\" [ \"twoVar\", \"nonexistingVar\", \"oneVar\" ]\n        (Type.record\n            [ ( \"one\", Type.var \"oneVar\" )\n            , ( \"two\", Type.var \"twoVar\" )\n            , ( \"three\", Type.var \"threeVar\" )\n            ]\n        )\n\nShould result in\n\n    type alias MyAlias twoVar oneVar threeVar =\n        { one : oneVar\n        , two : twoVar\n        , three : threeVar\n        }\n\nNotice how nonexisting variables are omitted, and missing variable are automatically added.\n\n","type":"String.String -> List.List String.String -> Elm.Annotation.Annotation -> Elm.Declaration"},{"name":"apply","comment":" ","type":"Elm.Expression -> List.List Elm.Expression -> Elm.Expression"},{"name":"bool","comment":" ","type":"Basics.Bool -> Elm.Expression"},{"name":"char","comment":" ","type":"Char.Char -> Elm.Expression"},{"name":"comment","comment":" Renders a multiline comment.\n\n    Elm.comment \"\"\"Here is my comment!\"\"\"\n\nWill generate\n\n\n\n    {- Here is my comment! -}\n\n","type":"String.String -> Elm.Declaration"},{"name":"customType","comment":" A custom type declaration.\n\n    Elm.customType \"MyType\"\n        [ Elm.variant \"One\"\n        , Elm.variantWith \"Two\"\n            [ Elm.Annotation.list Elm.Annotation.string ]\n        ]\n\nWill result in\n\n    type MyType\n        = One\n        | Two (List String)\n\n","type":"String.String -> List.List Elm.Variant -> Elm.Declaration"},{"name":"customTypeWith","comment":" A custom type declaration, with the ability to specify in which order to put the type variables.\n\n    Elm.customTypeWith \"MyType\"\n        [ \"addVar\", \"twoVar\" ]\n        [ Elm.variantWith \"One\"\n            [ Elm.Annotation.var \"oneVar\" ]\n        , Elm.variantWith \"Two\"\n            [ Elm.Annotation.var \"twoVar\" ]\n        ]\n\nWill result in\n\n    type MyType addVar twoVar oneVar\n        = One oneVar\n        | Two twoVar\n\nNotice how nonexisting variables (as used in phantom types) are included, and missing variable are automatically added.\n\n","type":"String.String -> List.List String.String -> List.List Elm.Variant -> Elm.Declaration"},{"name":"declaration","comment":" ","type":"String.String -> Elm.Expression -> Elm.Declaration"},{"name":"docs","comment":" Render a standard docstring.\n\n    @docs one, two, three\n\nIf a `group` has been given, it will be rendered as a second level header.\n\n```markdown\n## Group name\n\n@docs one, two, three\n```\n\n","type":"{ group : Maybe.Maybe String.String, members : List.List String.String } -> String.String"},{"name":"expose","comment":" By default, everything is exposed for your module.\n\nHowever, you can tag specific declarations you want exposed, and then only those things will be exposed.\n\n","type":"Elm.Declaration -> Elm.Declaration"},{"name":"exposeWith","comment":" You can also add a group tag to an exposed value. This will automatically group the `docs` statements in the module docs.\n\nFor precise control over what is rendered for the module comment, use [fileWith](#fileWith).\n\n","type":"{ exposeConstructor : Basics.Bool, group : Maybe.Maybe String.String } -> Elm.Declaration -> Elm.Declaration"},{"name":"file","comment":" Build a file!\n\n    Elm.file [ \"My\", \"Module\" ]\n        [ Elm.declaration \"placeholder\"\n            (Elm.string \"a fancy string!\")\n        ]\n\n","type":"List.List String.String -> List.List Elm.Declaration -> Elm.File"},{"name":"fileWith","comment":" Same as [file](#file), but you have more control over how the module comment is generated!\n\nPass in a function that determines how to render a `@docs` comment.\n\nEach exposed item is grouped based on the string used in [exposeWith](#exposeWith).\n\n**aliases** allow you to specify a module alias to be used.\n\n    Elm.fileWith [ \"MyModule\" ]\n        { docs = List.map Elm.docs\n        , aliases =\n            [ ( [ \"Json\", \"Encode\" ], \"Encode\" )\n            ]\n        }\n        [-- whatever declarations you desire.\n        ]\n\nwould make an import statement like\n\n    import Json.Encode as Encode\n\nAll values rendered in this file that are from this module would also automatically respect this alias as well.\n\n","type":"List.List String.String -> { docs : List.List { group : Maybe.Maybe String.String, members : List.List String.String } -> List.List String.String, aliases : List.List ( List.List String.String, String.String ) } -> List.List Elm.Declaration -> Elm.File"},{"name":"float","comment":" ","type":"Basics.Float -> Elm.Expression"},{"name":"fn","comment":" Create a function with a single argument.\n\nThis may seem a little weird the first time you encounter it, so let's break it down.\n\nHere's what's happening for the `fn*` functions —\n\n  - The `String` arguments are the **names of the arguments** for the generated function.\n  - The attached `Maybe Annotation` is the type annotation. If you provide `Nothing`, then `elm-codegen` will infer the type for you!\n  - The `(Expression -> Expression)` function is where we're providing you an `Expression` that represents an argument coming in to the generated function.\n\nSo, this\n\n    Elm.fn ( \"firstInt\", Nothing )\n        (\\firstArgument ->\n            Elm.plus\n                (Elm.int 42)\n                firstArgument\n        )\n\nGenerates\n\n    \\firstInt -> 42 + firstInt\n\nIf you want to generate a **top level** function instead of an anonymous function, use `Elm.declaration`.\n\n    Elm.declaration \"add42\" <|\n        Elm.fn ( \"firstInt\", Nothing )\n            (\\firstArgument ->\n                Elm.plus\n                    (Elm.int 42)\n                    firstArgument\n            )\n\nResults in\n\n    add42 : Int -> Int\n    add42 firstInt =\n        42 + firstInt\n\n**Note** — Elm CodeGen will protect variable names if they're used in a nested `fn*` by adding a string of numbers to the end of the name. So, you may see a variable name be something like `myVariable_0_1`.\n\nIf you absolutely don't want this behavior, you'll need to use [`functionAdvanced`](#functionAdvanced).\n\n","type":"( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> (Elm.Expression -> Elm.Expression) -> Elm.Expression"},{"name":"fn2","comment":" ","type":"( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> (Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Expression"},{"name":"fn3","comment":" ","type":"( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> (Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Expression"},{"name":"fn4","comment":" ","type":"( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> (Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Expression"},{"name":"fn5","comment":" ","type":"( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> (Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Expression"},{"name":"fn6","comment":" ","type":"( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> (Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Expression"},{"name":"function","comment":" You may run into situations where you don't know the number of arguments for a function at compile-time.\n\nIn that case you can use `function`. It follows the same pattern as the `fn*` functions.\n\nProvide it with —\n\n  - A list of argument names and an optional type\n  - A function which will be given all the input arguments as `Expression`s.\n\n","type":"List.List ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> (List.List Elm.Expression -> Elm.Expression) -> Elm.Expression"},{"name":"functionReduced","comment":" This is a special case of function declaration which will _reduce_ itself if possible.\n\nMeaning, if this would generate the following code\n\n    \\myArg -> someOtherFunction myArg\n\nThen it will replace itself with just\n\n    someOtherFunction\n\n**Note** you likely won't need this! It's generally used by the package-helper generator, but that might be a relatively special case.\n\n","type":"String.String -> (Elm.Expression -> Elm.Expression) -> Elm.Expression"},{"name":"get","comment":"\n\n    record\n        |> Elm.get \"field\"\n\nresults in\n\n    record.field\n\n","type":"String.String -> Elm.Expression -> Elm.Expression"},{"name":"hex","comment":" ","type":"Basics.Int -> Elm.Expression"},{"name":"ifThen","comment":"\n\n    ifThen (Elm.bool True)\n        (Elm.string \"yes\")\n        (Elm.string \"no\")\n\nWill generate\n\n    if True then\n        \"yes\"\n\n    else\n        \"no\"\n\nIf you need more than one branch, then chain them together!\n\n     Elm.ifThen (Elm.bool True)\n        (Elm.string \"yes\")\n        (Elm.ifThen (Elm.bool True)\n            (Elm.string \"maybe\")\n            (Elm.string \"no\")\n        )\n\nWill generate\n\n    if True then\n        \"yes\"\n\n    else if True then\n        \"maybe\"\n\n    else\n        \"no\"\n\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"int","comment":" ","type":"Basics.Int -> Elm.Expression"},{"name":"just","comment":" ","type":"Elm.Expression -> Elm.Expression"},{"name":"list","comment":" ","type":"List.List Elm.Expression -> Elm.Expression"},{"name":"maybe","comment":" ","type":"Maybe.Maybe Elm.Expression -> Elm.Expression"},{"name":"nothing","comment":" ","type":"Elm.Expression"},{"name":"parse","comment":" ","type":"String.String -> Result.Result String.String { declarations : List.List Elm.Declaration }"},{"name":"portIncoming","comment":"\n\n    import Elm.Annotation as Type\n\n    Elm.portIncoming \"receiveMessageFromTheWorld\"\n        [ Type.string\n        , Type.int\n        ]\n\nResults in\n\n    port receiveMessageFromTheWorld :\n        (String -> Int -> msg)\n        -> Sub msg\n\n**Note** You generally only need one incoming and one outgoing port!\n\nIf you want to vary the messages going in and out of your app, don't use a huge number of ports, instead write Json encoders and decoders.\n\nThis will give you more flexibility in the future and save you having to wire up a bunch of stuff.\n\n**Another note** - You may need to expose your port explicitly using [`Elm.expose`](#expose).\n\n","type":"String.String -> List.List Elm.Annotation.Annotation -> Elm.Declaration"},{"name":"portOutgoing","comment":" Create a port that can send messages to the outside world!\n\n    import Elm.Annotation as Type\n\n    Elm.portOutgoing \"tellTheWorld\" Type.string\n\nwill generate\n\n    port tellTheWorld : String -> Cmd msg\n\n","type":"String.String -> Elm.Annotation.Annotation -> Elm.Declaration"},{"name":"record","comment":"\n\n    Elm.record\n        [ ( \"name\", Elm.string \"Elm\" )\n        , ( \"designation\", Elm.string \"Pretty fabulous\" )\n        ]\n\n","type":"List.List ( String.String, Elm.Expression ) -> Elm.Expression"},{"name":"string","comment":" ","type":"String.String -> Elm.Expression"},{"name":"toString","comment":" See what code this expression would generate!\n\n**Note** - Check out the `Elm.ToString` module if this doesn't quite meet your needs!\n\n","type":"Elm.Expression -> String.String"},{"name":"triple","comment":" ","type":"Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"tuple","comment":" ","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"unit","comment":" ","type":"Elm.Expression"},{"name":"unsafe","comment":" This will insert the given string into your generated file.\n\nCheck out the [using packages/helpers guide](https://github.com/mdgriffith/elm-codegen/tree/main/guide/UsingHelpers.md). If you're reaching for this, it's likely you'd be better off using a local helper file!\n\n","type":"String.String -> Elm.Declaration"},{"name":"unwrap","comment":" Unwraps a single-variant type\n\n    Elm.declaration \"myFunction\" <|\n        Elm.fn \"val\"\n            (\\val ->\n                Elm.unwrap \"MyType\" val\n            )\n\nResults in the following lambda\n\n    myFunction val =\n        (\\(MyType val) -> val) val\n\n","type":"List.List String.String -> String.String -> Elm.Expression -> Elm.Expression"},{"name":"unwrapper","comment":" Generate a lambda which unwraps a single-variant type.\n\n    Elm.unwrapper [ \"MyModule\" ] \"MyType\"\n\nResults in the following lambda\n\n    \\(MyModule.MyType val) -> val\n\n","type":"List.List String.String -> String.String -> Elm.Expression"},{"name":"updateRecord","comment":"\n\n    myRecord\n        |> updateRecord\n            [ ( \"designation\", Elm.string \"Pretty fabulous\" )\n            ]\n\nResults in\n\n    { myRecord | designation = \"Pretty fabulous\" }\n\n","type":"List.List ( String.String, Elm.Expression ) -> Elm.Expression -> Elm.Expression"},{"name":"val","comment":" ","type":"String.String -> Elm.Expression"},{"name":"value","comment":" ","type":"{ importFrom : List.List String.String, name : String.String, annotation : Maybe.Maybe Elm.Annotation.Annotation } -> Elm.Expression"},{"name":"variant","comment":" ","type":"String.String -> Elm.Variant"},{"name":"variantWith","comment":" ","type":"String.String -> List.List Elm.Annotation.Annotation -> Elm.Variant"},{"name":"withDocumentation","comment":" Add a documentation comment to a declaration!\n","type":"String.String -> Elm.Declaration -> Elm.Declaration"},{"name":"withType","comment":" Sometimes you may need to add a manual type annotation.\n\n    import Elm.Annotation as Type\n\n    Elm.value \"myString\"\n        |> Elm.withType Type.string\n\nThough be sure `elm-codegen` isn't already doing this automatically for you!\n\n","type":"Elm.Annotation.Annotation -> Elm.Expression -> Elm.Expression"}],"binops":[]},{"name":"Elm.Annotation","comment":"\n\n@docs Annotation, var, bool, int, float, string, char, unit\n\n@docs cmd, sub\n\n@docs named, namedWith\n\n@docs maybe, list, tuple, triple, set, dict, result\n\n@docs record, extensible, alias\n\n@docs function\n\n@docs toString\n\n","unions":[],"aliases":[{"name":"Annotation","comment":" ","args":[],"type":"Internal.Compiler.Annotation"}],"values":[{"name":"alias","comment":" The classic example of a Model\n\n    Elm.Annotation.alias []\n        \"Model\"\n        []\n        (Elm.Annotation.record\n            [ ( \"hello\", Elm.Annotation.string ) ]\n        )\n\nwould correspond to\n\n    type alias Model =\n        { hello : String\n        }\n\n","type":"List.List String.String -> String.String -> List.List Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"bool","comment":" ","type":"Elm.Annotation.Annotation"},{"name":"char","comment":" ","type":"Elm.Annotation.Annotation"},{"name":"cmd","comment":" ","type":"Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"dict","comment":" ","type":"Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"extensible","comment":" ","type":"String.String -> List.List ( String.String, Elm.Annotation.Annotation ) -> Elm.Annotation.Annotation"},{"name":"float","comment":" ","type":"Elm.Annotation.Annotation"},{"name":"function","comment":" ","type":"List.List Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"int","comment":" ","type":"Elm.Annotation.Annotation"},{"name":"list","comment":" ","type":"Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"maybe","comment":" ","type":"Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"named","comment":" ","type":"List.List String.String -> String.String -> Elm.Annotation.Annotation"},{"name":"namedWith","comment":" ","type":"List.List String.String -> String.String -> List.List Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"record","comment":" ","type":"List.List ( String.String, Elm.Annotation.Annotation ) -> Elm.Annotation.Annotation"},{"name":"result","comment":" ","type":"Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"set","comment":" ","type":"Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"string","comment":" ","type":"Elm.Annotation.Annotation"},{"name":"sub","comment":" ","type":"Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"toString","comment":" ","type":"Elm.Annotation.Annotation -> String.String"},{"name":"triple","comment":" ","type":"Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"tuple","comment":" ","type":"Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"unit","comment":" ","type":"Elm.Annotation.Annotation"},{"name":"var","comment":" A type variable\n","type":"String.String -> Elm.Annotation.Annotation"}],"binops":[]},{"name":"Elm.Case","comment":" Generate a case expression!\n\nHere's an example for extracting a `Maybe Int`\n\n    Elm.Case.maybe myMaybe\n        { nothing = Elm.int 0\n        , just =\n            ( \"value\"\n            , \\content ->\n                Elm.plus (Elm.int 5) content\n            )\n        }\n\nGenerates\n\n    case myMaybe of\n        Nothing ->\n            0\n\n        Just value ->\n            value + 5\n\n@docs maybe, result, list, string\n\n@docs tuple, triple\n\n\n## Case on a Custom Type\n\n    Elm.Case.custom maybeString\n        (Elm.Annotation.maybe Elm.Annotation.string)\n        [ Elm.Case.branch0 \"Nothing\"\n            (Elm.string \"It's nothing, I swear!\")\n        , Elm.Case.branch1 \"Just\" ( \"val\", Elm.Annotation.string ) <|\n            \\val ->\n                Elm.append (Elm.string \"Actually, it's: \") val\n        ]\n\nGenerates\n\n    case maybeString of\n        Nothing ->\n            \"It's nothing, I swear!\"\n\n        Just just ->\n            \"Actually, it's: \" ++ just\n\n@docs custom\n\n@docs Branch, otherwise, branch0, branch1, branch2, branch3, branch4, branch5, branch6\n\n@docs branchWith\n\n@docs branchList\n\n","unions":[],"aliases":[{"name":"Branch","comment":" ","args":[],"type":"Internal.Branch.Branch"}],"values":[{"name":"branch0","comment":" ","type":"String.String -> Elm.Expression -> Elm.Case.Branch"},{"name":"branch1","comment":" ","type":"String.String -> ( String.String, Elm.Annotation.Annotation ) -> (Elm.Expression -> Elm.Expression) -> Elm.Case.Branch"},{"name":"branch2","comment":" ","type":"String.String -> ( String.String, Elm.Annotation.Annotation ) -> ( String.String, Elm.Annotation.Annotation ) -> (Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Case.Branch"},{"name":"branch3","comment":" ","type":"String.String -> ( String.String, Elm.Annotation.Annotation ) -> ( String.String, Elm.Annotation.Annotation ) -> ( String.String, Elm.Annotation.Annotation ) -> (Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Case.Branch"},{"name":"branch4","comment":" ","type":"String.String -> ( String.String, Elm.Annotation.Annotation ) -> ( String.String, Elm.Annotation.Annotation ) -> ( String.String, Elm.Annotation.Annotation ) -> ( String.String, Elm.Annotation.Annotation ) -> (Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Case.Branch"},{"name":"branch5","comment":" ","type":"String.String -> ( String.String, Elm.Annotation.Annotation ) -> ( String.String, Elm.Annotation.Annotation ) -> ( String.String, Elm.Annotation.Annotation ) -> ( String.String, Elm.Annotation.Annotation ) -> ( String.String, Elm.Annotation.Annotation ) -> (Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Case.Branch"},{"name":"branch6","comment":" ","type":"String.String -> ( String.String, Elm.Annotation.Annotation ) -> ( String.String, Elm.Annotation.Annotation ) -> ( String.String, Elm.Annotation.Annotation ) -> ( String.String, Elm.Annotation.Annotation ) -> ( String.String, Elm.Annotation.Annotation ) -> ( String.String, Elm.Annotation.Annotation ) -> (Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Case.Branch"},{"name":"branchList","comment":" ","type":"Basics.Int -> (List.List Elm.Expression -> Elm.Expression) -> Elm.Case.Branch"},{"name":"branchWith","comment":" ","type":"String.String -> Basics.Int -> (List.List Elm.Expression -> Elm.Expression) -> Elm.Case.Branch"},{"name":"custom","comment":" ","type":"Elm.Expression -> Elm.Annotation.Annotation -> List.List Elm.Case.Branch -> Elm.Expression"},{"name":"list","comment":" Let's unpack the first value from a list.\n\n    Elm.Case.list myList\n        { empty = Elm.int 0\n        , nonEmpty =\n            \\top remaining ->\n                Elm.plus (Elm.int 5) top\n        }\n\nGenerates\n\n    case myList of\n        [] ->\n            0\n\n        top :: remaining ->\n            top + 5\n\n**Note** if you want more control over unpacking lists, check out [`branchList`](#branchList)\n\n","type":"Elm.Expression -> { empty : Elm.Expression, nonEmpty : Elm.Expression -> Elm.Expression -> Elm.Expression } -> Elm.Expression"},{"name":"maybe","comment":" ","type":"Elm.Expression -> { nothing : Elm.Expression, just : ( String.String, Elm.Expression -> Elm.Expression ) } -> Elm.Expression"},{"name":"otherwise","comment":" A catchall branch in case you want the case to be nonexhaustive.\n","type":"(Elm.Expression -> Elm.Expression) -> Elm.Case.Branch"},{"name":"result","comment":"\n\n    Elm.Case.result myResult\n        { ok =\n            Tuple.pair \"ok\" <|\n                \\ok ->\n                    Elm.string \"No errors\"\n        , err =\n            Tuple.pair \"err\" <|\n                \\err ->\n                    err\n        }\n\nGenerates\n\n    case myResult of\n        Ok ok ->\n            \"No errors\"\n\n        Err err ->\n            err\n\n","type":"Elm.Expression -> { err : ( String.String, Elm.Expression -> Elm.Expression ), ok : ( String.String, Elm.Expression -> Elm.Expression ) } -> Elm.Expression"},{"name":"string","comment":" ","type":"Elm.Expression -> { cases : List.List ( String.String, Elm.Expression ), otherwise : Elm.Expression } -> Elm.Expression"},{"name":"triple","comment":"\n\n    Elm.Case.triple myTriple\n        \"one\"\n        \"two\"\n        \"three\"\n        (\\one two three ->\n            Elm.plus (Elm.int 5) two\n        )\n\nGenerates\n\n    case myTriple of\n        ( one, two, three ) ->\n            5 + two\n\n","type":"Elm.Expression -> String.String -> String.String -> String.String -> (Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Expression"},{"name":"tuple","comment":"\n\n    Elm.Case.tuple myTuple\n        \"first\"\n        \"second\"\n        (\\one two ->\n            Elm.plus (Elm.int 5) two\n        )\n\nGenerates\n\n    case myTuple of\n        ( first, second ) ->\n            5 + second\n\n","type":"Elm.Expression -> String.String -> String.String -> (Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Expression"}],"binops":[]},{"name":"Elm.Case.Branch","comment":" This module is for creating more advanced pattern matches in your case expressions.\n\nThe general usage looks something like this\n\n    import Elm.Case as Case\n    import Elm.Case.Branch as Branch\n\n    example =\n        Case.custom myValue\n            (Elm.Annotation.named [] \"Msg\")\n            -- Define all the branches in your case\n            [ Branch.variant1 \"ButtonClicked\" (Branch.var \"id\") <|\n                \\id -> Elm.Op.append id (Elm.string \" was clicked!\")\n\n            -- A branch which also destructures a record\n            , Branch.variant1 \"FormSubmitted\" (Branch.record2 Tuple.pair \"id\" \"isValid\") <|\n                \\( id, isValid ) ->\n                    Elm.ifThen isValue\n                        (Elm.string \"Form is valid\")\n                        (Elm.string \"Form is NOT valid\")\n            ]\n\nWhich generates\n\n    case myValue of\n        ButtonClicked id ->\n            \"Button \" ++ id ++ \" was clicked!\"\n\n        FormSubmitted { id, isValid } ->\n            if isValid then\n                \"Form is valid\"\n\n            else\n                \"Form is NOT valid\"\n\n@docs Branch, Pattern, map\n\n\n## Variables\n\n@docs var\n\n\n## Exact Matches\n\n@docs unit, ignore\n\n\n### Literals\n\n@docs int, string, char\n\n\n## Tuples and Triples\n\n@docs tuple, triple\n\n\n## Lists\n\n@docs list, listWithRemaining\n\n\n## Maybe\n\n@docs just, nothing\n\n\n## Result\n\n@docs err, ok\n\n\n## Records\n\nThis will help destructure record fields if you know what fields you want.\n\nHere's an example using an intermediate record to help us out!\n\n    {-| We define a record to help us out!\n    -}\n    type alias Details =\n        { id : Elm.Expression\n        , name : Elm.Expression\n        }\n\n    Case.custom (Elm.val \"msg\") (Type.named [] \"Msg\")\n        [ Branch.variant1 \"ButtonClicked\" (Branch.record2 Details \"id\" \"name\") <|\n            \\{ id, name } ->\n               Elm.tuple id name\n        ]\n\nWhich generates\n\n    case msg of\n        ButtonClicked { id, name } ->\n            ( id, name )\n\n@docs record0, record1, record2, record3, record4, record5, record6, record7, record8, record9\n\n\n## Custom Types\n\n@docs variant0, variant1, variant2, variant3, variant4, variant5, variant6, variant7, variant8, variant9\n\n\n## Custom Type Builder\n\nThese helpers let you define a Custom Type pattern with a builder.\n\n@docs CustomType, customType, withParam, toPattern\n\n\n## Alias (`as`)\n\n@docs aliasAs\n\n","unions":[{"name":"CustomType","comment":" ","args":["a"],"cases":[]}],"aliases":[{"name":"Branch","comment":" ","args":[],"type":"Internal.Branch.Branch"},{"name":"Pattern","comment":" ","args":["a"],"type":"Internal.Branch.Pattern a"}],"values":[{"name":"aliasAs","comment":" ","type":"String.String -> (Elm.Expression -> a -> b) -> Elm.Case.Branch.Pattern a -> Elm.Case.Branch.Pattern b"},{"name":"char","comment":" Matches a literal Char.\n","type":"Char.Char -> a -> Elm.Case.Branch.Pattern a"},{"name":"customType","comment":" ","type":"String.String -> a -> Elm.Case.Branch.CustomType a"},{"name":"err","comment":" The `Err` value of a result.\n","type":"Elm.Case.Branch.Pattern err -> Elm.Case.Branch.Pattern err"},{"name":"ignore","comment":" ","type":"value -> Elm.Case.Branch.Pattern value"},{"name":"int","comment":" Pattern match with a literal Int.\n\n    import Elm.Case.Branch as Branch\n\n    Branch.just (Branch.int 2 (Elm.int 5))\n\nResults in\n\n    Just 2 ->\n        5\n\n","type":"Basics.Int -> value -> Elm.Case.Branch.Pattern value"},{"name":"just","comment":" ","type":"Elm.Case.Branch.Pattern just -> Elm.Case.Branch.Pattern just"},{"name":"list","comment":" Match on a list of items\n\n    [ \"first\", \"second\" ] ->\n        \"firstsecond\"\n\nCould be represented like\n\n    Branch.list\n        { patterns =\n            [ Branch.string \"first\"\n            , Branch.string \"second\"\n            ]\n        , gather = \\item gathered -> item :: gathered\n        , startWith = []\n        , finally = Elm.string\n        }\n\n","type":"{ patterns : List.List (Elm.Case.Branch.Pattern item), gather : item -> gathered -> gathered, startWith : gathered, finally : gathered -> list } -> Elm.Case.Branch.Pattern list"},{"name":"listWithRemaining","comment":" Pattern match on an open list where you can have access to remaining \"tail\" of items.\n\nSo, something like this:\n\n    \"first\" :: \"second\" :: remaining ->\n        remaining\n\nCould be represented like\n\n    Branch.listWithRemaining\n        { patterns =\n            [ Branch.string \"first\"\n            , Branch.string \"second\"\n            ]\n        , remaining = Branch.var \"remaining\"\n        , gather = \\item gathered -> item :: gathered\n        , startWith = []\n        , finally =\n            \\gathered remaining ->\n                remaining\n        }\n\n","type":"{ patterns : List.List (Elm.Case.Branch.Pattern item), remaining : Elm.Case.Branch.Pattern remaining, gather : item -> gathered -> gathered, startWith : gathered, finally : gathered -> remaining -> list } -> Elm.Case.Branch.Pattern list"},{"name":"map","comment":" ","type":"(a -> b) -> Elm.Case.Branch.Pattern a -> Elm.Case.Branch.Pattern b"},{"name":"nothing","comment":" ","type":"value -> Elm.Case.Branch.Pattern value"},{"name":"ok","comment":" The `Ok` value for a `Result`\n","type":"Elm.Case.Branch.Pattern ok -> Elm.Case.Branch.Pattern ok"},{"name":"record0","comment":" An empty record pattern!\n","type":"record -> Elm.Case.Branch.Pattern record"},{"name":"record1","comment":" ","type":"(Elm.Expression -> record) -> String.String -> Elm.Case.Branch.Pattern record"},{"name":"record2","comment":" ","type":"(Elm.Expression -> Elm.Expression -> combined) -> String.String -> String.String -> Elm.Case.Branch.Pattern combined"},{"name":"record3","comment":" ","type":"(Elm.Expression -> Elm.Expression -> Elm.Expression -> combined) -> String.String -> String.String -> String.String -> Elm.Case.Branch.Pattern combined"},{"name":"record4","comment":" ","type":"(Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> combined) -> String.String -> String.String -> String.String -> String.String -> Elm.Case.Branch.Pattern combined"},{"name":"record5","comment":" ","type":"(Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> combined) -> String.String -> String.String -> String.String -> String.String -> String.String -> Elm.Case.Branch.Pattern combined"},{"name":"record6","comment":" ","type":"(Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> combined) -> String.String -> String.String -> String.String -> String.String -> String.String -> String.String -> Elm.Case.Branch.Pattern combined"},{"name":"record7","comment":" ","type":"(Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> combined) -> String.String -> String.String -> String.String -> String.String -> String.String -> String.String -> String.String -> Elm.Case.Branch.Pattern combined"},{"name":"record8","comment":" ","type":"(Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> combined) -> String.String -> String.String -> String.String -> String.String -> String.String -> String.String -> String.String -> String.String -> Elm.Case.Branch.Pattern combined"},{"name":"record9","comment":" ","type":"(Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> combined) -> String.String -> String.String -> String.String -> String.String -> String.String -> String.String -> String.String -> String.String -> String.String -> Elm.Case.Branch.Pattern combined"},{"name":"string","comment":" Matches a literal String.\n\n    example =\n        Branch.just (Branch.string \"admin\")\n            |> Branch.map\n                (\\str ->\n                    Elm.string \"This user is an admin!\"\n                )\n\nResults in\n\n    case user.kind of\n        Just \"admin\" ->\n            \"This user is an admin!\"\n\n","type":"String.String -> value -> Elm.Case.Branch.Pattern value"},{"name":"toPattern","comment":" ","type":"Elm.Case.Branch.CustomType a -> Elm.Case.Branch.Pattern a"},{"name":"triple","comment":" ","type":"Elm.Case.Branch.Pattern a -> Elm.Case.Branch.Pattern b -> Elm.Case.Branch.Pattern c -> Elm.Case.Branch.Pattern ( a, b, c )"},{"name":"tuple","comment":"\n\n    Branch.tuple (Branch.var \"one\") (Branch.var \"two\")\n        |> Branch.map\n            (\\( one, two ) ->\n                Elm.Op.append one two\n            )\n\n","type":"Elm.Case.Branch.Pattern a -> Elm.Case.Branch.Pattern b -> Elm.Case.Branch.Pattern ( a, b )"},{"name":"unit","comment":" ","type":"value -> Elm.Case.Branch.Pattern value"},{"name":"var","comment":" This is the most basic kind of pattern - it matches anything and gives it a variable name.\n\n    import Elm.Case.Branch as Branch\n\n\n    Branch.variant1 \"Username\" (Branch.var \"username\") <|\n        \\username ->\n            Elm.Op.append\n                (Elm.string \"Hello \")\n                username\n\nResults in\n\n    Username username ->\n        \"Hello \" ++ username\n\n","type":"String.String -> Elm.Case.Branch.Pattern Elm.Expression"},{"name":"variant0","comment":" ","type":"String.String -> value -> Elm.Case.Branch.Pattern value"},{"name":"variant1","comment":" ","type":"String.String -> Elm.Case.Branch.Pattern value -> (value -> result) -> Elm.Case.Branch.Pattern result"},{"name":"variant2","comment":" ","type":"String.String -> Elm.Case.Branch.Pattern value1 -> Elm.Case.Branch.Pattern value2 -> (value1 -> value2 -> combined) -> Elm.Case.Branch.Pattern combined"},{"name":"variant3","comment":" ","type":"String.String -> Elm.Case.Branch.Pattern value1 -> Elm.Case.Branch.Pattern value2 -> Elm.Case.Branch.Pattern value3 -> (value1 -> value2 -> value3 -> combined) -> Elm.Case.Branch.Pattern combined"},{"name":"variant4","comment":" ","type":"String.String -> Elm.Case.Branch.Pattern value1 -> Elm.Case.Branch.Pattern value2 -> Elm.Case.Branch.Pattern value3 -> Elm.Case.Branch.Pattern value4 -> (value1 -> value2 -> value3 -> value4 -> combined) -> Elm.Case.Branch.Pattern combined"},{"name":"variant5","comment":" ","type":"String.String -> Elm.Case.Branch.Pattern value1 -> Elm.Case.Branch.Pattern value2 -> Elm.Case.Branch.Pattern value3 -> Elm.Case.Branch.Pattern value4 -> Elm.Case.Branch.Pattern value5 -> (value1 -> value2 -> value3 -> value4 -> value5 -> combined) -> Elm.Case.Branch.Pattern combined"},{"name":"variant6","comment":" ","type":"String.String -> Elm.Case.Branch.Pattern value1 -> Elm.Case.Branch.Pattern value2 -> Elm.Case.Branch.Pattern value3 -> Elm.Case.Branch.Pattern value4 -> Elm.Case.Branch.Pattern value5 -> Elm.Case.Branch.Pattern value6 -> (value1 -> value2 -> value3 -> value4 -> value5 -> value6 -> combined) -> Elm.Case.Branch.Pattern combined"},{"name":"variant7","comment":" ","type":"String.String -> Elm.Case.Branch.Pattern value1 -> Elm.Case.Branch.Pattern value2 -> Elm.Case.Branch.Pattern value3 -> Elm.Case.Branch.Pattern value4 -> Elm.Case.Branch.Pattern value5 -> Elm.Case.Branch.Pattern value6 -> Elm.Case.Branch.Pattern value7 -> (value1 -> value2 -> value3 -> value4 -> value5 -> value6 -> value7 -> combined) -> Elm.Case.Branch.Pattern combined"},{"name":"variant8","comment":" ","type":"String.String -> Elm.Case.Branch.Pattern value1 -> Elm.Case.Branch.Pattern value2 -> Elm.Case.Branch.Pattern value3 -> Elm.Case.Branch.Pattern value4 -> Elm.Case.Branch.Pattern value5 -> Elm.Case.Branch.Pattern value6 -> Elm.Case.Branch.Pattern value7 -> Elm.Case.Branch.Pattern value8 -> (value1 -> value2 -> value3 -> value4 -> value5 -> value6 -> value7 -> value8 -> combined) -> Elm.Case.Branch.Pattern combined"},{"name":"variant9","comment":" ","type":"String.String -> Elm.Case.Branch.Pattern value1 -> Elm.Case.Branch.Pattern value2 -> Elm.Case.Branch.Pattern value3 -> Elm.Case.Branch.Pattern value4 -> Elm.Case.Branch.Pattern value5 -> Elm.Case.Branch.Pattern value6 -> Elm.Case.Branch.Pattern value7 -> Elm.Case.Branch.Pattern value8 -> Elm.Case.Branch.Pattern value9 -> (value1 -> value2 -> value3 -> value4 -> value5 -> value6 -> value7 -> value8 -> value9 -> combined) -> Elm.Case.Branch.Pattern combined"},{"name":"withParam","comment":" ","type":"Elm.Case.Branch.Pattern a -> Elm.Case.Branch.CustomType (a -> b) -> Elm.Case.Branch.CustomType b"}],"binops":[]},{"name":"Elm.Declare","comment":" You may run into situations where you want to generate a function, and then call that generated function somewhere else.\n\nThis module will help you do that.\n\nHere's an example, let's define a new function called `add42`\n\n    renderFile =\n        let\n            add42 =\n                Elm.Declare.fn \"add42\"\n                    ( \"firstInt\", Nothing )\n                    (\\firstArgument ->\n                        Elm.plus\n                            (Elm.int 42)\n                            firstArgument\n                    )\n        in\n        Elm.file [ \"MyFile\" ]\n            -- add our declaration to our file\n            [ add42.declaration\n\n            -- and another place where we call that function!\n            , Elm.declaration \"mySweetNumber\"\n                (add42.call (Elm.int 82))\n            ]\n\nDepending on your situation, you may want to define a function in one file, but call it from another.\n\nIn that case you can do something like this using `callFrom`:\n\n    renderFileList =\n        let\n            add42 =\n                Elm.Declare.fn \"add42\"\n                    ( \"firstInt\", Nothing )\n                    (\\firstArgument ->\n                        Elm.plus\n                            (Elm.int 42)\n                            firstArgument\n                    )\n        in\n        [ Elm.file [ \"MyFile\" ]\n            -- add our declaration to our file\n            [ add42.declaration\n            ]\n        , Elm.file [ \"MyOtherFile\" ]\n            -- and call from another file\n            [ Elm.declaration \"mySweetNumber\"\n                (add42.callFrom [ \"MyFile\" ] (Elm.int 82))\n            ]\n        ]\n\n@docs fn, fn2, fn3, fn4, fn5, fn6\n\n@docs value\n\n@docs function\n\n","unions":[],"aliases":[],"values":[{"name":"fn","comment":" ","type":"String.String -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> (Elm.Expression -> Elm.Expression) -> { declaration : Elm.Declaration, call : Elm.Expression -> Elm.Expression, callFrom : List.List String.String -> Elm.Expression -> Elm.Expression, value : List.List String.String -> Elm.Expression }"},{"name":"fn2","comment":" ","type":"String.String -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> (Elm.Expression -> Elm.Expression -> Elm.Expression) -> { declaration : Elm.Declaration, call : Elm.Expression -> Elm.Expression -> Elm.Expression, callFrom : List.List String.String -> Elm.Expression -> Elm.Expression -> Elm.Expression, value : List.List String.String -> Elm.Expression }"},{"name":"fn3","comment":" ","type":"String.String -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> (Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> { declaration : Elm.Declaration, call : Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression, callFrom : List.List String.String -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression, value : List.List String.String -> Elm.Expression }"},{"name":"fn4","comment":" ","type":"String.String -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> (Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> { declaration : Elm.Declaration, call : Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression, callFrom : List.List String.String -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression, value : List.List String.String -> Elm.Expression }"},{"name":"fn5","comment":" ","type":"String.String -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> (Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> { declaration : Elm.Declaration, call : Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression, callFrom : List.List String.String -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression, value : List.List String.String -> Elm.Expression }"},{"name":"fn6","comment":" ","type":"String.String -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> (Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> { declaration : Elm.Declaration, call : Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression, callFrom : List.List String.String -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression, value : List.List String.String -> Elm.Expression }"},{"name":"function","comment":" ","type":"String.String -> List.List ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> (List.List Elm.Expression -> Elm.Expression) -> { declaration : Elm.Declaration, call : List.List Elm.Expression -> Elm.Expression, callFrom : List.List String.String -> List.List Elm.Expression -> Elm.Expression, value : List.List String.String -> Elm.Expression }"},{"name":"value","comment":" ","type":"String.String -> Elm.Expression -> { declaration : Elm.Declaration, value : Elm.Expression, valueFrom : List.List String.String -> Elm.Expression }"}],"binops":[]},{"name":"Elm.Let","comment":" This module is for building `let` expressions.\n\n@docs letIn, value, Let\n\nHere's a brief example to get you started\n\n    Elm.Let.letIn\n        (\\one two ->\n            Elm.Op.append one two\n        )\n        |> Elm.Let.value \"one\" (Elm.string \"Hello\")\n        |> Elm.Let.value \"two\" (Elm.string \"World!\")\n        |> Elm.Let.toExpression\n\nWill translate into\n\n    let\n        one =\n            \"Hello!\"\n\n        two =\n            \"World\"\n    in\n    one ++ two\n\n\n# Destructing values\n\n@docs tuple\n\nHere's an example destructing a tuple. This code\n\n    Elm.Let.letIn\n        (\\( first, second ) ->\n            Elm.Op.append first second\n        )\n        |> Elm.Let.tuple \"first\" \"second\" (Elm.tuple (Elm.string \"Hello\") (Elm.string \"World!\"))\n        |> Elm.Let.toExpression\n\nWill generate\n\n    let\n        ( first, second ) =\n            ( \"Hello\", \"World!\" )\n    in\n    first ++ second\n\n@docs record\n\nAnd extracting fields from a record.\n\n    Elm.Let.letIn\n        (\\fields ->\n            case fields of\n                [ first, second ] ->\n                    Elm.Op.append first second\n\n                _ ->\n                    Elm.unit\n        )\n        |> Elm.Let.record [ \"first\", \"second\" ]\n            (Elm.record\n                [ ( \"first\", Elm.string \"Hello\" )\n                , ( \"second\", Elm.string \"world!\" )\n                ]\n            )\n        |> Elm.Let.toExpression\n\nWill generate:\n\n    let\n        { first, second } =\n            { first = \"Hello\", second = \"world!\" }\n    in\n    first ++ second\n\n\n# Functions\n\nHere's an example of declaring functions in a let expression:\n\n    Elm.Let.letIn\n        (\\myFn ->\n            myFn (Elm.bool True)\n        )\n        |> Elm.Let.fn \"myFn\"\n            ( \"arg\", Just Type.bool )\n            (\\arg ->\n                Elm.ifThen arg\n                    (Elm.string \"True\")\n                    (Elm.string \"False\")\n            )\n        |> Elm.Let.toExpression\n\nwill generate\n\n    let\n        myFn arg =\n            if arg then\n                \"True\"\n\n            else\n                \"False\"\n    in\n    myFn True\n\n@docs fn, fn2, fn3\n\n\n# Converting to an Expression\n\n@docs toExpression\n\n","unions":[{"name":"Let","comment":" ","args":["a"],"cases":[]}],"aliases":[],"values":[{"name":"fn","comment":" ","type":"String.String -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> (Elm.Expression -> Elm.Expression) -> Elm.Let.Let ((Elm.Expression -> Elm.Expression) -> a) -> Elm.Let.Let a"},{"name":"fn2","comment":" ","type":"String.String -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> (Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Let.Let ((Elm.Expression -> Elm.Expression -> Elm.Expression) -> a) -> Elm.Let.Let a"},{"name":"fn3","comment":" ","type":"String.String -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> (Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Let.Let ((Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> a) -> Elm.Let.Let a"},{"name":"letIn","comment":" ","type":"a -> Elm.Let.Let a"},{"name":"record","comment":" ","type":"List.List String.String -> Elm.Expression -> Elm.Let.Let (List.List Elm.Expression -> a) -> Elm.Let.Let a"},{"name":"toExpression","comment":" ","type":"Elm.Let.Let Elm.Expression -> Elm.Expression"},{"name":"tuple","comment":" ","type":"String.String -> String.String -> Elm.Expression -> Elm.Let.Let (( Elm.Expression, Elm.Expression ) -> a) -> Elm.Let.Let a"},{"name":"value","comment":" ","type":"String.String -> Elm.Expression -> Elm.Let.Let (Elm.Expression -> a) -> Elm.Let.Let a"}],"binops":[]},{"name":"Elm.Op","comment":" This module helps generate operators!\n\nSo, this\n\n    Elm.Op.equal (Elm.bool True) (Elm.bool False)\n\nWould generate\n\n    True == False\n\n\n## Equality\n\n@docs equal, notEqual, and, or\n\n\n## Lists and strings\n\n@docs append, cons\n\n\n## Math\n\n@docs plus, minus, multiply, divide, intDivide, power\n\n\n## Comparisons\n\n@docs lt, gt, lte, gte\n\n@docs pipe\n\n@docs parens\n\n\n## Parsing\n\n@docs keep, skip\n\n\n## Url parsing\n\n@docs slash, query\n\n","unions":[],"aliases":[],"values":[{"name":"and","comment":" `&&`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"append","comment":" `++`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"cons","comment":" `::`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"divide","comment":" `/`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"equal","comment":" `==`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"gt","comment":" `>`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"gte","comment":" `>=`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"intDivide","comment":" `//`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"keep","comment":" used in the `elm/parser` library\n\n`|=`\n\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"lt","comment":" `<`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"lte","comment":" `<=`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"minus","comment":" `-`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"multiply","comment":" `*`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"notEqual","comment":" `/=`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"or","comment":" `||`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"parens","comment":" Wrap an expression in parentheses.\n\nGenerally you won't need this as `elm-codegen` handles parens for you, but it can be useful to semantically group operations from this module.\n\n","type":"Elm.Expression -> Elm.Expression"},{"name":"pipe","comment":" `|>`\n\n    Elm.value \"thang\"\n        |> Elm.Op.pipe (Elm.value \"thang2\")\n        |> Elm.Op.pipe (Elm.value \"thang3\")\n\nResults in\n\n    thang\n        |> thang2\n        |> thang3\n\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"plus","comment":" `+`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"power","comment":" The to-the-power-of operator `^`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"query","comment":" `<?>` used in url parsing\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"skip","comment":" `|.`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"slash","comment":" `</>` used in url parsing\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"}],"binops":[]},{"name":"Elm.ToString","comment":" Convert values to a string!\n\nThis can be useful if you're generating examples or just playing with the library and want to get an intuition for it.\n\n@docs expression, annotation, declaration\n\n\n## With Import Aliases\n\nIf you want further control over import aliases,\n\n@docs expressionWith, annotationWith, declarationWith\n\n","unions":[],"aliases":[],"values":[{"name":"annotation","comment":" ","type":"Elm.Annotation.Annotation -> { imports : String.String, signature : String.String }"},{"name":"annotationWith","comment":" ","type":"{ aliases : List.List ( List.List String.String, String.String ) } -> Elm.Annotation.Annotation -> { imports : String.String, signature : String.String }"},{"name":"declaration","comment":" ","type":"Elm.Declaration -> { imports : String.String, docs : String.String, signature : String.String, body : String.String }"},{"name":"declarationWith","comment":" ","type":"{ aliases : List.List ( List.List String.String, String.String ) } -> Elm.Declaration -> { imports : String.String, docs : String.String, signature : String.String, body : String.String }"},{"name":"expression","comment":" ","type":"Elm.Expression -> { imports : String.String, body : String.String, signature : String.String }"},{"name":"expressionWith","comment":" ","type":"{ aliases : List.List ( List.List String.String, String.String ) } -> Elm.Expression -> { imports : String.String, body : String.String, signature : String.String }"}],"binops":[]}]