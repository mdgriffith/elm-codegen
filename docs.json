[{"name":"Elm","comment":"\n\n@docs File, file\n\n\n## Basics\n\n@docs Expression, toString\n\n@docs bool, int, float, char, string, hex, unit\n\n@docs maybe, just, nothing\n\n@docs list, tuple, triple\n\n@docs withType\n\n\n## Records\n\n@docs record, get, updateRecord\n\n\n## Flow control\n\n@docs ifThen\n\n**Note** If you need `let` or `case` expressions, check out the docs for [`Elm.Let`](./Elm-Let) or [`Elm.Case`](./Elm-Case)!\n\n\n## Declarations\n\nA `Declaration` is anything that is at the \"top level\" of your file, meaning all values with no indentation.\n\n@docs Declaration\n\n@docs comment, docs, declaration\n\n@docs withDocumentation, group\n\n@docs expose, exposeConstructor\n\n@docs fileWith\n\n\n## Functions\n\n@docs fn, fn2, fn3\n\n@docs fnBuilder, fnArg, Arg, fnDone, body, Fn\n\n@docs function, functionReduced\n\n\n## Custom Types\n\n@docs customType, customTypeWith, Variant, variant, variantWith\n\n@docs alias, aliasWith\n\n\n# Ports\n\n@docs portIncoming, portOutgoing\n\n\n# Parsing existing Elm\n\n@docs parse, unsafe\n\n\n# Low-level\n\n@docs apply, val, value\n\n@docs unwrap, unwrapper\n\n","unions":[{"name":"Fn","comment":" ","args":["value"],"cases":[]},{"name":"Variant","comment":" ","args":[],"cases":[]}],"aliases":[{"name":"Arg","comment":" Check out the `Elm.Arg` module for more information on how to create one of these.\n","args":["val"],"type":"Internal.Arg.Arg val"},{"name":"Declaration","comment":" ","args":[],"type":"Internal.Compiler.Declaration"},{"name":"Expression","comment":" ","args":[],"type":"Internal.Compiler.Expression"},{"name":"File","comment":" ","args":[],"type":"{ path : String.String, contents : String.String, warnings : List.List { declaration : String.String, warning : String.String } }"}],"values":[{"name":"alias","comment":" A type alias declaration.\n\n    import Elm.Annotation as Type\n\n    Elm.alias \"MyAlias\"\n        (Type.record\n            [ ( \"one\", Type.string )\n            , ( \"two\", Type.int )\n            , ( \"three\", Type.var \"content\" )\n            ]\n        )\n\nShould result in\n\n    type alias MyAlias content =\n        { one : String\n        , two : Int\n        , three : content\n        }\n\n","type":"String.String -> Elm.Annotation.Annotation -> Elm.Declaration"},{"name":"aliasWith","comment":" A type alias declaration, with the ability to specify in which order to put the type variables.\n\n    import Elm.Annotation as Type\n\n    Elm.aliasWith \"MyAlias\" [ \"twoVar\", \"nonexistingVar\", \"oneVar\" ]\n        (Type.record\n            [ ( \"one\", Type.var \"oneVar\" )\n            , ( \"two\", Type.var \"twoVar\" )\n            , ( \"three\", Type.var \"threeVar\" )\n            ]\n        )\n\nShould result in\n\n    type alias MyAlias twoVar oneVar threeVar =\n        { one : oneVar\n        , two : twoVar\n        , three : threeVar\n        }\n\nNotice how nonexisting variables are omitted, and missing variable are automatically added.\n\n","type":"String.String -> List.List String.String -> Elm.Annotation.Annotation -> Elm.Declaration"},{"name":"apply","comment":" ","type":"Elm.Expression -> List.List Elm.Expression -> Elm.Expression"},{"name":"body","comment":" `body` allows you to define the funciton body _after_ defining the args.\n\nSo, normally, we'd have this.\n\n    Elm.fnBuilder\n        (\\arg1 arg2 ->\n            Elm.Op.plus arg1 arg2\n        )\n        |> Elm.fnArg (Elm.Arg.var \"arg1\")\n        |> Elm.fnArg (Elm.Arg.var \"arg2\")\n        |> Elm.fnDone\n\nBut, that's sorta weird because you're defining the body before the args.\n\nYou can also do this:\n\n    Elm.fnBuilder Tuple.pair\n        |> Elm.fnArg (Elm.Arg.var \"arg1\")\n        |> Elm.fnArg (Elm.Arg.var \"arg2\")\n        |> Elm.body\n            (\\( arg1, arg2 ) ->\n                Elm.Op.plus arg1 arg2\n            )\n\nWhich more closely mirrors the way you'd write a function in Elm.\n\nThe downside is that you need to capture the arguments in a data strucutre(in this example, we used `Tuple.pair`).\n\n","type":"(args -> Elm.Expression) -> Elm.Fn args -> Elm.Expression"},{"name":"bool","comment":" ","type":"Basics.Bool -> Elm.Expression"},{"name":"char","comment":" ","type":"Char.Char -> Elm.Expression"},{"name":"comment","comment":" Renders a multiline comment.\n\n    Elm.comment \"\"\"Here is my comment!\"\"\"\n\nWill generate\n\n\n\n    {- Here is my comment! -}\n\n","type":"String.String -> Elm.Declaration"},{"name":"customType","comment":" A custom type declaration.\n\n    Elm.customType \"MyType\"\n        [ Elm.variant \"One\"\n        , Elm.variantWith \"Two\"\n            [ Elm.Annotation.list Elm.Annotation.string ]\n        ]\n\nWill result in\n\n    type MyType\n        = One\n        | Two (List String)\n\n","type":"String.String -> List.List Elm.Variant -> Elm.Declaration"},{"name":"customTypeWith","comment":" A custom type declaration, with the ability to specify in which order to put the type variables.\n\n    Elm.customTypeWith \"MyType\"\n        [ \"addVar\", \"twoVar\" ]\n        [ Elm.variantWith \"One\"\n            [ Elm.Annotation.var \"oneVar\" ]\n        , Elm.variantWith \"Two\"\n            [ Elm.Annotation.var \"twoVar\" ]\n        ]\n\nWill result in\n\n    type MyType addVar twoVar oneVar\n        = One oneVar\n        | Two twoVar\n\nNotice how nonexisting variables (as used in phantom types) are included, and missing variable are automatically added.\n\n","type":"String.String -> List.List String.String -> List.List Elm.Variant -> Elm.Declaration"},{"name":"declaration","comment":" ","type":"String.String -> Elm.Expression -> Elm.Declaration"},{"name":"docs","comment":" This will include some markdown in the module doc comment.\n","type":"String.String -> Elm.Declaration"},{"name":"expose","comment":" By default, everything is exposed for your module.\n\nHowever, you can tag specific declarations you want exposed, and then only those things will be exposed.\n\n","type":"Elm.Declaration -> Elm.Declaration"},{"name":"exposeConstructor","comment":" ","type":"Elm.Declaration -> Elm.Declaration"},{"name":"file","comment":" Build a file!\n\n    Elm.file [ \"My\", \"Module\" ]\n        [ Elm.declaration \"placeholder\"\n            (Elm.string \"a fancy string!\")\n        ]\n\n","type":"List.List String.String -> List.List Elm.Declaration -> Elm.File"},{"name":"fileWith","comment":" Same as [file](#file), but you have more control over how the module comment is generated!\n\nPass in a function that determines how to render a `@docs` comment.\n\nEach exposed item is grouped using [group](#group).\n\n**aliases** allow you to specify a module alias to be used.\n\n    Elm.fileWith [ \"MyModule\" ]\n        { docs = \"# Here's my cool module!\"\n        , aliases =\n            [ ( [ \"Json\", \"Encode\" ], \"Encode\" )\n            ]\n        }\n        [-- whatever declarations you desire.\n        ]\n\nwould make an import statement like\n\n    import Json.Encode as Encode\n\nAll values rendered in this file that are from this module would also automatically respect this alias as well.\n\n","type":"List.List String.String -> { docs : String.String, aliases : List.List ( List.List String.String, String.String ) } -> List.List Elm.Declaration -> Elm.File"},{"name":"float","comment":" ","type":"Basics.Float -> Elm.Expression"},{"name":"fn","comment":" Create a function with a single argument.\n\nThis may seem a little weird the first time you encounter it, so let's break it down.\n\nHere's what's happening for the `fn*` functions —\n\n  - The `String` arguments are the **names of the arguments** for the generated function.\n  - The attached `Maybe Annotation` is the type annotation. If you provide `Nothing`, then `elm-codegen` will infer the type for you!\n  - The `(Expression -> Expression)` function is where we're providing you an `Expression` that represents an argument coming in to the generated function.\n\nSo, this\n\n    Elm.fn (Elm.Arg.var \"firstInt\")\n        (\\firstArgument ->\n            Elm.Op.plus\n                (Elm.int 42)\n                firstArgument\n        )\n\nGenerates\n\n    \\firstInt -> 42 + firstInt\n\nIf you want to generate a **top level** function instead of an anonymous function, use `Elm.declaration`.\n\n    Elm.declaration \"add42\" <|\n        Elm.fn (Elm.Arg.var \"firstInt\")\n            (\\firstArgument ->\n                Elm.Op.plus\n                    (Elm.int 42)\n                    firstArgument\n            )\n\nResults in\n\n    add42 : Int -> Int\n    add42 firstInt =\n        42 + firstInt\n\n**Note** — Elm CodeGen will protect variable names if they're used in a nested `fn*` by adding a string of numbers to the end of the name. So, you may see a variable name be something like `myVariable_0_1`.\n\n","type":"Elm.Arg arg -> (arg -> Elm.Expression) -> Elm.Expression"},{"name":"fn2","comment":" ","type":"Elm.Arg one -> Elm.Arg two -> (one -> two -> Elm.Expression) -> Elm.Expression"},{"name":"fn3","comment":" ","type":"Elm.Arg one -> Elm.Arg two -> Elm.Arg three -> (one -> two -> three -> Elm.Expression) -> Elm.Expression"},{"name":"fnArg","comment":" ","type":"Elm.Arg arg -> Elm.Fn (arg -> value) -> Elm.Fn value"},{"name":"fnBuilder","comment":" Build a function with any number of arguments.\n\nHere's how you'd implement a function which adds two numbers together:\n\n    Elm.fnBuilder\n        (\\arg1 arg2 ->\n            Elm.Op.plus arg1 arg2\n        )\n        |> Elm.fnArg (Elm.Arg.var \"arg1\")\n        |> Elm.fnArg (Elm.Arg.var \"arg2\")\n        |> Elm.fnDone\n\n","type":"value -> Elm.Fn value"},{"name":"fnDone","comment":" ","type":"Elm.Fn Elm.Expression -> Elm.Expression"},{"name":"function","comment":" You may run into situations where you don't know the number of arguments for a function at compile-time.\n\nIn that case you can use `function`. It follows the same pattern as the `fn*` functions.\n\nProvide it with —\n\n  - A list of argument names and an optional type\n  - A function which will be given all the input arguments as `Expression`s.\n\n","type":"List.List ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> (List.List Elm.Expression -> Elm.Expression) -> Elm.Expression"},{"name":"functionReduced","comment":" This is a special case of function declaration which will _reduce_ itself if possible.\n\nMeaning, if this would generate the following code\n\n    \\myArg -> someOtherFunction myArg\n\nThen it will replace itself with just\n\n    someOtherFunction\n\n**Note** you likely won't need this! It's generally used by the package-helper generator, but that might be a relatively special case.\n\n","type":"String.String -> (Elm.Expression -> Elm.Expression) -> Elm.Expression"},{"name":"get","comment":"\n\n    record\n        |> Elm.get \"field\"\n\nresults in\n\n    record.field\n\n","type":"String.String -> Elm.Expression -> Elm.Expression"},{"name":"group","comment":" Group declarations in a module.\n\nThis will add a `@docs` tag to the module doc comment for any exposed functions in the group.\n\n    Elm.group\n        [ myFunction\n        , myOtherFunction\n        ]\n\nWill create the following module doc comment:\n\n    @docs myFunction, myOtherFunction\n\n","type":"List.List Elm.Declaration -> Elm.Declaration"},{"name":"hex","comment":" ","type":"Basics.Int -> Elm.Expression"},{"name":"ifThen","comment":"\n\n    ifThen (Elm.bool True)\n        (Elm.string \"yes\")\n        (Elm.string \"no\")\n\nWill generate\n\n    if True then\n        \"yes\"\n\n    else\n        \"no\"\n\nIf you need more than one branch, then chain them together!\n\n     Elm.ifThen (Elm.bool True)\n        (Elm.string \"yes\")\n        (Elm.ifThen (Elm.bool True)\n            (Elm.string \"maybe\")\n            (Elm.string \"no\")\n        )\n\nWill generate\n\n    if True then\n        \"yes\"\n\n    else if True then\n        \"maybe\"\n\n    else\n        \"no\"\n\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"int","comment":" ","type":"Basics.Int -> Elm.Expression"},{"name":"just","comment":" ","type":"Elm.Expression -> Elm.Expression"},{"name":"list","comment":" ","type":"List.List Elm.Expression -> Elm.Expression"},{"name":"maybe","comment":" ","type":"Maybe.Maybe Elm.Expression -> Elm.Expression"},{"name":"nothing","comment":" ","type":"Elm.Expression"},{"name":"parse","comment":" ","type":"String.String -> Result.Result String.String { declarations : List.List Elm.Declaration }"},{"name":"portIncoming","comment":"\n\n    import Elm.Annotation as Type\n\n    Elm.portIncoming \"receiveMessageFromTheWorld\"\n        [ Type.string\n        , Type.int\n        ]\n\nResults in\n\n    port receiveMessageFromTheWorld :\n        (String -> Int -> msg)\n        -> Sub msg\n\n**Note** You generally only need one incoming and one outgoing port!\n\nIf you want to vary the messages going in and out of your app, don't use a huge number of ports, instead write Json encoders and decoders.\n\nThis will give you more flexibility in the future and save you having to wire up a bunch of stuff.\n\n**Another note** - You may need to expose your port explicitly using [`Elm.expose`](#expose).\n\n","type":"String.String -> List.List Elm.Annotation.Annotation -> Elm.Declaration"},{"name":"portOutgoing","comment":" Create a port that can send messages to the outside world!\n\n    import Elm.Annotation as Type\n\n    Elm.portOutgoing \"tellTheWorld\" Type.string\n\nwill generate\n\n    port tellTheWorld : String -> Cmd msg\n\n","type":"String.String -> Elm.Annotation.Annotation -> Elm.Declaration"},{"name":"record","comment":"\n\n    Elm.record\n        [ ( \"name\", Elm.string \"Elm\" )\n        , ( \"designation\", Elm.string \"Pretty fabulous\" )\n        ]\n\n","type":"List.List ( String.String, Elm.Expression ) -> Elm.Expression"},{"name":"string","comment":" ","type":"String.String -> Elm.Expression"},{"name":"toString","comment":" See what code this expression would generate!\n\n**Note** - Check out the `Elm.ToString` module if this doesn't quite meet your needs!\n\n","type":"Elm.Expression -> String.String"},{"name":"triple","comment":" ","type":"Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"tuple","comment":" ","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"unit","comment":" ","type":"Elm.Expression"},{"name":"unsafe","comment":" This will insert the given string into your generated file.\n\nCheck out the [using packages/helpers guide](https://github.com/mdgriffith/elm-codegen/tree/main/guide/UsingHelpers.md). If you're reaching for this, it's likely you'd be better off using a local helper file!\n\n","type":"String.String -> Elm.Declaration"},{"name":"unwrap","comment":" Unwraps a single-variant type\n\n    Elm.declaration \"myFunction\" <|\n        Elm.fn \"val\"\n            (\\val ->\n                Elm.unwrap \"MyType\" val\n            )\n\nResults in the following lambda\n\n    myFunction val =\n        (\\(MyType val) -> val) val\n\n","type":"List.List String.String -> String.String -> Elm.Expression -> Elm.Expression"},{"name":"unwrapper","comment":" Generate a lambda which unwraps a single-variant type.\n\n    Elm.unwrapper [ \"MyModule\" ] \"MyType\"\n\nResults in the following lambda\n\n    \\(MyModule.MyType val) -> val\n\n","type":"List.List String.String -> String.String -> Elm.Expression"},{"name":"updateRecord","comment":"\n\n    myRecord\n        |> updateRecord\n            [ ( \"designation\", Elm.string \"Pretty fabulous\" )\n            ]\n\nResults in\n\n    { myRecord | designation = \"Pretty fabulous\" }\n\n","type":"List.List ( String.String, Elm.Expression ) -> Elm.Expression -> Elm.Expression"},{"name":"val","comment":" ","type":"String.String -> Elm.Expression"},{"name":"value","comment":" ","type":"{ importFrom : List.List String.String, name : String.String, annotation : Maybe.Maybe Elm.Annotation.Annotation } -> Elm.Expression"},{"name":"variant","comment":" ","type":"String.String -> Elm.Variant"},{"name":"variantWith","comment":" ","type":"String.String -> List.List Elm.Annotation.Annotation -> Elm.Variant"},{"name":"withDocumentation","comment":" Add a documentation comment to a declaration!\n","type":"String.String -> Elm.Declaration -> Elm.Declaration"},{"name":"withType","comment":" Sometimes you may need to add a manual type annotation.\n\n    import Elm.Annotation as Type\n\n    Elm.value\n        { importFrom = []\n        , name = \"myString\"\n        , annotation = Nothing\n        }\n        |> Elm.withType Type.string\n\nThough be sure `elm-codegen` isn't already doing this automatically for you!\n\n","type":"Elm.Annotation.Annotation -> Elm.Expression -> Elm.Expression"}],"binops":[]},{"name":"Elm.Annotation","comment":"\n\n@docs Annotation, var, bool, int, float, string, char, unit\n\n@docs cmd, sub\n\n@docs named, namedWith\n\n@docs maybe, list, tuple, triple, set, dict, result\n\n@docs record, extensible, alias\n\n@docs function\n\n@docs toString\n\n","unions":[],"aliases":[{"name":"Annotation","comment":" ","args":[],"type":"Internal.Compiler.Annotation"}],"values":[{"name":"alias","comment":" The classic example of a Model\n\n    Elm.Annotation.alias []\n        \"Model\"\n        []\n        (Elm.Annotation.record\n            [ ( \"hello\", Elm.Annotation.string ) ]\n        )\n\nwould correspond to\n\n    type alias Model =\n        { hello : String\n        }\n\n","type":"List.List String.String -> String.String -> List.List Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"bool","comment":" ","type":"Elm.Annotation.Annotation"},{"name":"char","comment":" ","type":"Elm.Annotation.Annotation"},{"name":"cmd","comment":" ","type":"Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"dict","comment":" ","type":"Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"extensible","comment":" ","type":"String.String -> List.List ( String.String, Elm.Annotation.Annotation ) -> Elm.Annotation.Annotation"},{"name":"float","comment":" ","type":"Elm.Annotation.Annotation"},{"name":"function","comment":" ","type":"List.List Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"int","comment":" ","type":"Elm.Annotation.Annotation"},{"name":"list","comment":" ","type":"Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"maybe","comment":" ","type":"Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"named","comment":" ","type":"List.List String.String -> String.String -> Elm.Annotation.Annotation"},{"name":"namedWith","comment":" ","type":"List.List String.String -> String.String -> List.List Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"record","comment":" ","type":"List.List ( String.String, Elm.Annotation.Annotation ) -> Elm.Annotation.Annotation"},{"name":"result","comment":" ","type":"Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"set","comment":" ","type":"Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"string","comment":" ","type":"Elm.Annotation.Annotation"},{"name":"sub","comment":" ","type":"Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"toString","comment":" ","type":"Elm.Annotation.Annotation -> String.String"},{"name":"triple","comment":" ","type":"Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"tuple","comment":" ","type":"Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"unit","comment":" ","type":"Elm.Annotation.Annotation"},{"name":"var","comment":" A type variable\n","type":"String.String -> Elm.Annotation.Annotation"}],"binops":[]},{"name":"Elm.Arg","comment":" An `Arg` can be used to pattern match on the arguments of a function.\n\n    let\n        args =\n            Elm.Arg.tuple (Arg.var \"first\") (Arg.var \"second\")\n    in\n    Elm.fn args\n        (\\( first, second ) ->\n            Elm.record\n                [ ( \"first\", first )\n                , ( \"second\", second )\n                ]\n        )\n\nWill generate\n\n    \\( first, second ) ->\n        { first = first\n        , second = second\n        }\n\nOr they can be used to unpack values in the branch of a case expression.\n\n    Elm.Case.custom (Elm.val \"myVar\") (Elm.Annotation.named [] \"MyCustomType)\n        [ Elm.branch \"MyCustomType\" (Arg.tuple (Arg.var \"first\") (Arg.var \"second\"))\n            (\\( first, second ) ->\n                Elm.record\n                    [ ( \"first\", first )\n                    , ( \"second\", second )\n                    ]\n            )\n        ]\n\nWill generate\n\n      case myVar of\n          MyCustomType first second ->\n              { first = first\n              , second = second\n              }\n\n@docs unit, var, varWith\n\n@docs tuple, triple\n\n@docs record, field\n\n@docs aliasAs\n\n\n## Useful for case expressions\n\n@docs ignore, string, char\n\n@docs list, item, items, listRemaining\n\n@docs customType\n\n","unions":[],"aliases":[],"values":[{"name":"aliasAs","comment":" Unpack a pattern, but keep a reference to the original value.\n\n    let\n        args =\n            Elm.Arg.customType \"MyCustomType\" Tuple.pair\n                |> Elm.Arg.item (Arg.var \"first\")\n                |> Elm.Arg.item (Arg.var \"second\")\n                |> Elm.Arg.aliasAs \"myAlias\"\n    in\n    Elm.fn args\n        (\\( ( first, second ), myAlias ) ->\n            Elm.record\n                [ ( \"first\", first )\n                , ( \"second\", second )\n                , ( \"myAlias\", myAlias )\n                ]\n        )\n\nWill generate\n\n    \\((MyCustomType first second) as myAlias) ->\n        { first = first\n        , second = second\n        , myAlias = myAlias\n        }\n\n","type":"String.String -> Elm.Arg arg -> Elm.Arg ( arg, Elm.Expression )"},{"name":"char","comment":" ","type":"Char.Char -> Elm.Arg Elm.Expression"},{"name":"customType","comment":" Let's say you have a custom type like\n\n    type MyCustomType\n        = MyCustomType String Int\n\nAnd you want to extract the String and Int\n\n    let\n        args =\n            Elm.Arg.customType \"MyCustomType\" Tuple.pair\n                |> Elm.Arg.item (Arg.var \"first\")\n                |> Elm.Arg.item (Arg.var \"second\")\n    in\n    Elm.fn args\n        (\\( first, second ) ->\n            Elm.record\n                [ ( \"first\", first )\n                , ( \"second\", second )\n                ]\n        )\n\nWhich will generate\n\n    \\(MyCustomType first second) ->\n        { first = first\n        , second = second\n        }\n\n","type":"String.String -> a -> Elm.Arg a"},{"name":"field","comment":" ","type":"String.String -> Elm.Arg (Elm.Expression -> a) -> Elm.Arg a"},{"name":"ignore","comment":" Will generate `_` to ignore an argument or pattern.\n","type":"Elm.Arg Elm.Expression"},{"name":"item","comment":" ","type":"Elm.Arg arg -> Elm.Arg (arg -> a) -> Elm.Arg a"},{"name":"items","comment":" This is for the situation where you only know the number of arguments when you run the generator.\n\nThis isn't super common.\n\n","type":"List.List (Elm.Arg arg) -> Elm.Arg (List.List arg -> a) -> Elm.Arg a"},{"name":"list","comment":"\n\n    Arg.list Tuple.pair\n        |> Arg.item (Arg.var \"first\")\n        |> Arg.item (Arg.var \"second\")\n\nWill genrate\n\n    [ first, second ]\n\nAnd\n\n     Arg.list\n        (\\one two remaining ->\n            { one = one\n            , two = two\n            , remaining = remaining\n            }\n        )\n        |> Arg.item (Arg.var \"first\")\n        |> Arg.item (Arg.var \"second\")\n        |> Arg.listRemaining \"remaining\"\n\nWill generate\n\n    first :: second :: remaining\n\n","type":"a -> Elm.Arg a"},{"name":"listRemaining","comment":" ","type":"String.String -> Elm.Arg (Elm.Expression -> a) -> Elm.Arg a"},{"name":"record","comment":" Unpack record fields.\n\n    let\n        args =\n            Elm.Arg.record\n                |> Elm.Arg.field \"first\" (Arg.var \"first\")\n                |> Elm.Arg.field \"second\" (Arg.var \"second\")\n    in\n    Elm.fn args\n        (\\{ first, second } ->\n            Elm.record\n                [ ( \"first\", first )\n                , ( \"second\", second )\n                ]\n        )\n\nWould generate\n\n    \\{ first, second } ->\n        { first = first\n        , second = second\n        }\n\n","type":"fields -> Elm.Arg fields"},{"name":"string","comment":" ","type":"String.String -> Elm.Arg Elm.Expression"},{"name":"triple","comment":" ","type":"Elm.Arg one -> Elm.Arg two -> Elm.Arg three -> Elm.Arg ( one, two, three )"},{"name":"tuple","comment":" ","type":"Elm.Arg one -> Elm.Arg two -> Elm.Arg ( one, two )"},{"name":"unit","comment":" An empty tuple `()` is generally called \"unit\".\n","type":"Elm.Arg Elm.Expression"},{"name":"var","comment":" ","type":"String.String -> Elm.Arg Elm.Expression"},{"name":"varWith","comment":" ","type":"String.String -> Elm.Annotation.Annotation -> Elm.Arg Elm.Expression"}],"binops":[]},{"name":"Elm.Case","comment":" Generate a case expression!\n\nHere's an example for extracting a `Maybe Int`\n\n    Elm.Case.maybe myMaybe\n        { nothing = Elm.int 0\n        , just =\n            ( \"value\"\n            , \\content ->\n                Elm.plus (Elm.int 5) content\n            )\n        }\n\nGenerates\n\n    case myMaybe of\n        Nothing ->\n            0\n\n        Just value ->\n            value + 5\n\n@docs maybe, result, string\n\n\n## Case on a Custom Type\n\n    Elm.Case.custom maybeString\n        (Elm.Annotation.maybe Elm.Annotation.string)\n        [ Elm.Case.branch (Elm.Arg.customType \"Nothing\" ())\n            (\\_ ->\n                Elm.string \"It's nothing, I swear!\"\n            )\n        , Elm.Case.branch\n            (Elm.Arg.customType \"Just\" identity\n                |> Arg.item (Arg.var \"val\")\n            )\n            (\\val ->\n                Elm.append (Elm.string \"Actually, it's: \") val\n            )\n        ]\n\nGenerates\n\n    case maybeString of\n        Nothing ->\n            \"It's nothing, I swear!\"\n\n        Just just ->\n            \"Actually, it's: \" ++ just\n\n@docs custom\n\n@docs Branch, branch\n\n","unions":[],"aliases":[{"name":"Branch","comment":" ","args":[],"type":"Internal.Branch.Branch"}],"values":[{"name":"branch","comment":" ","type":"Elm.Arg val -> (val -> Elm.Expression) -> Elm.Case.Branch"},{"name":"custom","comment":" ","type":"Elm.Expression -> Elm.Annotation.Annotation -> List.List Elm.Case.Branch -> Elm.Expression"},{"name":"maybe","comment":" ","type":"Elm.Expression -> { nothing : Elm.Expression, just : ( String.String, Elm.Expression -> Elm.Expression ) } -> Elm.Expression"},{"name":"result","comment":"\n\n    Elm.Case.result myResult\n        { ok =\n            Tuple.pair \"ok\" <|\n                \\ok ->\n                    Elm.string \"No errors\"\n        , err =\n            Tuple.pair \"err\" <|\n                \\err ->\n                    err\n        }\n\nGenerates\n\n    case myResult of\n        Ok ok ->\n            \"No errors\"\n\n        Err err ->\n            err\n\n","type":"Elm.Expression -> { err : ( String.String, Elm.Expression -> Elm.Expression ), ok : ( String.String, Elm.Expression -> Elm.Expression ) } -> Elm.Expression"},{"name":"string","comment":" ","type":"Elm.Expression -> { cases : List.List ( String.String, Elm.Expression ), otherwise : Elm.Expression } -> Elm.Expression"}],"binops":[]},{"name":"Elm.Declare","comment":" You may run into situations where you want to generate a function, and then call that generated function somewhere else.\n\nThis module will help you do that.\n\nHere's an example, let's define a new function called `add42`\n\n    import Elm.Arg as Arg\n    import Elm.Declare as Declare\n\n    renderFile =\n        let\n            add42 =\n                Declare.fn \"add42\"\n                    (Arg.value \"firstInt\")\n                    (\\firstArgument ->\n                        Elm.plus\n                            (Elm.int 42)\n                            firstArgument\n                    )\n        in\n        Elm.file [ \"MyFile\" ]\n            -- add our declaration to our file\n            [ add42.declaration\n\n            -- and another place where we call that function!\n            , Elm.declaration \"mySweetNumber\"\n                (add42.call (Elm.int 82))\n            ]\n\n@docs Function, fn, fn2, fn3, fn4, fn5, fn6\n\n@docs withDocumentation\n\n@docs fnBuilder, fnArg, fnDone, fnBody, placeholder\n\n@docs Value, value\n\n@docs function\n\n\n# Virtual Modules\n\nIt's very common to have some modules that you both need to _generate_ and _use_ in your generated Elm code.\n\nHere's an example, let's define a new module called `MyModule`:\n\n    import Elm\n    import Elm.Annotation\n    import Elm.Declare\n    import Elm.Op\n\n    type alias MyModule =\n        { runCalculation : Elm.Expression -> Elm.Expression\n        , myType : Elm.Annotation.Annotation\n        }\n\n    myModule =\n        Elm.Declare.module_ [ \"MyModule\" ] MyModule\n            |> Elm.Declare.with\n                (Elm.Declare.fn \"runCalculation\"\n                    (Elm.Arg.var \"input\")\n                    (\\input -> Elm.Op.plus input (Elm.int 42))\n                )\n            |> Elm.Declare.with\n                (Elm.Declare.customType \"MyType\"\n                    [ Elm.variant \"One\"\n                    , Elm.variant \"Two\"\n                    ]\n                )\n\nOnce we've declared our module, we can do 2 things.\n\nFirst, we can generate the Elm code for the module:\n\n    Elm.toFile myModule\n\nOr we can include it in another module:\n\n    Elm.file [ \"MyInternalFile\" ]\n        [ Elm.include myModule\n\n        --... Whatever other declarations you want in this file.\n        ]\n\nSecondly, we can use the virtual module in our Elm code:\n\n    myModule.call.runCalculation (Elm.int 42)\n\nWhich will generate\n\n    MyModule.runCalculation 42\n\nAnd handle the imports and everything.\n\n@docs Module, module_, with, withUnexposed\n\n@docs Annotation, alias, customType\n\n@docs toFile, include, withSubmodule\n\n\n## Advanced Custom Types\n\nIn some cases you may want to generate a custom type and also have some helpers to\n\n1.  Create an instance of that type\n2.  Pattern match on that type\n\n`customTypeAdvanced` is a helper function that will let you do that!\n\nBut it does get a little involved, so if you don't need it, trying something simpler may be the way to go.\n\nAs an example, here's how to create a helper for the `Maybe` type.\n\n    maybe =\n        Elm.Declare.customTypeAdvanced \"Maybe\"\n            { exposeConstructor = True }\n            (\\nothing just ->\n                { nothing = nothing\n                , just = just\n                }\n            )\n            |> Elm.Declare.variant0 \"Nothing\" .nothing\n            |> Elm.Declare.variant1 \"Just\" (Elm.Annotation.var \"a\") .just\n            |> Elm.Declare.finishCustomType\n\n    -- Which then allows you to create an instance of the type via\n    maybe.make_.just (Elm.int 42)\n    -- Which would generate `Just 42`\n\n    -- And if you want to use it as a case expression, you can do this:\n\n    maybe.case_ (Elm.val \"a\")\n        { just = \\a -> a\n        , nothing = Elm.string \"\"\n        }\n\n    -- Which would generate\n    case a of\n       Just a -> a\n       Nothing -> \"\"\n\n@docs customTypeAdvanced, CustomType\n\n@docs variant0, variant1, variant2, variant3, variant4\n\n@docs CustomTypeBuilder, customVariant, finishCustomType\n\n\n## Internal things\n\n@docs Internal\n\n","unions":[{"name":"CustomTypeBuilder","comment":" ","args":["case_","make_"],"cases":[]},{"name":"Internal","comment":" You can safely ignore this type. It's used internally for some type bookkeeping, but you should never have it in your type signatures or anything.\n","args":["val"],"cases":[]}],"aliases":[{"name":"Annotation","comment":" ","args":[],"type":"{ annotation : Elm.Annotation.Annotation, declaration : Elm.Declaration, internal : Elm.Declare.Internal Elm.Annotation.Annotation }"},{"name":"CustomType","comment":" ","args":["make_"],"type":"{ declaration : Elm.Declaration, annotation : Elm.Annotation.Annotation, make_ : make_, case_ : Elm.Expression -> make_ -> Elm.Expression, internal : Elm.Declare.Internal { annotation : Elm.Annotation.Annotation, make_ : make_, case_ : Elm.Expression -> make_ -> Elm.Expression } }"},{"name":"Function","comment":" ","args":["tipe"],"type":"{ call : tipe, value : Elm.Expression, declaration : Elm.Declaration, internal : Elm.Declare.Internal tipe }"},{"name":"Module","comment":" ","args":["val"],"type":"{ name : List.List String.String, declarations : List.List Elm.Declaration, call : val }"},{"name":"Value","comment":" ","args":[],"type":"{ value : Elm.Expression, declaration : Elm.Declaration, internal : Elm.Declare.Internal Elm.Expression }"}],"values":[{"name":"alias","comment":" ","type":"String.String -> Elm.Annotation.Annotation -> Elm.Declare.Annotation"},{"name":"customType","comment":" ","type":"String.String -> List.List Elm.Variant -> Elm.Declare.Annotation"},{"name":"customTypeAdvanced","comment":" ","type":"String.String -> { exposeConstructor : Basics.Bool } -> make_ -> Elm.Declare.CustomTypeBuilder case_ make_"},{"name":"customVariant","comment":" ","type":"String.String -> List.List Elm.Annotation.Annotation -> (case_ -> branch) -> (Elm.Arg branch -> Elm.Arg Elm.Expression) -> ((List.List Elm.Expression -> Elm.Expression) -> previousMake_ -> make_) -> Elm.Declare.CustomTypeBuilder case_ previousMake_ -> Elm.Declare.CustomTypeBuilder case_ make_"},{"name":"finishCustomType","comment":" ","type":"Elm.Declare.CustomTypeBuilder make_ make_ -> Elm.Declare.CustomType make_"},{"name":"fn","comment":" ","type":"String.String -> Elm.Arg value -> (value -> Elm.Expression) -> Elm.Declare.Function (Elm.Expression -> Elm.Expression)"},{"name":"fn2","comment":" ","type":"String.String -> Elm.Arg one -> Elm.Arg two -> (one -> two -> Elm.Expression) -> Elm.Declare.Function (Elm.Expression -> Elm.Expression -> Elm.Expression)"},{"name":"fn3","comment":" ","type":"String.String -> Elm.Arg one -> Elm.Arg two -> Elm.Arg three -> (one -> two -> three -> Elm.Expression) -> Elm.Declare.Function (Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression)"},{"name":"fn4","comment":" ","type":"String.String -> Elm.Arg one -> Elm.Arg two -> Elm.Arg three -> Elm.Arg four -> (one -> two -> three -> four -> Elm.Expression) -> Elm.Declare.Function (Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression)"},{"name":"fn5","comment":" ","type":"String.String -> Elm.Arg one -> Elm.Arg two -> Elm.Arg three -> Elm.Arg four -> Elm.Arg five -> (one -> two -> three -> four -> five -> Elm.Expression) -> Elm.Declare.Function (Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression)"},{"name":"fn6","comment":" ","type":"String.String -> Elm.Arg one -> Elm.Arg two -> Elm.Arg three -> Elm.Arg four -> Elm.Arg five -> Elm.Arg six -> (one -> two -> three -> four -> five -> six -> Elm.Expression) -> Elm.Declare.Function (Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression)"},{"name":"fnArg","comment":" ","type":"Elm.Arg arg -> { name : String.String, builder : Elm.Fn (arg -> value), call : Elm.Expression -> List.List Elm.Expression -> e } -> { name : String.String, builder : Elm.Fn value, call : Elm.Expression -> List.List Elm.Expression -> Elm.Expression -> e }"},{"name":"fnBody","comment":" ","type":"(args -> Elm.Expression) -> { name : String.String, builder : Elm.Fn args, call : Elm.Expression -> List.List Elm.Expression -> res } -> Elm.Declare.Function res"},{"name":"fnBuilder","comment":" ","type":"String.String -> res -> { name : String.String, builder : Elm.Fn res, call : Elm.Expression -> List.List Elm.Expression -> Elm.Expression }"},{"name":"fnDone","comment":" ","type":"{ name : String.String, builder : Elm.Fn Elm.Expression, call : Elm.Expression -> List.List Elm.Expression -> res } -> Elm.Declare.Function res"},{"name":"function","comment":" ","type":"String.String -> List.List ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> (List.List Elm.Expression -> Elm.Expression) -> Elm.Declare.Function (List.List Elm.Expression -> Elm.Expression)"},{"name":"include","comment":" Include a module as a declaration in another module.\n\n**Note** - Be aware that the modulename of the included module must match the module name of the module you're including it in!\n\n","type":"Elm.Declare.Module val -> Elm.Declaration"},{"name":"module_","comment":" ","type":"List.List String.String -> val -> Elm.Declare.Module val"},{"name":"placeholder","comment":" You may want a placeholder function body if you're defining a function using `Declare` with the intention of _calling_ the function instead of defining it.\n\nIn that case you can use `placeholder`!\n\nOf note, if you generate the actual body of `placeholder`, it'll generate `Debug.todo \"Placeholder function body\"`.\n\n","type":"Elm.Expression"},{"name":"toFile","comment":" ","type":"Elm.Declare.Module val -> Elm.File"},{"name":"value","comment":" ","type":"String.String -> Elm.Expression -> Elm.Declare.Value"},{"name":"variant0","comment":" ","type":"String.String -> (case_ -> Elm.Expression) -> Elm.Declare.CustomTypeBuilder case_ (Elm.Expression -> make_) -> Elm.Declare.CustomTypeBuilder case_ make_"},{"name":"variant1","comment":" ","type":"String.String -> (case_ -> Elm.Expression -> Elm.Expression) -> Elm.Annotation.Annotation -> Elm.Declare.CustomTypeBuilder case_ ((Elm.Expression -> Elm.Expression) -> make_) -> Elm.Declare.CustomTypeBuilder case_ make_"},{"name":"variant2","comment":" ","type":"String.String -> (case_ -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Declare.CustomTypeBuilder case_ ((Elm.Expression -> Elm.Expression -> Elm.Expression) -> make_) -> Elm.Declare.CustomTypeBuilder case_ make_"},{"name":"variant3","comment":" ","type":"String.String -> (case_ -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Declare.CustomTypeBuilder case_ ((Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> make_) -> Elm.Declare.CustomTypeBuilder case_ make_"},{"name":"variant4","comment":" ","type":"String.String -> (case_ -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Declare.CustomTypeBuilder case_ ((Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> make_) -> Elm.Declare.CustomTypeBuilder case_ make_"},{"name":"with","comment":" ","type":"{ a | declaration : Elm.Declaration, internal : Elm.Declare.Internal required } -> Elm.Declare.Module (required -> val) -> Elm.Declare.Module val"},{"name":"withDocumentation","comment":" Add documentation to a function or value declared using this module.\n","type":"String.String -> { a | declaration : Elm.Declaration } -> { a | declaration : Elm.Declaration }"},{"name":"withSubmodule","comment":" Add a module as a \"submodule\".\n\nThis can be useful for organizing particularly complex modules.\n\nThe only thing to be aware of here is that the module name for both of these modules must be the same or you're going to have a bad time.\n\n","type":"Elm.Declare.Module submod -> Elm.Declare.Module (submod -> mod) -> Elm.Declare.Module mod"},{"name":"withUnexposed","comment":" ","type":"{ a | declaration : Elm.Declaration } -> Elm.Declare.Module val -> Elm.Declare.Module val"}],"binops":[]},{"name":"Elm.Let","comment":" This module is for building `let` expressions.\n\n@docs letIn, value, unpack, Let\n\nHere's a brief example to get you started\n\n    import Elm\n    import Elm.Let as Let\n\n    Let.letIn\n        (\\one two ->\n            Elm.Op.append one two\n        )\n        |> Let.value \"one\" (Elm.string \"Hello\")\n        |> Let.value \"two\" (Elm.string \"World!\")\n        |> Let.toExpression\n\nWill translate into\n\n    let\n        one =\n            \"Hello!\"\n\n        two =\n            \"World\"\n    in\n    one ++ two\n\n\n# Destructing values\n\nHere's an example destructing a tuple. This code\n\n    import Elm\n    import Elm.Let as Let\n    import Elm.Arg as Arg\n\n\n    Let.letIn\n        (\\( first, second ) ->\n            Elm.Op.append first second\n        )\n        |> Let.unpack\n            (Arg.tuple\n                (Arg.var \"first\")\n                (Arg.var \"second\")\n            )\n            (Elm.tuple\n                (Elm.string \"Hello\")\n                (Elm.string \"World!\")\n            )\n        |> Let.toExpression\n\nWill generate\n\n    let\n        ( first, second ) =\n            ( \"Hello\", \"World!\" )\n    in\n    first ++ second\n\nAnd extracting fields from a record.\n\n    import Elm\n    import Elm.Let as Let\n    import Elm.Arg as Arg\n\n    Let.letIn\n        (\\{first, second } ->\n            Elm.Op.append first second\n        )\n        |> Let.unpack\n            (Arg.record (\\first second -> {first, second})\n            |> Arg.field \"first\"\n            |> Arg.field \"second\"\n\n            )\n            (Elm.record\n                [ ( \"first\", Elm.string \"Hello\" )\n                , ( \"second\", Elm.string \"world!\" )\n                ]\n            )\n        |> Let.toExpression\n\nWill generate:\n\n    let\n        { first, second } =\n            { first = \"Hello\", second = \"world!\" }\n    in\n    first ++ second\n\n\n# Functions\n\nHere's an example of declaring functions in a let expression:\n\n    import Elm\n    import Elm.Let as Let\n\n    Let.letIn\n        (\\myFn ->\n            myFn (Elm.bool True)\n        )\n        |> Let.fn \"myFn\"\n            (Arg.varWith \"arg\" Type.bool )\n            (\\arg ->\n                Elm.ifThen arg\n                    (Elm.string \"True\")\n                    (Elm.string \"False\")\n            )\n        |> Let.toExpression\n\nwill generate\n\n    let\n        myFn arg =\n            if arg then\n                \"True\"\n\n            else\n                \"False\"\n    in\n    myFn True\n\n@docs fn, fn2, fn3\n\n\n# Converting to an Expression\n\n@docs toExpression, withBody\n\n","unions":[{"name":"Let","comment":" ","args":["a"],"cases":[]}],"aliases":[],"values":[{"name":"fn","comment":" ","type":"String.String -> Elm.Arg arg -> (arg -> Elm.Expression) -> Elm.Let.Let ((Elm.Expression -> Elm.Expression) -> a) -> Elm.Let.Let a"},{"name":"fn2","comment":" ","type":"String.String -> Elm.Arg one -> Elm.Arg two -> (one -> two -> Elm.Expression) -> Elm.Let.Let ((Elm.Expression -> Elm.Expression -> Elm.Expression) -> a) -> Elm.Let.Let a"},{"name":"fn3","comment":" ","type":"String.String -> Elm.Arg one -> Elm.Arg two -> Elm.Arg three -> (one -> two -> three -> Elm.Expression) -> Elm.Let.Let ((Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> a) -> Elm.Let.Let a"},{"name":"letIn","comment":" ","type":"a -> Elm.Let.Let a"},{"name":"toExpression","comment":" ","type":"Elm.Let.Let Elm.Expression -> Elm.Expression"},{"name":"unpack","comment":" ","type":"Elm.Arg arg -> Elm.Expression -> Elm.Let.Let (arg -> b) -> Elm.Let.Let b"},{"name":"value","comment":" ","type":"String.String -> Elm.Expression -> Elm.Let.Let (Elm.Expression -> a) -> Elm.Let.Let a"},{"name":"withBody","comment":" Define the body of your `let` at the bottom instead of the top so it matches the generated syntax a bit closer.\n\nThese two are equivalent\nimport Elm\nimport Elm.Let as Let\n\n      Let.letIn\n          (\\one two ->\n              Elm.Op.append one two\n          )\n          |> Let.value \"one\" (Elm.string \"Hello\")\n          |> Let.value \"two\" (Elm.string \"World!\")\n          |> Let.toExpression\n\n\n      Let.letIn Tuple.pair\n          |> Let.value \"one\" (Elm.string \"Hello\")\n          |> Let.value \"two\" (Elm.string \"World!\")\n          |> Let.withBody\n              (\\(one, two) ->\n                  Elm.Op.append one two\n              )\n\nAnd will generate\n\n      let\n          one = \"Hello\"\n          two = \"World!\"\n      in\n      one ++ two\n\n","type":"(val -> Elm.Expression) -> Elm.Let.Let val -> Elm.Expression"}],"binops":[]},{"name":"Elm.Op","comment":" This module helps generate operators!\n\nSo, this\n\n    Elm.Op.equal (Elm.bool True) (Elm.bool False)\n\nWould generate\n\n    True == False\n\n\n## Equality\n\n@docs equal, notEqual, and, or\n\n\n## Lists and strings\n\n@docs append, cons\n\n\n## Math\n\n@docs plus, minus, multiply, divide, intDivide, power\n\n\n## Comparisons\n\n@docs lt, gt, lte, gte\n\n@docs pipe, pipeLeft\n\n@docs parens\n\n\n## Parsing\n\n@docs keep, skip\n\n\n## Url parsing\n\n@docs slash, query\n\n","unions":[],"aliases":[],"values":[{"name":"and","comment":" `&&`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"append","comment":" `++`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"cons","comment":" `::`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"divide","comment":" `/`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"equal","comment":" `==`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"gt","comment":" `>`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"gte","comment":" `>=`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"intDivide","comment":" `//`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"keep","comment":" used in the `elm/parser` library\n\n`|=`\n\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"lt","comment":" `<`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"lte","comment":" `<=`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"minus","comment":" `-`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"multiply","comment":" `*`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"notEqual","comment":" `/=`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"or","comment":" `||`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"parens","comment":" Wrap an expression in parentheses.\n\nGenerally you won't need this as `elm-codegen` handles parens for you, but it can be useful to semantically group operations from this module.\n\n","type":"Elm.Expression -> Elm.Expression"},{"name":"pipe","comment":" `|>`\n\n    Elm.value\n        { importFrom = []\n        , name = \"thang\"\n        , annotation = Nothing\n        }\n        |> Elm.Op.pipe (Elm.value \"thang2\")\n        |> Elm.Op.pipe (Elm.value \"thang3\")\n\nResults in\n\n    thang\n        |> thang2\n        |> thang3\n\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"pipeLeft","comment":" `<|`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"plus","comment":" `+`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"power","comment":" The to-the-power-of operator `^`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"query","comment":" `<?>` used in url parsing\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"skip","comment":" `|.`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"slash","comment":" `</>` used in url parsing\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"}],"binops":[]},{"name":"Elm.ToString","comment":" Convert values to a string!\n\nThis can be useful if you're generating examples or just playing with the library and want to get an intuition for it.\n\n@docs expression, annotation, declaration\n\n\n## With Import Aliases\n\nIf you want further control over import aliases,\n\n@docs expressionWith, annotationWith, declarationWith\n\n","unions":[],"aliases":[],"values":[{"name":"annotation","comment":" ","type":"Elm.Annotation.Annotation -> { imports : String.String, signature : String.String }"},{"name":"annotationWith","comment":" ","type":"{ aliases : List.List ( List.List String.String, String.String ) } -> Elm.Annotation.Annotation -> { imports : String.String, signature : String.String }"},{"name":"declaration","comment":" ","type":"Elm.Declaration -> List.List { imports : String.String, docs : String.String, signature : String.String, body : String.String }"},{"name":"declarationWith","comment":" ","type":"{ aliases : List.List ( List.List String.String, String.String ) } -> Elm.Declaration -> List.List { imports : String.String, docs : String.String, signature : String.String, body : String.String }"},{"name":"expression","comment":" ","type":"Elm.Expression -> { imports : String.String, body : String.String, signature : String.String }"},{"name":"expressionWith","comment":" ","type":"{ aliases : List.List ( List.List String.String, String.String ) } -> Elm.Expression -> { imports : String.String, body : String.String, signature : String.String }"}],"binops":[]}]